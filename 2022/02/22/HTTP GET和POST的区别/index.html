<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>HTTP GET和POST的区别 | 面向money编程</title><meta name="keywords" content="计算机网络"><meta name="author" content="StrokeBun"><meta name="copyright" content="StrokeBun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="GET 和 POST 是 HTTP 发送请求最常用的两种方法，当你用搜索两者的区别时，很容易得到以下回答：  GET 通过 URL 传递参数，而 POST 放在请求体 request body 中； GET 直接在 URL 中暴露参数，相比 POST 更不安全； 对参数的数据类型，GET 只接受 ASCII 字符，而POST没有限制； GET 传递数据大小有限制，而 POST 没有限制； GET">
<meta property="og:type" content="article">
<meta property="og:title" content="HTTP GET和POST的区别">
<meta property="og:url" content="https://strokebun.github.io/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/index.html">
<meta property="og:site_name" content="面向money编程">
<meta property="og:description" content="GET 和 POST 是 HTTP 发送请求最常用的两种方法，当你用搜索两者的区别时，很容易得到以下回答：  GET 通过 URL 传递参数，而 POST 放在请求体 request body 中； GET 直接在 URL 中暴露参数，相比 POST 更不安全； 对参数的数据类型，GET 只接受 ASCII 字符，而POST没有限制； GET 传递数据大小有限制，而 POST 没有限制； GET">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://strokebun.github.io/img/default.jpg">
<meta property="article:published_time" content="2022-02-22T06:30:13.000Z">
<meta property="article:modified_time" content="2022-02-22T09:10:42.525Z">
<meta property="article:author" content="StrokeBun">
<meta property="article:tag" content="计算机网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://strokebun.github.io/img/default.jpg"><link rel="shortcut icon" href="/img/bun.png"><link rel="canonical" href="https://strokebun.github.io/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'HTTP GET和POST的区别',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-02-22 17:10:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">面向money编程</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">HTTP GET和POST的区别</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-22T06:30:13.000Z" title="发表于 2022-02-22 14:30:13">2022-02-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-22T09:10:42.525Z" title="更新于 2022-02-22 17:10:42">2022-02-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="HTTP GET和POST的区别"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>GET 和 POST 是 HTTP 发送请求最常用的两种方法，当你用搜索两者的区别时，很容易得到以下回答：</p>
<ul>
<li>GET 通过 URL 传递参数，而 POST 放在请求体 request body 中；</li>
<li>GET 直接在 URL 中暴露参数，相比 POST 更不安全；</li>
<li>对参数的数据类型，GET 只接受 ASCII 字符，而POST没有限制；</li>
<li>GET 传递数据大小有限制，而 POST 没有限制；</li>
<li>GET 发送一个请求，而 POST 发送两个请求；</li>
<li>……</li>
</ul>
<p>但如果查看相关 RFC 文档的话，便会产生质疑。</p>
<blockquote>
<p>The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.<br>A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.</p>
<p>The POST method requests that the target resource process the representation enclosed in the request according to the resource’s own specific semantics.</p>
</blockquote>
<p>大概意思是 GET 方法的语义是请求指定的资源，不修改数据、幂等、可缓存的，GET 请求的 request body 没有明确语义；而 POST 的语义是根据 request body 的内容处理资源，可能修改数据、不幂等。除此之外没有其他规定了。</p>
<blockquote>
<p>GET 的语义是读取，反复读取不应该有副作用，所以能进行缓存。而 POST 的语义是提交，这往往是有副作用的，因此不能被缓存。</p>
</blockquote>
<p>然而上述说明也不是强制性的，服务端完全可以实现无副作用的 POST 和有副作用的 GET 请求，前者往往没有影响，但后者往往会跟浏览器的预期不符合，所以在服务端往往会遵守 GET 幂等，POST 非幂等的设计。</p>
<blockquote>
<p>但这不代表 POST 接口都是非幂等的，需要根据业务选择。</p>
</blockquote>
<p>那上面说的那些区别怎么解释呢？</p>
<h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p>关于 GET 通过 URL 传递参数，这是因为在使用浏览器时，GET 请求只能由 URL 触发，要携带参数就只能通过 URL，所以才会出现这个说法。</p>
<p>但当把客户端的范围扩大，包括手机设备、postman 这类工具，这时候就没有类似浏览器的限制，只需要遵守 HTTP 请求的格式即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">METHOD</span>&gt;</span> <span class="tag">&lt;<span class="name">URL</span>&gt;</span> <span class="tag">&lt;<span class="name">Version</span>&gt;</span>\r\n</span><br><span class="line"><span class="tag">&lt;<span class="name">Header1</span>&gt;</span>: <span class="tag">&lt;<span class="name">HeaderValue1</span>&gt;</span>\r\n</span><br><span class="line"><span class="tag">&lt;<span class="name">Header2</span>&gt;</span>: <span class="tag">&lt;<span class="name">HeaderValue2</span>&gt;</span>\r\n</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">HeaderN</span>&gt;</span>: <span class="tag">&lt;<span class="name">HeaderValueN</span>&gt;</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line"><span class="tag">&lt;<span class="name">Body</span> <span class="attr">Data....</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中的 METHOD 可以是 GET/POST，也可以是 PUT、DELETE 等。HTTP 协议并没有限制 GET 请求不能有 body，POST 不能将参数放到 URL 上。HTTP 协议交由用户自定义实现，例如 Elastic Search 的搜索功能就使用了携带 body 的 GET。</p>
<p>极高的自由反而是不自由，这样每次开发都得约定一系列规范，造成更多的不便。于是一些统一的规范便出现了，其中最典型的是 REST，REST 规定 GET、POST、PUT 和 DELETE 分别用于获取、创建、替换和删除资源。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>针对安全性有这样的说法，GET 由于在 URL 中暴露参数，相比 POST 更加不安全。但 HTTP 本身就是不安全的，所有的数据都是明文传输的，讨论 GET 和 POST 的安全性没有太大意义，保证安全性应该选用 HTTPS。</p>
<h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>另一个常见说法是 GET 的参数只支持 ASCII，而 POST 没有限制。出现这个说法是因为前一个说法 “GET 通过 URL 传递参数” 推导出来的，而 URL 只能使用 ASCII 字符，POST 使用 body 传输，所以没有限制。</p>
<p>一方面，URL 只能使用 ASCII 这个说法本身就是错误的，RFC 中的规定是 ASCII 的一部分可以不经过编码在 URL 中使用，其他字符需要经过 Percent Encoding。例如本文的 URL <a target="_blank" rel="noopener" href="https://blog.strokebun.top/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/">https://blog.strokebun.top/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</a> 便经过了编码。</p>
<p>另一方面，上文也说到了，GET 和 POST 都能使用 URL 和 body 传递参数，所以 GET 的参数是没有限制的。 </p>
<h4 id="传递数据限制"><a href="#传递数据限制" class="headerlink" title="传递数据限制"></a>传递数据限制</h4><p>上面说到浏览器的 GET 请求通常使用 URL 传递数据，所以 GET 数据有长度限制（也就是 URL 长度限制）。</p>
<p>HTTP 协议对 URL 长度没有任何规定，实际的限制是客户端和服务端共同决定的。一方面，浏览器通常会对输入的 URL 进行了限制，例如 Chrome 限制为 2MB，其他浏览器也有各自的限制；另一方面，服务端例如 tomcat 在处理 url 时需要先分配内存，于是限制长度防止分配过大的内存。</p>
<p>对于 GET 请求的参数过多导致 URL 过长的问题，更推荐采用 body 传输参数。</p>
<h4 id="发送包数"><a href="#发送包数" class="headerlink" title="发送包数"></a>发送包数</h4><p>上面的说法有不少文章已经进行了分析，但其中大部分还提到一点，GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包。</p>
<p>浏览器会把 GET 请求的 header 和 data 一起发送，服务器响应 200；而对于 POST，浏览器先发送 header，服务器响应 100，浏览器再发送 data，服务器响应 200。</p>
<p>一个例子是上传文件，url 包含文件名称，body 是二进制流。服务端接收请求后，先根据 header 校验是否符合规范，不符合就直接丢弃，符合的话可以响应 100，继续接收请求。于是客户端可以做一些优化，如果数据量大就先发送 header，但是不同的客户端实现是不一样的，也可以不做优化。</p>
<p>怎么发包是由客户端自主决定的，只要符合 HTTP 协议就行，这是一种优化，但不是 GET 和 POST 自身的区别。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>RFC 只规定了 GET 和 POST 的语义，二者没有本质的区别，网上提到的大部分区别只是一种约定。但在实际开发中也不用纠结 RFC，协议是人定的，遇到实际问题灵活运用工具，适当反规范没有问题。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">HTTP请求方法 w3school</a></li>
<li><p><a target="_blank" rel="noopener" href="https://www.rfc-editor.org/info/rfc7231">RFC 7231</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd">99%的人都理解错了HTTP中GET与POST的区别</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/28586791/answer/767316172">GET 和 POST 到底有什么区别？ 大宽宽的回答</a></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">StrokeBun</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://strokebun.github.io/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/">https://strokebun.github.io/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://strokebun.github.io" target="_blank">面向money编程</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></div><div class="post_share"><div class="social-share" data-image="/img/default.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/"><img class="next-cover" src="/img/default.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">TCP的粘包</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/17/https%E7%9A%84%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/" title="HTTPS的加密原理"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-17</div><div class="title">HTTPS的加密原理</div></div></a></div><div><a href="/2022/02/17/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/" title="HTTP发展史"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-17</div><div class="title">HTTP发展史</div></div></a></div><div><a href="/2022/02/20/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" title="TCP可靠传输与拥塞控制"><img class="cover" src="/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-20</div><div class="title">TCP可靠传输与拥塞控制</div></div></a></div><div><a href="/2022/02/21/TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/" title="TCP连接的建立与释放"><img class="cover" src="/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">TCP连接的建立与释放</div></div></a></div><div><a href="/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/" title="TCP的粘包"><img class="cover" src="/img/default.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-21</div><div class="title">TCP的粘包</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">StrokeBun</div><div class="author-info__description">Money Oriented Programming</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/strokebun"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E4%BD%93"><span class="toc-number">1.</span> <span class="toc-text">请求体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81"><span class="toc-number">3.</span> <span class="toc-text">编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE%E9%99%90%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">传递数据限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E5%8C%85%E6%95%B0"><span class="toc-number">5.</span> <span class="toc-text">发送包数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number"></span> <span class="toc-text">参考资料</span></a></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" title="HTTP GET和POST的区别">HTTP GET和POST的区别</a><time datetime="2022-02-22T06:30:13.000Z" title="发表于 2022-02-22 14:30:13">2022-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/" title="TCP的粘包">TCP的粘包</a><time datetime="2022-02-21T08:50:21.000Z" title="发表于 2022-02-21 16:50:21">2022-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/21/TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/" title="TCP连接的建立与释放">TCP连接的建立与释放</a><time datetime="2022-02-21T02:42:36.000Z" title="发表于 2022-02-21 10:42:36">2022-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/20/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" title="TCP可靠传输与拥塞控制">TCP可靠传输与拥塞控制</a><time datetime="2022-02-20T09:46:26.000Z" title="发表于 2022-02-20 17:46:26">2022-02-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/17/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/" title="HTTP发展史">HTTP发展史</a><time datetime="2022-02-17T07:26:47.000Z" title="发表于 2022-02-17 15:26:47">2022-02-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By StrokeBun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>