<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>小话设计模式(4)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍行为型的设计模式，主要解决的是类或对象的之间的交互问题，常见的有 观察者模式， 策略模式，模板方法模式。</p><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(3)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍结构型的设计模式，结构型模式总结了类或对象组合在一起的结构，常见的有代理模式、装饰器模式、适配模式、门面模式。</p><p>系列文章：</p><p><a href="/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/">小话设计模式(1)</a></p><p><a href="/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)">小话设计模式(2)</a></p><p><a href="/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/">小话设计模式(4)</a></p><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><p>代理模式即在不改变原始类（被代理类）的情况下，引入代理类给原始类附加功能。主要分为静态代理和动态代理。</p><h3 id="1-1-静态代理"><a href="#1-1-静态代理" class="headerlink" title="1.1 静态代理"></a>1.1 静态代理</h3><p>静态代理要求代理类和被代理类实现同样的接口，在调用相同的接口时，在代理类中进行业务增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="function">UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 业务逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">  <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">(UserController userController)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userController = userController;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">    UserVo userVo = userController.login(telephone, password);</span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">IUserController userController = <span class="keyword">new</span> UserControllerProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>上述代码在原业务逻辑中引入性能监控，UserControllerProxy 也实现了 IUserController 接口，并在 login 业务中添加了性能监控。</p><p>静态代理实现简单，但缺点是需要为每一个原始类都需要创建一个代理类，造成代码膨胀。 </p><h3 id="1-2-动态代理"><a href="#1-2-动态代理" class="headerlink" title="1.2 动态代理"></a>1.2 动态代理</h3><p>为了解决静态代理类膨胀的问题，引入了动态代理。动态代理不事先编写代理类，而是在运行时动态创建代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsCollectorProxy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MetricsCollectorProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    DynamicProxyHandler handler = <span class="keyword">new</span> DynamicProxyHandler(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">      Object result = method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">      String apiName = proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MetricsCollectorProxy proxy = <span class="keyword">new</span> MetricsCollectorProxy();</span><br><span class="line">IUserController userController = (IUserController) proxy.createProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>通过动态代理，我们就得到了一个对于所有实现  IUserController 接口都能实现监控的效果。</p><p>动态代理在 RPC、监控、鉴权以及各种框架中被广泛使用，但也存在一定的性能损耗，在日常业务开发中选择静态代理还是动态代理，需要在性能和代码膨胀中进行权衡。</p><h2 id="2-装饰器模式"><a href="#2-装饰器模式" class="headerlink" title="2. 装饰器模式"></a>2. 装饰器模式</h2><p>装饰器模式允许向一个现有对象添加新的功能，同时不改变新的结构。</p><p>Java IO 中 InputStream 是一个接口，FileInputStream 用来读取文件，BufferedInputStream 支持缓存，可以提高速度。当我们带缓存读取文件时，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">InputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br></pre></td></tr></table></figure><p>可以看到，使用时需要先创建一个 FileInputStream，再将它传给 BufferedInputStream 才能使用，为什么不直接继承实现一个带缓存的文件流 BufferedFileInputStream呢？如果 InputStream 实现类较少的话，那我们直接继承是可以接受的，但是 InputStream 存在大量实现类，如果我们想给每种实现都带缓存，那么需要对每个实现类进行继承，产生大量派生类，类继承结构变得特别复杂。</p><p>设计原则中有 ”组合优于继承“，我们可以使用组合替代继承，引入装饰器模式，下面是 Java IO 流的类似实现思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            fill(); <span class="comment">// fill是读入缓冲区的代码</span></span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.in = in; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...实现读取基本类型数据的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferedInputStream 和  DataInputStream 继承了相同的 InputStream 父类，可以对原始类嵌套多个装饰器类，当我们需要某个功能时，只需要装饰（嵌套）对应功能的实现类即可。</p><p>通过装饰器模式，我们免除了复杂的继承机制，并且可以动态添加和撤销功能。</p><h2 id="3-适配模式"><a href="#3-适配模式" class="headerlink" title="3. 适配模式"></a>3. 适配模式</h2><p>适配模式目的是将不兼容的接口转换为可兼容的接口，让原先接口不兼容的类能够组合工作。生活中常见的例子是各种 USB 转接头，让原本无法直接连接的设备能够通讯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeCToUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleConnect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端typeC的充电线</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接TypeC充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// USB转接</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">TypeCToUSB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TypeC typeC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(TypeC typeC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeC = typeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        typeC.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adapter adapter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">power</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adapter.handleConnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们便实现使用双端 typeC 设备与电脑连接充电。</p><p>适配模式并不复杂，在日常开发中使用适配模式的场景如下：</p><ul><li>封装有缺陷的接口设计，抽象出更好的接口设计</li><li>兼容老版本接口</li><li>当依赖的外部系统被替换时，通过适配模式减少代码改动</li></ul><h2 id="4-门面模式"><a href="#4-门面模式" class="headerlink" title="4. 门面模式"></a>4. 门面模式</h2><p>GoF 中对门面模式的定义是，为子系统提供一组统一的接口，定义高层的接口让子系统更易使用。</p><p>假设有系统 A，提供 a、b、c、d 四个接口，另一个系统 B 想要使用 a、b、d 接口，利用门面模式，我们提供一个包含三个接口的 x 接口，供 B 使用。</p><p>那为什么需要 x 接口呢，直接调用 a、b、d 不可以吗？</p><p>如果 A 是我们平常的后端系统， 而 B 是前端，A 与 B 之间需要通过网络通信。那么如果直接调用 3 个接口，会产生三次网络通信，而调用 x 接口，只需要一次通信，为了加快响应速度，提高用户体验，我们应该尽可能减少网络通信的次数。</p><p>接下来举一个家庭影院的例子，家中有空调、影碟机和爆米花机，我们希望有一个上层系统进行控制，开启/关闭系统后自动打开/关闭所有设备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeFacade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DVDPlayer dvdPlayer;</span><br><span class="line">    <span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line">    <span class="comment">// 省略构造函数...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.on();</span><br><span class="line">        popcorn.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">        airCondition.down();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airCondition.off();</span><br><span class="line">        popcorn.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括而言，门面模式做接口整合，解决是多接口调用带来的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://www.bilibili.com/video/BV1G4411c7N4?from=search&seid=17614039806864782413&spm_id_from=333.337.0.0">尚硅谷：设计模式</a></li><li><a href="https://www.runoob.com/design-pattern/decorator-pattern.html">装饰器模式 菜鸟教程</a></li><li><a href="https://book.douban.com/subject/1052241/">设计模式</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(2)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍常见的创建型设计模式，主要有单例、工厂和建造者模式。</p><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><p>单例模式是一个很容易理解的概念，要求一个类只能创建一个对象，并提供全局访问点，常用场景是存储配置信息或者唯一高消耗资源。</p><p>实现单例模式的主要考虑点为：</p><ul><li>构造函数外部无法访问</li><li>对象创建时线程安全</li><li>是否需要延迟加载</li></ul><p>具体实现主要有两种方式，饿汉式和懒汉式，下文将会以一个 id 生成器进行举例。</p><h3 id="1-1-饿汉式"><a href="#1-1-饿汉式" class="headerlink" title="1.1 饿汉式"></a>1.1 饿汉式</h3><p>饿汉式实现即在类加载之后，该实例就已经创建完成，该实例创建的时候是线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式的优点是实现非常简单，有人认为这种方式提前初始化会提前创建对象却不使用，导致资源浪费，个人不认同这种观点，在系统启动后去执行耗时的操作，可能会影响系统的性能，不如将这耗时的操作提前到系统初始化之时。</p><h3 id="1-2-懒汉式"><a href="#1-2-懒汉式" class="headerlink" title="1.2 懒汉式"></a>1.2 懒汉式</h3><p>与饿汉式对应的是懒汉式，将对象的初始化延迟。在 java 中有多种方式可以实现懒汉式，这里主要推荐静态内部类和枚举的方式。</p><ul><li>静态内部类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式依赖类加载机制，当调用 getInstance() 方法时，内部类才会进行加载，instance 才会被创建，其唯一性和线程安全性由 JVM 进行保证。</p><ul><li>枚举：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式依赖 java 枚举为单例的性质，实现最为简单，推荐使用。</p><p>说明：懒汉式中还有一种双重检测的实现方式，但这种方式实现复杂，注意点多，甚至在低版本 jdk 下都无法保证正确实现单例模式。个人不推荐使用这种方式，但在此还是提供实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> IdGenerator instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (IdGenerator.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><p>工厂模式主要用于创建对象，可分为简单工厂、工厂方法和抽象工厂。其中抽象工厂较为复杂，在日常开发中较少使用，下文以一个车辆工厂举例介绍简单工厂和工厂方法。</p><h3 id="2-1-简单工厂"><a href="#2-1-简单工厂" class="headerlink" title="2.1 简单工厂"></a>2.1 简单工厂</h3><p>简单工厂将创建对象的逻辑汇集到一个工厂类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;五菱&quot;</span>.equals(car)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;特斯拉&quot;</span>.equals(car)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getWuling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getTesla</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建车辆的代码被汇集到 CarFactory 中，并且提供按品牌创建车辆对象的方法。简单工厂并不是一个设计模式，它没有用到面向对象的任何特性，它更像是一种编程习惯，将类似功能的代码整合，并没有提升代码的拓展性。</p><h3 id="2-2-工厂方法"><a href="#2-2-工厂方法" class="headerlink" title="2.2 工厂方法"></a>2.2 工厂方法</h3><p>当需要拓展新类型时，简单工厂仍需要在一堆 if-else 中进行改动，要避免这种情况，需要利用多态的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;特斯拉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wuling</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;五菱宏光&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WulingFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeslaFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了一个工厂接口，并且实现了五菱和特斯拉的工厂类。当我们需要创建对象时，先创建对应的工厂，再调用 create 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ICarFactory teslaFactory = <span class="keyword">new</span> TeslaFactory();</span><br><span class="line">Car tesla = teslaFactory.create();</span><br><span class="line">ICarFactory wulingFactory = <span class="keyword">new</span> WulingFactory();</span><br><span class="line">Car wuling = wulingFactory.create();</span><br></pre></td></tr></table></figure><p>工厂方法即提供创建对象的统一接口，并将创建对象的具体实现交由子类实现。</p><h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3 应用场景"></a>2.3 应用场景</h3><p>那什么时候选择简单工厂，什么时候选择工厂方法呢？</p><ul><li>如果创建对象的代码块比较简单，只有两三种类型，推荐不进行拆分</li><li>当创建对象的类型较多，并且各个对象的创建逻辑较为简单时，例如只需要简单的 new 操作，选择简单工厂模式</li><li>当各个对象的创建逻辑较为复杂，需要复杂的初始化时，选择工厂方法模式，将复杂的逻辑分散到各个工厂子类中</li></ul><h2 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h2><h3 id="3-1-头疼的初始化"><a href="#3-1-头疼的初始化" class="headerlink" title="3.1 头疼的初始化"></a>3.1 头疼的初始化</h3><p>在日常开发中，创建一个对象的常用方式是直接调用该类的构造函数。但是当成员属性较多，并且有部分属性初始化是可选的时，我们需要重载大量的构造函数，代码的可读性和易用性都降低了。</p><p>有一种解决方案是提供一个简单的构造函数和 setter 方法，在创建一个对象之后，调用 setter 给需要的属性赋值。这种方案能够解决一定问题，但仍存在缺陷：</p><ul><li>必须初始化的属性依赖程序员而不是编译器确认，如果使用者忘记初始化，会影响后续的业务逻辑</li><li>建造过程中可能处于不一致的状态，没法通过检查构造参数实现一致性</li><li>该类要求是不可变对象，不应该提供 setter</li></ul><h3 id="3-2-建造者模式"><a href="#3-2-建造者模式" class="headerlink" title="3.2 建造者模式"></a>3.2 建造者模式</h3><p>为了解决这些问题，建造者模式由此产生。建造者模式在类中内置一个建造者 Builder 类，并且区分必选项和可选项，摆脱陷入大量重载构造函数的泥泽之中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化必选项</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">        <span class="comment">// 初始化可选项，提供默认值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://www.bilibili.com/video/BV1G4411c7N4?from=search&seid=17614039806864782413&spm_id_from=333.337.0.0">尚硅谷：设计模式</a></li><li><a href="https://book.douban.com/subject/30412517/">effective java</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(1)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>设计模式是一门经验课，相比于数据结构和算法让人写出高效的代码，设计模式让人实现可拓展、可维护的高质量代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈面向对象编程</title>
      <link href="/2022/01/24/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/24/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>面向过程是一种编程范式，以过程（函数）作为单元组织代码，数据与过程相分离，主要是对过程进行抽象，将其组合为函数，代表语言 C 语言。</p><p>而面向对象也是一种编程范式，以对象（类）作为组织代码的单元，主要是对数据进行抽象，将其组合为类，具有封装、继承、多态三个特性，代表语言有 C++、Java、C#。</p><p>面向对象相比于面向过程有以下优势：</p><ul><li>更适合于复杂大规模程序开发</li><li>OOP 风格的代码更容易复用、拓展和维护</li></ul><p>说明：面向过程也并一无是处，没有纯粹的 OOP，面向对象的编程语言在宏观上是面向对象，但在微观上仍是面向过程的。 面向过程的 C 语言也可以实现不完全的面向对象特性：</p><ul><li>封装：使用 static 关键字</li><li>继承：用组合代替</li><li>多态：利用函数指针实现，redis 和 linux 内核中的 VFS 就是使用这种方法实现多态</li></ul><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h2><h3 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h3><p>封装是将相关的数据和操作汇集到类模块，并暴露有限的接口供外部访问内部数据，用户不需要也无权访问其底层实现。</p><p>意义：</p><ul><li>降低修改的灵活性，提高代码的可控性</li><li>降低使用负担，使用者只需关注暴露的接口即可</li></ul><p>原则：</p><ul><li>当不确定内部属性的访问权限时，优先考虑最低的访问权限。当将一个属性的访问权限从 public 改为 private 可能导致大量的代码改动，反之只要小量或者没有代码改动。</li><li>有必要时才提供 setter 方法</li><li>当获取或者设置类的可变属性时，考虑采用防御性复制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(person.toString());</span><br><span class="line"><span class="comment">// Person&#123;birthday=Mon Jan 24 09:21:38 CST 2022&#125;</span></span><br><span class="line">Date birthday = person.getBirthday();</span><br><span class="line">birthday.setYear(<span class="number">98</span>);</span><br><span class="line">System.out.println(person.toString());</span><br><span class="line"><span class="comment">// Person&#123;birthday=Sat Jan 24 09:21:38 CST 1998&#125;</span></span><br></pre></td></tr></table></figure><p>上述测试代码中 <code>getBirthday</code> 方法返回的是可变的 <code>Date</code> 对象，在外部对该 <code>Date</code> 对象进行修改会导致 <code>Person</code> 业务逻辑错误。问题根源是 birthday 虽然是引用类型，但语意上应该是值类型，我们关心的是它的值，不希望不同引用对其进行同步修改。</p><p>修改方式是采用防御性复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> birthday == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Date(birthday.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>Date</code> 可变是一种设计错误，其一系列 getter/setter 已被弃用</li><li>是否采用防御性复制，需要根据其语意和实际类型是否统一判断</li></ul><h3 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h3><p>此处讨论的继承为广义的继承，不局限于继承具体类。</p><p>从可继承数量上分为：</p><ul><li>单继承：一个类只能继承一个父类，代表语言 Java、C#</li><li>多继承：一个类能继承多个父类，代表语言 C++。多继承会存在菱形问题，类 B 和 C 继承 A，都重写了某一个方法，现有类 D 继承 B 和 C，该方法继承 B 还是 C 会存在歧义 </li></ul><p>根据继承类型分为：</p><ul><li>接口继承：实现某一个接口，<strong>生成可复用的代码</strong>，Java 中采用 implements 关键字</li><li>实现继承：继承某个类，<strong>复用已有的代码</strong>，Java 中采用 extends 关键字</li></ul><p>原则：</p><ul><li>提倡接口继承，慎用实现继承</li><li>优先考虑组合而不是继承。一方面继承带来了更大的耦合，父类改动时需要谨慎考虑对子类的影响，降低了拓展性；另一方面子类可以通过重写破坏父类精心设计的封装</li><li>考虑使用继承的情况：1. 继承层次浅，继承关系不复杂；2.模板方法设计模式；</li></ul><p>3.无法改变一个方法的参数类型，并且该参数不是接口，考虑使用继承进行拓展</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    client.encode(url);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedClient</span> <span class="keyword">extends</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写该方法实现自己的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">Client client = <span class="keyword">new</span> CustomizedClient();</span><br><span class="line">f(client);</span><br></pre></td></tr></table></figure><ul><li>继承应遵守里氏替换原则，能够向上转型，常规逻辑的 is-a 关系不是使用继承的充分条件，需要<strong>考虑父类/接口的契约，子类需要履行所有契约</strong>。一个直观的测试方法：子类能够通过父类的所有的单元测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List接口，供举例说明，与java.util.List定义不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个元素到列表的末尾</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体实现...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中 <code>SortedList</code> 实现了 <code>List</code> 接口，但 <code>SortedList</code> 在插入元素应该将其存放在合适的位置，并不一定是末尾，并不遵守 <code>List</code> 的契约。直觉上 <code>SortedList</code> 是<code>List</code>，但从设计角度不应该实现 <code>List</code> 接口，考虑使用更上级的 <code>Collection</code> 接口。</p><p>jdk 中的设计错误：</p><p>1.<code>Stack</code> 继承了 <code>Vector</code>，栈从定义上并不具备 <code>Vector</code> 中随机访问和删除等功能，不应该使用继承。正确方式是使用组合，在内部维护一个 <code>Vector</code>，对外提供入栈、出栈等方法。</p><p>2.<code>Properties</code> 继承了 <code>HashTable&lt;Object, Object&gt;</code>，<code>Properties</code> 相比 <code>HashTable</code> 而言多了 IO 读取和持久化等功能。但是其 key 和 value 都应该是 <code>String</code> 类型，如果 <code>Properties</code> 调用继承<code>HashTable</code> 的 <code>put</code> 方法插入非 <code>String</code> 类型的 k/v 时，在持久化时会导致强制转型失败。正确方式是继承 <code>HashTable&lt;String, String&gt;</code> 或者使用组合。</p><h3 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h3><p>广义的多态可分为：</p><ul><li>静态多态：也称参数多态，在编译期确定类型，让相同的代码应用在不同类型。例如 C++ 中的 template（采用异构翻译，即为每一个类型创建一份代码），Java 中的泛型（采用同构翻译，即类型擦除，所有类型都会被转为 Object）</li><li>动态多态：也称子类型多态，在运行期确定，让不同的实现代码应用在相同的场合。OOP 中讨论的多态通常指动态多态</li></ul><p>多态可以提高代码的拓展性和复用性，也是很多设计模式的继承。在 OOP 中多态依赖继承实现，继承是多态的基础，多态是继承的目的。</p><p>设计原则：</p><ul><li>设计接口和父类时，需要谨慎设计契约</li></ul><p>这里举一个常见的鸟类案例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;ostrich can&#x27;t fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了父类鸟类，并定义 <code>fly</code> 方法，子类鸵鸟继承了该类，但由于鸵鸟无法飞，<code>fly</code> 方法中抛出异常。一方面是上文所言鸵鸟无法实现父类的契约，不应该继承该类；另一方面，抽象出鸟类时应该考虑到不是所有鸟都会飞，不应该提供 <code>fly</code> 方法。更好的方式是将 <code>fly</code> 放到 <code>Flyable</code></p><p>接口中，而鸵鸟类不实现该接口。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="type">Flyable</span> &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AbstractBird</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eagle</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> <span class="title">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    void fly() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3.结语"></a>3.结语</h2><p>设计再良好的系统，在烂代码的侵蚀下最终会变得不可控。在考虑总体架构设计之后，也别忽略对模块、类、方法的设计，勿在浮沙筑高楼，好的架构师首先得是一个好的程序员。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/4031906/">冒号课堂 编程范式和OOP思想</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://book.douban.com/subject/2334288/">大话设计模式</a></li><li><a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">Google Tech Talk: How to design a good API</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 编程思维 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
