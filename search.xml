<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java并发编程(4) CAS</title>
      <link href="/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(4)%20CAS/"/>
      <url>/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(4)%20CAS/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a>1.  介绍</h2><p>锁可以分为：</p><ul><li>悲观锁：认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</li><li>乐观锁：总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。</li></ul><p>由于无锁操作中没有锁的存在，因此不会出现死锁，换句话说，乐观锁免疫死锁。</p><p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p><p>乐观锁底层依赖 CAS 实现，CAS，Compare and Swap，比较并交换，是一种乐观锁实现。CAS 有 3 个操作数，内存位置 V，期望值 A，新值 B，如果 V 中的值等于 A，则将 V 中的数据更新为 B；否则则不进行操作，最终返回 V 的数值。</p><h2 id="2-Java中的CAS"><a href="#2-Java中的CAS" class="headerlink" title="2. Java中的CAS"></a>2. Java中的CAS</h2><p>sun.misc.Unsafe 包中提供了 CAS 支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* var1: 要操作的对象</span></span><br><span class="line"><span class="comment">* var2: 要操作的属性的地址偏移量</span></span><br><span class="line"><span class="comment">* var1 + var2 可以确定内存位置V的值</span></span><br><span class="line"><span class="comment">* var4: 期望值A</span></span><br><span class="line"><span class="comment">* var5: 新值B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>CAS 是 atomic 包的原子类的实现基础。例如 AtmoicInteger 的 getAndSet 方法，即通过 CAS 设置新值并返回旧值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-CAS底层实现"><a href="#3-CAS底层实现" class="headerlink" title="3. CAS底层实现"></a>3. CAS底层实现</h2><p>在 intel x86 平台下，CAS 通过 cmpxchg 指令实现：</p><ul><li>多处理器: 添加 lock 前缀</li><li>单处理器: 不添加 lock 前缀</li></ul><p>lock 前缀的指令具有以下特点：</p><ul><li>如果待访问的数据已经位于 cache 中，并且 Cache Line 的状态为已修改或独占，则直接更新，否则锁住总线进行更新</li><li>禁止该指令前后的读写指令重排序</li><li>将写缓冲区的数据刷新到内存</li></ul><h2 id="4-CAS-的不足"><a href="#4-CAS-的不足" class="headerlink" title="4. CAS 的不足"></a>4. CAS 的不足</h2><ul><li><p>循环时间长，高并发下开销大</p></li><li><p>只能保证一个变量的原子操作</p><p>解决方案：AtomicReference 类能够保证对象之间的原子性，可以把多个变量放到一个对象里面进行 CAS 操作。</p></li><li><p>ABA 问题：一个变量的数据由 A 改为 B 再改为 A，CAS 无法分辨</p><p>解决方案：增加了版本号 version</p><p>JDK 提供了 AtomicStampedReference 作为解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类Pair包括引用和版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * expectedReference: 期望引用</span></span><br><span class="line"><span class="comment">   * newReference: 新值引用</span></span><br><span class="line"><span class="comment">   * expectedStamp: 期望版本号</span></span><br><span class="line"><span class="comment">   * newStamp: 新版本号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 V   newReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp; <span class="comment">// 引用一致</span></span><br><span class="line">            expectedStamp == current.stamp &amp;&amp; <span class="comment">// 版本一致</span></span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp))); <span class="comment">// 设置新值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(3) synchronized</title>
      <link href="/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(3)%20synchronized/"/>
      <url>/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(3)%20synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>synchronized 是 Java 中的一个关键字，用于对代码块的互斥访问，是非公平可重入锁。</p><blockquote><p>公平锁指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，非公平锁则不保证该顺序性；可重入锁又称递归锁，指该获取到锁的线程，递归调用再次访问互斥代码块时，不会被阻塞。</p></blockquote><p>synchronized 有三种加锁方式：</p><ul><li>普通方法，相当于给 实例对象加锁，进入同步代码之前要获得当前实例的锁</li><li>静态方法，相当于给类对象加锁</li><li>代码块，需要指定加锁对象</li></ul><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><p>synchronized 经过编译之后，会在同步块前后形成 monitorenter 和 monitorexit，当执行 monitorenter 指令时，尝试获取锁，获取成功则计数 +1，执行 monitorexit 则计数 -1，当计数为 0 时，锁即被释放。</p><p>monitorenter 和 monitorexit 两个指令，主要是基于 Mark Word 实现的。Java 的对象头由 Mark Word 和 Klass Point 组成。</p><ul><li><p>Mark Word：存储对象的运行数据，64 位 JVM 的 Mark Word 组成如下：</p><p><img src="markword.png" alt="alt"></p><p>其中 monitor 字段即指向堆中相应的监视器对象。</p></li><li><p>Klass Point：指向类元数据（方法区中的 Klass 对象）的指针</p></li></ul><p>在 JVM 层面，监视器对象含有 owner 属性，当获取锁时，使用 CAS 尝试将该字段设置为当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 该线程获取锁的次数</span></span><br><span class="line">    _owner        = NULL; <span class="comment">// 持有ObjectMonitor对象的线程</span></span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 等待锁释放的线程队列</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-锁升级"><a href="#3-锁升级" class="headerlink" title="3. 锁升级"></a>3. 锁升级</h2><p>传统的锁（下文的重量级锁）依赖操作系统的同步函数，涉及用户态和内核态的切换，而程序实际运行时可能并不存在多线程竞争，此时使用这种机制是十分低效的。</p><p>针对上述问题，在 jdk 1.6 时引入偏向锁和轻量级锁，并搭配锁升级机制，解决没有多线程竞争和少量竞争的场景下重量级锁的性能开销问题。</p><h3 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h3><p>Hotspot 的开发人员发现很多情况下锁不存在多线程竞争，总由同一个线程多次获得，于是引入偏向锁。偏向锁会偏向第一个访问锁的线程，在接下来的运行过程中，如果该锁没有被其他线程访问，则持有偏向锁的线程将不会触发同步。偏向锁只在第一次获取锁时有一个 CAS 操作，后续操作只会执行几个简单的命令。</p><p>新创建对象的 Mark Word 是可偏向状态，其中的 thread id 为 0，称为匿名偏向。</p><h4 id="偏向锁的加锁"><a href="#偏向锁的加锁" class="headerlink" title="偏向锁的加锁"></a>偏向锁的加锁</h4><ul><li>该对象第一次被线程获取锁，为匿名偏向状态，会使用 CAS 尝试将 thread id 改为当前线程，成功则获得锁，否则撤销偏向锁，并升级为轻量级锁</li><li>被偏向的线程再次进入同步块，发现 thread id 为自身，则往当前线程栈中添加一条 Lock Record，并指向锁对象，执行同步代码块</li><li>当其他线程进入同步块，发生锁已偏向，进入撤销锁的逻辑</li></ul><p>锁升级的时机为：当锁已经发生偏向后，如果另一个线程尝试获得未释放的偏向锁，就会升级成轻量级锁。</p><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>偏向锁的撤销需要等待 safe point，暂停所有线程，并进行判断：</p><ul><li>偏向的线程仍存活并且在同步块中，则升级为轻量级锁，原偏向的线程继续拥有锁</li><li>偏向的线程已经死亡或者不在同步块，则将 Mark Word 改为无锁状态，升级为轻量级锁</li></ul><blockquote><p>hotspot 团队在多年验证之后发现，鉴于撤销锁的高成本，从整体而言偏向锁带来的性能提升没有太大收益，偏向锁在 jdk 15 中已经默认关闭偏向锁。</p></blockquote><h3 id="3-2-轻量级锁"><a href="#3-2-轻量级锁" class="headerlink" title="3.2 轻量级锁"></a>3.2 轻量级锁</h3><p>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁使用的操作系统互斥量带来的开销。</p><h4 id="轻量级锁的加锁"><a href="#轻量级锁的加锁" class="headerlink" title="轻量级锁的加锁"></a>轻量级锁的加锁</h4><p>JVM 会为每次线程在线程栈中创建空间存储锁记录 Lock Record，这个空间称为 Displaced Mark Word。如果一个线程获得锁时发现是轻量级锁，则将锁对象的 Mark Word 复制到自己的 Displaced Mark Word。</p><p>线程尝试用 CAS 自旋将锁的 Mark Word 替换为指向 Lock Record 的指针，成功则获取锁，失败则说明有其他线程在竞争锁。</p><p>当自旋超过一定次数之后，则会升级为重量级锁。</p><h4 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h4><p>释放锁时，当前线程使用 CAS 将 Displaced Mark Word 的内容复制回锁的 Mark Word，没有发生竞争则会成功，如果已经升级为重量级锁，则复制失败，此时会释放锁并唤醒被阻塞的线程。</p><h3 id="3-3-重量级锁"><a href="#3-3-重量级锁" class="headerlink" title="3.3 重量级锁"></a>3.3 重量级锁</h3><p>重量级锁依赖于操作系统的互斥量实现的，效率很低，但被阻塞的线程不会消耗 CPU。</p><p>一个 monitor 对象包括两个同步队列 cxq 和 EntryList，以及一个等待队列 WaitSet，都为 ObjectWaiter 组成的链表。</p><p><img src="重量级锁.png" alt="alt"></p><p>当一个线程尝试获得重量级锁失败时，将该线程封装为 ObjectWaiter 插入到 cxq 队列队首，并挂起当前线程，进入 BLOCKED 状态；当线程释放锁时，会根据唤醒策略，从 cxq 或 EntryList 中挑选一个线程唤醒。</p><p>如果调用的是 wait 方法，则将该线程加入 WaitSet，该线程进入 WAITING 或 TIMED_WAITING 状态。当被 notify 唤醒后，会将线程从 WaitSet 移动到 cxq 或 EntryList 中去，进入 BLOCKED 状态。</p><p>锁升级的全流程如下图：</p><p><img src="锁升级.png" alt="alt"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://github.com/farmerjohngit/myblog/issues/12">死磕synchronized底层实现</a></li><li><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a></li><li><a href="http://concurrent.redspider.group/article/02/9.html">深入浅出Java多线程</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计(1): 短域名系统</title>
      <link href="/2022/02/05/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1(1)%20%E7%9F%AD%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/02/05/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1(1)%20%E7%9F%AD%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>短域名 TinyURL 是一个在线服务，可以将长的 URL 转化为一个短的 URL 完成重定向。</p><p>微博/Twitter 要求推文限制在 100 多个字符，如果直接使用原始链接，将大幅度限制用户的发表字数；日常使用的二维码是根据字符生成的，长 URL 生成的二维码更加不好识别。</p><p>以上场景导致短域名系统的出现。</p><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><h3 id="2-1-系统输入"><a href="#2-1-系统输入" class="headerlink" title="2.1 系统输入"></a>2.1 系统输入</h3><ul><li>一个冗长的域名</li><li>一个自定义的别名</li><li>一个过期时间</li></ul><h3 id="2-2-系统输出"><a href="#2-2-系统输出" class="headerlink" title="2.2 系统输出"></a>2.2 系统输出</h3><p>自定义别名或者随机生成的短域名，在过期时间到来前访问都可以被重定向到原始的冗长域名上</p><h3 id="2-3-系统要求"><a href="#2-3-系统要求" class="headerlink" title="2.3 系统要求"></a>2.3 系统要求</h3><h4 id="2-3-1-需求"><a href="#2-3-1-需求" class="headerlink" title="2.3.1 需求"></a>2.3.1 需求</h4><ul><li>过期后短域名将失效</li><li>短域名是唯一的</li><li>支持自定义短域名，并且限制规则</li></ul><h4 id="2-3-2-系统指标"><a href="#2-3-2-系统指标" class="headerlink" title="2.3.2 系统指标"></a>2.3.2 系统指标</h4><ul><li>读多写少系统，估算 1 亿用户使用<ul><li>写 QPS = 100 M * 0.1 / 86400 = 1k -&gt; 峰值 2k -&gt; 预估值 = 4k</li><li>读 QPS = 100 M * 10 / 86400 = 115k -&gt; 峰值 230k -&gt; 预估值 = 460k</li></ul></li></ul><blockquote><p>系统设计时需要考虑峰值和预估值，峰值为用户访问的上限值，预估值为经过几年用户增长后，用户访问的上限值。</p></blockquote><ul><li>延迟、可靠性（几个 9）、安全性</li></ul><h2 id="3-方案设计"><a href="#3-方案设计" class="headerlink" title="3. 方案设计"></a>3. 方案设计</h2><h3 id="3-1-可行解"><a href="#3-1-可行解" class="headerlink" title="3.1 可行解"></a>3.1 可行解</h3><p>先从业务需要简单实现一个可用的系统，需要完成以下接口。</p><p>写接口：</p><ul><li>输入长域名，判断是否存储</li><li>生成一个从未使用过的短域名</li><li>将长域名和短域名的关联持久化到数据库中</li></ul><p>读接口：</p><ul><li>获取短域名，判断是否有效</li><li>根据短域名查询长域名</li><li>使用长域名通知客户端重定向</li></ul><h4 id="处理过期时间"><a href="#处理过期时间" class="headerlink" title="处理过期时间"></a>处理过期时间</h4><p>增加过期时间有以下方案：</p><ul><li>延迟删除：获取短域名时判断是否过期，过期则进行删除。优点是性能损失小，修改方便；缺点是造成空间浪费</li><li>定时删除：设置定时任务，为每个短域名设置删除回调，过期则立即删除。优点是空间利用率最高；缺点是维护定时任务占用大量内存，性能差</li><li>轮询删除：设置后台逻辑，定时清理过期元素。空间和性能的折中考虑。</li></ul><p>由于系统要求低延迟，性能要求高，故选择延迟删除方案。</p><h4 id="保证域名唯一"><a href="#保证域名唯一" class="headerlink" title="保证域名唯一"></a>保证域名唯一</h4><p>一个全局唯一的分布式 id 便能保证域名的唯一性，实现分布式 id 有以下方案：</p><ul><li>哈希，需要处理哈希冲突</li><li>UUID，性能损耗大</li><li>数据库自增 id，可以通过号端模式降低性能开销，但安全性较低</li><li>雪花算法</li></ul><p>综上，一个可行的系统如下图所示：</p><p><img src="可行解.png" alt="alt"></p><h3 id="3-2-系统优化"><a href="#3-2-系统优化" class="headerlink" title="3.2 系统优化"></a>3.2 系统优化</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul><li>水平拓展系统，使用 NGINX 进行负载均衡</li><li>进行分片、数据副本</li></ul><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>数据库层面：</p><ul><li>数据表的业务逻辑很简单，考虑将关系型数据库改为持久化 kv 引擎，例如 LevelDB</li><li>构建索引：写入时需要判断长域名是否存在，对长域名建立索引</li></ul><p>缓存层面：</p><ul><li>判断长域名是否存储和短域名是否分配，可以构建布隆过滤器</li><li>考虑在客户端建立缓存，存储长短域名映射，进一步降低延迟</li></ul><p>业务层面：</p><ul><li>利用号端模式获取批量 id，降低全局 id 的性能开销</li></ul><h4 id="可靠和安全性"><a href="#可靠和安全性" class="headerlink" title="可靠和安全性"></a>可靠和安全性</h4><ul><li>数据库采用主从模式</li><li>使用 kafka 与 binlog 的方式进行全量与增量的跨机房数据冗余备份</li><li>根据监控指标，进行系统熔点、限流、扩缩容 </li><li>直接使用自增 id 作为短域名，避免被遍历爬取</li><li>进行 IP 限流和黑名单防止 DOS 攻击</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/TinyURL">TinyURL wikipedia</a></li><li><a href="https://www.bilibili.com/video/BV1Jb4y197ks">系统设计 短地址系统</a></li><li><a href="https://hardcore.feishu.cn/docs/doccnAfY0f35ZgnrFg7jSTQmOOf">实现一个短域名系统</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(2): JMM和volatile</title>
      <link href="/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(2)%20JMM%E5%92%8Cvolatile/"/>
      <url>/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(2)%20JMM%E5%92%8Cvolatile/</url>
      
        <content type="html"><![CDATA[<h2 id="1-并发编程模型"><a href="#1-并发编程模型" class="headerlink" title="1. 并发编程模型"></a>1. 并发编程模型</h2><p>在并发编程中，必须解决两个问题：</p><ul><li>线程通信：线程之间通过什么机制交换信息</li><li>线程同步：用什么机制控制不同线程操作的相对顺序</li></ul><p>为了解决上述问题，有两种主流的并发模型：</p><ul><li>消息传递模型：线程之间没有公共状态，线程间通过发送消息进行通信，并且发送消息总是在接收消息之前，因此线程同步是天然的</li><li>共享内存模型：线程之间共享程序的公共状态，通过读写内存进行通信，线程同步必须显示指定某段代码在线程之间互斥执行</li></ul><p>消息传递模型的典型代表是 go 中的 channel，而在 Java 中使用的是共享内存模型。</p><h2 id="2-共享内存模型的三个关键点"><a href="#2-共享内存模型的三个关键点" class="headerlink" title="2. 共享内存模型的三个关键点"></a>2. 共享内存模型的三个关键点</h2><p>当设计共享内存模型时，需要考虑三个关键点：</p><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h3><p>原子性指一个操作是不可中断的，即使在多线程环境中，一个操作一旦开始，也不会被另一个线程打断。</p><p>例如线程 A 和线程 B 同时对一个变量 i 赋值，A 给 i 赋值为 1， B 给 i 赋值为 2，原子性保证 i 的值要么是 1，要么是 2，不会出现其他的值。这样看来原子性保证仿佛是必然的，其实不然，例如对 64 位的 long 类型进行赋值，假设 long 类型的读写不是原子的，那么便可能存在预期之外的数字。</p><h3 id="2-2-可见性"><a href="#2-2-可见性" class="headerlink" title="2.2 可见性"></a>2.2 可见性</h3><p>可见性是指当一个线程修改某一个共享变量的值时，其他线程能够立即知道这个修改。</p><p>对于单线程程序而言，可见性问题是不存在的。在多线程程序中，可能由于缓存的存在，其他线程读取变量时读到的仍是旧值，怎么解决可见性问题也是并发编程的一个考虑点。</p><h3 id="2-3-有序性"><a href="#2-3-有序性" class="headerlink" title="2.3 有序性"></a>2.3 有序性</h3><p>有序性问题指程序在执行过程中，进行指令重排，导致与原指令的顺序未必一致，可能在多线程带代码中导致另一个线程读到脏值。</p><p>指令是否发生重排、如何重排是我们无法预测的，也就是说，线程 A 的执行顺序对于线程 B 而言是没有保证的，而日常开发中线程 B 的结果可能依赖线程  A 部分代码的运行顺序，所以便需要保持其有序性。</p><h2 id="3-JMM"><a href="#3-JMM" class="headerlink" title="3. JMM"></a>3. JMM</h2><h3 id="3-1-硬件的效率与一致性"><a href="#3-1-硬件的效率与一致性" class="headerlink" title="3.1 硬件的效率与一致性"></a>3.1 硬件的效率与一致性</h3><p>为了减少 CPU 和内存之间处理速度带来的限制，现代 CPU 引入了 cache 的概念，CPU 读取数据先从缓存中读取，读取失败后再从内存中读取。</p><p>由于每个 CPU 核心都包含 cache，这也引入了缓存一致性问题，CPU 层面通过 MESI 等缓存一致性协议解决了该问题。除了 cache 之外，为了提高 CPU 的运算效率，会对代码进行指令重排序和乱序执行，CPU 会保证最后的执行结果一致，但不保证代码顺序运行。 </p><blockquote><p>相关知识具体可见博客中的 程序员需要了解的计组知识(2) 和 (3) 。</p></blockquote><h3 id="3-2-JMM"><a href="#3-2-JMM" class="headerlink" title="3.2 JMM"></a>3.2 JMM</h3><p>JMM，Java Memory Model，Java 内存模型与硬件模型高度类似，并且在编译器层面也对指令进行重排序。</p><p>JMM 主要目的是定义程序中共享字段的访问规则。</p><ul><li>所有变量都存储在主内存中（虚拟机内存的一部分，不是计算机中的内存）</li><li>每条线程还要自己的工作内存，线程的工作内存保存了主内存的部分副本，线程对变量的所有操作必须在工作内存中进行</li><li>线程的工作内存是独立的，无法互相访问</li></ul><p><img src="jmm.png" alt="alt"></p><p>所以当线程读取共享变量的值时，先在工作内存中寻找，如果变量已经被更新中，则从主内存中将数据拷贝到工作内存中。</p><h2 id="4-happens-before原则"><a href="#4-happens-before原则" class="headerlink" title="4. happens-before原则"></a>4. happens-before原则</h2><p>上文提到，java 在编译器层面会对指令进行重排序，保证单线程内的最终结果一致，那么对于多线程程序呢？</p><p>一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。</p><p>JMM 在其中找到了平衡点，对编译器和处理器来说，只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。也就是说，JMM 并不能保证未同步的多线程程序与其顺序执行的结果一致。</p><p>不过对程序员也提供了弥补错误，对于使用同步语意（synchronized、volatile、Lock 等），提供了 happens-before 原则，只要程序满足了该原则，便能保证运行结果与预期相同。happens-before定制了两个操作之间的执行顺序，其定义如下：</p><ul><li><p>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p></li><li><p>如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</p></li></ul><p>在 Java 程序中，有如下天然的 happens-before 关系：</p><ul><li>程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens-before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li><li>start 规则：如果线程 A 执行操作 ThreadB.start() 启动线程B，那么 A 线程的 ThreadB.start() 操作 happens-before 于线程 B 中的任意操作、</li><li>join 规则：如果线程 A 执行操作 ThreadB.join() 并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 ThreadB.join()   操作成功返回。</li></ul><h2 id="4-volatile"><a href="#4-volatile" class="headerlink" title="4. volatile"></a>4. volatile</h2><p>在 Java 中，volatile 关键字有两个作用：</p><ul><li>保证变量的内存可见性</li><li>禁止 volatile 变量和普通变量重排序</li></ul><h3 id="4-1-内存可见性"><a href="#4-1-内存可见性" class="headerlink" title="4.1 内存可见性"></a>4.1 内存可见性</h3><p>当一个线程对 volatile 修饰的变量进行写操作时， JMM 会立即把该线程对应的本地内存的值刷新到主内存；而对这个变量进行读操作时， JMM 会立即把该线程的本地内存置为无效，从主内存中读取共享变量的值。</p><p>内存可见性不代表线程安全，例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码允许之后 count 并不为 200000，这是由于自增操作并不保证原子性，所以仍不是线程安全的。</p><h3 id="4-2-禁止指令重排序"><a href="#4-2-禁止指令重排序" class="headerlink" title="4.2 禁止指令重排序"></a>4.2 禁止指令重排序</h3><p>如果允许 volatile 变量和普通变量重排序，可能会发生问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// step 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// step 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// step 3</span></span><br><span class="line">            System.out.println(a); <span class="comment">// step 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中线程 A 调用 writer，线程 B 调用 reader。可能出现以下场景：</p><ul><li>线程 A 设置 flag 为 true</li><li>线程 B 读取 flag 为 true</li><li>线程 B 读普通变量 a 的值为 0</li><li>线程 A 写普通变量 a 的值为 1</li></ul><p>虽然 volatile 保证了内存可见性，但是普通变量的值发生了读取错误。</p><p>故 jdk 1.5 中增强了 volatile 的内存语义，禁止 volatile 变量和普通变量重排序。JVM 层面通过内存屏障来实现，内存屏障是硬件层面而言的，有两个作用：</p><ul><li>屏障两侧的指令进制重排序</li><li>强制把 cache 中的脏数据写入内存，或者使相应的 cache line 失效</li></ul><p>内存屏障有 LoadLoad、LoadStore、StoreStore、StoreLoad 四种。</p><blockquote><p>其规则是 Store 为写指令，Load 为读指令，并按顺序代表屏障前后的指令。例如 LoadLoad 即屏障前后都是读指令，LoadStore 即屏障前是读指令，屏障后是写指令。</p></blockquote><p>对于 volatile 而言，其策略是</p><ul><li>在每个 volatile 写操作前插入一个 StoreStore 屏障</li><li>在每个 volatile 写操作后插入一个 StoreLoad 屏障</li><li>在每个 volatile 读操作后插入一个 LoadLoad 屏障</li><li>在每个 volatile 读操作后再插入一个 LoadStore 屏障</li></ul><p>volatile 禁止重排序的功能最经典的用法是双重检测的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：因为代码复杂，考虑点多，日常开发中不建议双重检测的单例模式，更加推荐使用静态内部类或者枚举的形式，具体可见作者的 小话设计模式(2)。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://concurrent.redspider.group/">深入浅出Java多线程</a></li><li><a href="https://book.douban.com/subject/26663605/">实战Java高并发程序设计</a></li><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/26591326/">Java并发编程的艺术</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(1): 多线程基础</title>
      <link href="/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(1)%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(1)%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><p>在谈论什么是线程之前需要先介绍一下进程。最初的计算机运行方式是串行的，当程序通过网络、IO 请求资源时，必须等待操作完成，在这段等待的时间中计算机的 CPU 资源便被浪费了。为了提高计算机的运行效率，计算机科学家们创建了操作系统，并提出了进程的概念。</p><blockquote><p>程序等待资源返回的过程称为 阻塞。</p></blockquote><p>进程即运行的程序，包括程序代码和资源两个部分，各个进程之间互不干扰，并且保存着各自的运行状态。当遇到网络、IO 等导致进程阻塞时，操作系统将其他可运行的进程调度到 CPU 上运行，提高了计算机的运行效率，给用户一种一段时间内多个程序同时运行的感觉，这被称之为并发。</p><blockquote><p>关于并发与并行，并发指多个任务交替运行，不限制 CPU 核心数；而并行指多个任务在多个 CPU 核心上同时执行，要求是多核 CPU。</p></blockquote><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h3><p>虽然进程的出现提高了计算机的运行效率，但进程对于开发者而言还是存在一些问题：</p><ul><li><p>多进程的通讯较为繁琐，虽然操作系统提供一系列的通信手段，但是对于开发者而言需要熟悉相应操作系统的 API 才能够实现进程通信</p></li><li><p>进程切换的代价太高了，进程的调度过程涉及进程大量资源替换，是一个耗时的工作</p></li></ul><p>于是，计算机科学家们提出了一个新的概念，线程。多个线程共享同一个进程的地址空间，并且更加轻量，相较进程切换成本有所降低。线程是对逻辑的抽象，而进程是对资源的抽象。</p><h3 id="1-3-上下文切换"><a href="#1-3-上下文切换" class="headerlink" title="1.3 上下文切换"></a>1.3 上下文切换</h3><p>当操作系统将一个进程（或线程）切换到另一个进程（或线程）时，需要涉及上下文切换。上下文是指某个时间点 CPU 寄存器和程序计数器的内容，在切换前需要保存当前的上下文，下次切换为这个任务时，可以再加载这个任务的状态，这个上下文保存再加载的过程就是上下文切换。</p><p>上下文操作会消耗大量的 CPU 时间，适合 IO 密集型应用，而对于计算密集型应用，使用太多线程会导致大量的上下文切换，反而会导致性能降低。</p><blockquote><p>计算密集型指操作主要是 CPU 进行计算，较少涉及 IO 操作。IO 密集型指应用经常需要请求 IO 资源，易进入阻塞状态。</p></blockquote><h3 id="1-4-线程实现方式"><a href="#1-4-线程实现方式" class="headerlink" title="1.4 线程实现方式"></a>1.4 线程实现方式</h3><p>(1) 内核线程实现</p><p><img src="内核线程实现.png" alt="alt"></p><p>由内核通过调度器来完成线程切换，优点是每个线程是独立的调度单元，线程之间互不影响，但缺点是线程创建和切换开销大。</p><p>(2) 用户线程实现</p><p><img src="用户线程实现.png" alt="alt"></p><p>完全建立在用户空间，内核无法感知线程的存在，内核只对线程所属的进程进行控制。优点是不依赖内核实现，但用户需要在用户态实现线程创建和调度功能，一般只在不支持多线程的操作系统上使用，实现并发。</p><p>(3) 混合实现</p><p><img src="混合实现.png" alt="alt"></p><p>即存在用户线程，也存在轻量级进程，支持大规模的用户线程并发，同时使用内核线程进行调度和处理映射。用户线程和内核线程的映射有 1:1，M:N 两种形式，Java 线程为 1:1 的形式，go 的 goroutine 为 M:N 的形式。</p><h3 id="2-在Java中使用多线程"><a href="#2-在Java中使用多线程" class="headerlink" title="2. 在Java中使用多线程"></a>2. 在Java中使用多线程</h3><p>在 Java 中有三种线程创建方式，分别为继承 Thread 类，实现 Runnable 接口和实现 Callable 接口。</p><h3 id="2-1-继承-Thread"><a href="#2-1-继承-Thread" class="headerlink" title="2.1 继承 Thread"></a>2.1 继承 Thread</h3><p>继承 Thread 的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意需要调用 start() 方法后，才会创建线程。</p><p>由于 Java 只支持单继承，如果继承了 Thread 类，便无法继承其他类，故直接继承的方式在实际开发中很少使用。</p><h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h3><p>Runnable 接口的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 采用函数式编程实现</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java 8 匿名内部类&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-实现Callable接口"><a href="#2-3-实现Callable接口" class="headerlink" title="2.3 实现Callable接口"></a>2.3 实现Callable接口</h3><p>实现 Runnable 接口没有返回值，如果我们需要任务运行后的返回值，需要依赖 Callable 接口，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallerTask());</span><br><span class="line">        <span class="keyword">new</span> Thread(task).run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;call&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：继承 Thread 的方式较少使用，实现 Runnable 接口在不需要任务返回值的场景使用，需要返回值则采用实现 Callable 接口的方式。</p><h2 id="3-线程状态与切换"><a href="#3-线程状态与切换" class="headerlink" title="3. 线程状态与切换"></a>3. 线程状态与切换</h2><h3 id="3-1-线程状态"><a href="#3-1-线程状态" class="headerlink" title="3.1 线程状态"></a>3.1 线程状态</h3><p>Thread 类中定义了线程的状态为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;  </span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="New"><a href="#New" class="headerlink" title="New"></a>New</h4><p>当创建 Thread 并且未调用 start() 方法时，操作系统还未为此创建线程，此时处于 New 状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br></pre></td></tr></table></figure><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>调用 start() 方法之后，Thread 处于 Runnable 状态，该状态并不一定在 CPU 上运行。</p><blockquote><p>Runnable 在操作系统的状态中还细分为 READY 和 RUNNING，RUNNING 才是在 CPU 上运行。Java 团队认为 READY 切换到 RUNNING 的时间较短，故在 java 中不进行区分。</p></blockquote><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>当线程执行完毕后，状态就变为 TERMINATED，该状态不可逆。</p><h4 id="BLOKCED"><a href="#BLOKCED" class="headerlink" title="BLOKCED"></a>BLOKCED</h4><p>当线程竞争锁失败之后，状态变为 BLOCKED 状态，阻塞等待锁的释放。</p><blockquote><p>BLOCKED 状态不关心内核线程的阻塞态，只针对 Java 层面的锁，例如 synchronized，Lock 等。操作系统的线程在遇到 IO 等也会进入阻塞状态，此时 Thread 的状态是 Runnable。</p></blockquote><h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h4><p>该状态下，线程等待并且无时间限制。</p><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>等待状态，但有时间限制，如果超时则转换为 RUNNABLE 状态。</p><h3 id="3-2-状态切换"><a href="#3-2-状态切换" class="headerlink" title="3.2 状态切换"></a>3.2 状态切换</h3><h4 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h4><p>wait 和 notify 是 Java 多线程等待/通知机制的一种，以下是使用示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadA: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadB: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">ThreadA: <span class="number">0</span></span><br><span class="line">ThreadB: <span class="number">0</span></span><br><span class="line">ThreadA: <span class="number">1</span></span><br><span class="line">ThreadB: <span class="number">1</span></span><br><span class="line">ThreadA: <span class="number">2</span></span><br><span class="line">ThreadB: <span class="number">2</span></span><br><span class="line">ThreadA: <span class="number">3</span></span><br><span class="line">ThreadB: <span class="number">3</span></span><br><span class="line">ThreadA: <span class="number">4</span></span><br><span class="line">ThreadB: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>在上述代码中，线程 A 和线程 B 首先打印出自己的信息，然后使用 notify() 方法叫醒另一个正在等待的线程，然后自己使用 wait() 方法陷入等待并释放 lock 锁。</p><blockquote><p>notify() 会唤醒一个等待的线程，与其对应的还有一个 notifyAll()，会唤醒所有等待的线程。</p><p>wait、notify、notify 需要和 synchronized 配合使用。 </p></blockquote><p>当一个线程调用 wait() 方法后，会进入 WAITING 状态，直到其他线程调用相应的 notify() 方法。</p><p>如果调用 wait(long timeout) ，则进入 TIMED_WAITING 状态。</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>线程调用 sleep(long timeout)，进入 TIMED_WAITING 状态，与 wait(long timeout) 的区别是 sleep 不释放锁。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>调用 join() 之后，当前线程必须等待另一个线程执行完毕，join() 的底层实现是 wait()，与 wait() 的状态转移一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(...);</span><br><span class="line">test.start();</span><br><span class="line"><span class="comment">// 当前线程必须等待test线程执行完毕</span></span><br><span class="line">test.join();</span><br></pre></td></tr></table></figure><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>当一个线程调用 yield() 之后，会主动让出 CPU，进入 RUNNABLE 状态等待调度。</p><h4 id="park和unpark"><a href="#park和unpark" class="headerlink" title="park和unpark"></a>park和unpark</h4><p>每个线程都与一个许可(permit)关联。unpark 函数为线程提供 permit，线程调用 park 则等待（进入WAITING 状态）并消耗permit。park和unpark方法具体实现比较复杂，这里不展开。</p><h4 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h4><p>综上，我们可以得到 Thread 的状态转移图。</p><p><img src="状态转移图.png" alt="alt"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://concurrent.redspider.group/">深入浅出Java多线程</a></li><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/30351286/">Java并发编程之美</a></li><li><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员需要了解的计组知识(3): 存储器</title>
      <link href="/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3)%20%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3)%20%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-存储金字塔"><a href="#1-存储金字塔" class="headerlink" title="1. 存储金字塔"></a>1. 存储金字塔</h2><p>计算机中使用的存储器可分为</p><ul><li><p>RAM ：静态存储器，读写速度快。举例 CPU Cache</p></li><li><p>DRAM ：动态存储器，读写速度慢，集成度高，掉电失去数据。举例 内存</p></li><li><p>硬盘</p></li></ul><p>计算机中使用的存储设备构成了存储器金字塔</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=YjZjYzE2NmNmZTMzYmNlYThkMDc4NjY0Y2VmZjE0OGZfc0ZmdTJ5Sk5FMEt6a0oyTjRyS3poa1BqTFhEQ0FsNDRfVG9rZW46Ym94Y25wNWd5ZVZDYjF1Y0RiMnp3dzh3cWtjXzE2NDMzNjI3Njg6MTY0MzM2NjM2OF9WNA" alt="img"></p><p>各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降。上一层的存储器可以看出下一层存储器的缓存。</p><h2 id="2-局部性原理"><a href="#2-局部性原理" class="headerlink" title="2. 局部性原理"></a>2. 局部性原理</h2><p>上文说到，上层存储是下层存储的缓存，那么通过添加缓存能加快访问吗？</p><p>是的，计算机的前辈们概括出了局部性原理，包括：</p><ul><li>时间局部性：刚被访问的数据，短时间内容易被再次访问</li><li>空间局部性：刚被访问的数据，其附近的数据容易被访问</li></ul><p>其中时间局部性在 内存管理 中得到广泛应用，空间局部性在 cache、文件系统、磁盘缓存、数据库 中得到广泛应用。</p><h2 id="3-cache"><a href="#3-cache" class="headerlink" title="3. cache"></a>3. cache</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>在过去几十年的计算机发展中，CPU 的性能提升远超内存，内存的存取速度严重滞后于处理器的计算速度，内存瓶颈导致高性能处理器难以发挥出应有的功效，这对日益增长的高性能计算形成了极大的制约，这一问题称为 内存墙 Memory wall。</p><p>为了弥补 CPU 和内存之间的性能差距，在 CPU 中引入高速缓存 cache，CPU 先从 cache 尝试访问数据和指令，访问失败再从内存中访问。</p><p>现在的 CPU 一般包含 L1、L2、L3 三级高级缓存，前一级可以当成后一级的缓存，L3 作为内存的缓存。L1、L2 每个核心独有，而 L3 缓存所有核心共用。</p><p>根据空间局部性原理，cache 从内存中读入是按块进行的，这样一块数据，称之为 cache line，cache line 的大小通常是 64 字节。</p><h3 id="3-2-伪共享问题"><a href="#3-2-伪共享问题" class="headerlink" title="3.2 伪共享问题"></a>3.2 伪共享问题</h3><p>Cache 每次都会读入一个 cache line 大小的数据，在多线程环境中，如果两个线程各自的变量（共两个）被放在同一个 cache line，每次写其中一个变量将导致整个 cache line 失效，相当于只有一个线程可以同时访问这个 cache line，降低了访问速度，这被称为伪共享问题。</p><p>伪共享问题的解决方案是进行字节填充。即增加没有实际意义的填充字段，保证一个 cache line 中只能存储一个对象，在 java 中可以使用 <code>@Contended</code> 注解实现。</p><h3 id="3-3-缓存一致性"><a href="#3-3-缓存一致性" class="headerlink" title="3.3 缓存一致性"></a>3.3 缓存一致性</h3><p>在多核 CPU 中，每个核都会有 L1 和 L2 缓存，对于内存中的同一个数据，两个核心的 cache 都了进行缓存，当其中一个核心的程序对该变量进行修改后，另一个核心的 cache 还保留着改动前的数据，可能会业务逻辑错误，这被称为缓存一致性问题。</p><p>解决一致性问题最常见的方案是总线嗅探，即所有的读写请求都经过总线进行广播，其他核心根据这些广播更新自己的缓存。基于总线嗅探有很多协议，其中最常见的是 MESI 协议。</p><p>MESI 协议，是一种写失效协议。在写失效协议中，只有一个 CPU 核心负责写入数据，其他的核心只是同步读取到这个写入。在一个 CPU 核心写入 cache 之后，会广播一个“失效”请求告诉所有其他的 CPU 核心，其他的 CPU 核心判断是否需要将相应的 cache line 标记为脏。</p><p>MESI 对应着 Cache Line 的四个标记：</p><ul><li><p>M：已修改，Modified，脏数据</p></li><li><p>E：独占，Exclusive；当前数据为该 cache 独占，写入不需要广播，如果接收到读取请求，则转变为 S 标记</p></li><li><p>S：共享，Shared；写入前需要进行广播，要求其他核心的 cache line 失效，再更新数据</p></li><li><p>I：已失效，Invalidated，脏数据</p></li></ul><p>其状态图如下</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=YTk0N2U2ODJjNzE0ZGJmNzU1YTk5NjEwOWRiOTk5MGRfUGtvSmhwR2RpWWk0b3p4NWhwYkx4UjNMSHZaeWZQY2hfVG9rZW46Ym94Y242OUc2UW1UYXNDbGVEVUVkVUlpTDdiXzE2NDMzNjI3Njg6MTY0MzM2NjM2OF9WNA" alt="img"></p><p>说明：c、c++、java 中均有 volatile 关键字，被 volatile 修饰的变量，要求写入时直接写入内存，读取时直接从内存读取，底层便依赖 MESI 协议实现。</p><h2 id="4-NUMA"><a href="#4-NUMA" class="headerlink" title="4. NUMA"></a>4. NUMA</h2><p>numa 非统一内存访问是一种关于多个 cpu 核心如何访问内存的架构模型，现在的 cpu 基本都是 numa 架构。</p><p>numa 架构简单而言就是一个 CPU 核心和一组内存插槽构成一个 node，每个核心可以访问自己 node下的内存，也可以访问其他 node 的内存，但是访问自己 node 内存的速度快于其他 node。</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=ODQzN2FmYjEwMzdhMDg4MWM2N2FkOGVlYzlkM2NmNmRfNGptc0JWTFNKVm1VSWVNQzR2RVVwMzA5VTFoTHlxQktfVG9rZW46Ym94Y25DT3dvWnRNSFdlWUxzelVEemo2UHNmXzE2NDMzNjI3Njg6MTY0MzM2NjM2OF9WNA" alt="img"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><p><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></p></li><li><p><a href="https://time.geekbang.org/column/intro/100026001">极客时间：深入浅出计算机组成原理</a></p></li><li><p><a href="https://book.douban.com/subject/1230413/">深入理解计算机系统</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Random-access_memory#Memory_wall">memory wall wikipedia</a></p></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1">程序员需要了解的计组知识(1): 二进制数</a>%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2">程序员需要了解的计组知识(2): CPU</a>%20CPU/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3">程序员需要了解的计组知识(3): 存储器</a>%20%E5%AD%98%E5%82%A8%E5%99%A8/)</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员需要了解的计组知识(2): CPU</title>
      <link href="/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2)%20CPU/"/>
      <url>/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2)%20CPU/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>CPU 从功能上由控制器、运算器、寄存器和时钟四个部分组成，CPU 需要与内存、IO 设备配合工作。程序启动后，根据时钟信号，CPU 会从内存中不断读取指令和数据进行运算，控制器再根据运算结果进行控制。</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFiNzBjOWE0OTYxMTk5NGRkYWI3NjUwMjYyYTNiOWNfcnoxazNGb0xGSW1oalVjeTFIcDF1eUpMM2trRWNjTGJfVG9rZW46Ym94Y25GSEo5YTJYS0xLNUNyUDVjalNyY3RjXzE2NDMzNTY2Mjk6MTY0MzM2MDIyOV9WNA" alt="img"></p><p>这些指令就是最底层的机器语言，由 0 和 1 组成，程序员无法直接阅读，故引入汇编语言。汇编语言是 “给程序员看的机器码”，汇编语言与机器码一一对应，通常将汇编语言转换为机器码的过程称为汇编，将机器码转换为汇编语言称为反汇编。</p><p>对于程序员而言，我们只需要关注其中的寄存器，CPU 是寄存器的集合。</p><h2 id="2-程序控制"><a href="#2-程序控制" class="headerlink" title="2. 程序控制"></a>2. 程序控制</h2><h3 id="2-1-逻辑跳转"><a href="#2-1-逻辑跳转" class="headerlink" title="2.1 逻辑跳转"></a>2.1 逻辑跳转</h3><p>CPU 执行指令，是一条条按顺序执行的，并且有一个 PC 寄存器用来存储下一条要执行指令的地址，上文说到的 CPU 从内存中读取指令，便是根据 PC 寄存器中存放的地址，从内存中加载指令执行。</p><p>汇编语言中包含 jmp、jne、goto 等指令，会直接或者根据条件间接改变 PC 寄存器的值，达到跳转代码的效果。平常代码中的 if else、for/while 循环等会被编译成 jmp 等指令，实现逻辑控制的效果。</p><h3 id="2-2-函数调用"><a href="#2-2-函数调用" class="headerlink" title="2.2 函数调用"></a>2.2 函数调用</h3><p>函数调用也是通过设置 PC 寄存器为函数的地址实现的，不过与逻辑跳转不一样的地方在于，函数调用不是使用 jmp 等指令，而是采用 call 和 return 两个指令。</p><p>call 指令会将函数执行后的下一条指令地址存放在栈中，而 return 指令会将栈顶的指令地址给 PC 寄存器赋值。</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=YmE1OWRlZjY3OTVlOTc1MDFlMTFiY2VjZjM3NWVmYmZfTlpWWnVRbXRyS1I1WGlsVEF2N0R0ZnpaWDFDN1REOElfVG9rZW46Ym94Y25hMEtIekp1Z3d1VU9nZmRQeVN5WThjXzE2NDMzNTY2Mjk6MTY0MzM2MDIyOV9WNA" alt="img"></p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQ3ZjcxNDg5MGJiNjc5ODQwYTUxYzM5OTI5ZmFhZmRfTkdsd0s0aDdBdnBiSkNodWlKVmN1ZVpsdUdMVUlQcnhfVG9rZW46Ym94Y25uRzZTWjRNR1JrZTBsalptZmVtTUFoXzE2NDMzNTY2Mjk6MTY0MzM2MDIyOV9WNA" alt="img"></p><h2 id="3-堆和栈"><a href="#3-堆和栈" class="headerlink" title="3. 堆和栈"></a>3. 堆和栈</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行时，OS 会预先分配一段内存，用于存储数据。</p><p>对于动态的内存占用（例如 C 语言中的 malloc），会从预先分配的内存中划分出一部分，这种用户主动请求而划分的内存，称之为堆，堆的一个特点是不会自动释放，依赖用户或者垃圾收集器进行回收。</p><p>函数调用需要在内存中创建一个帧，用于存储函数的内部变量，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 test 函数前，需要将 x 先存放在内存之中，而函数执行过程中变量 a 和 b 也需要存储在帧中。在函数调用结束之后，帧的内存会被自动回收，而这块内存称之为栈。</p><p>说明：</p><ul><li>数据结构中的堆是用数组实现的二叉树，其父节点的值比所有子节点的大/小。本节讨论的堆主要针对内存而言，两者没有实质联系</li><li>在日常交流或者其他技术文章中会存在 堆栈 这个概念，而 堆栈 = 栈</li></ul><h2 id="4-一些科普"><a href="#4-一些科普" class="headerlink" title="4. 一些科普"></a>4. 一些科普</h2><ul><li>乱序执行：为了提高运行效率，CPU 不严格按照指令出现的顺序执行，例如下面的计算，d 依赖 a 的结果，必须在  a = b + c 允许之后计算，但 x 与 a、d 没有关系，x 的计算可能在 a、d 计算之前，也可能在 a、d 计算之后。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b + c</span><br><span class="line">d = a * c</span><br><span class="line">x = y * z</span><br></pre></td></tr></table></figure><ul><li>指令集架构：分为复杂指令集 CISC 和精简指令集 RISC。RISC 指令固定长度，代表是 ARM；CISC 指令不固定长度，代表是 Intel</li><li>x86 架构：狭义的 x86 架构指只支持 32 位的 Intel/AMD 的 CPU；x86_64 架构又称 x64 架构，支持 32 位和 64 位，指令集与 x86 兼容，目前绝大部分的 Intel/AMD CPU 属于这个体系；广义的 x86 架构，泛指 x86 + x64。程序员谈论的 x86 一般指广义上的，即 Intel/AMD 的 CPU。</li><li>超线程：Intel 的技术商标，更广泛的概念叫 同步多线程 Simultaneous Multithreading。不同于软件级别的多线程，超线程将一个物理 CPU 分成两个逻辑部分 ，例如在 CPU 有两份相同的寄存器，每份寄存器存储一个任务的运行环境，在一个任务无法进行时可以极快切换到另一个任务运行。我们平时看到的 8 核 16 线程即属于超线程的范畴。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></li><li><a href="https://time.geekbang.org/column/intro/100026001">极客时间：深入浅出计算机组成原理</a></li><li><a href="https://zh.wikipedia.org/wiki/X86-64">x86-64 wikipedia</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程 阮一峰</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1">程序员需要了解的计组知识(1): 二进制数</a>%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2">程序员需要了解的计组知识(2): CPU</a>%20CPU/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3">程序员需要了解的计组知识(3): 存储器</a>%20%E5%AD%98%E5%82%A8%E5%99%A8/)</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员需要了解的计组知识(1): 二进制数</title>
      <link href="/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1)%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <url>/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1)%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>计算机内部由集成电路 IC 这种电子部件构成的，IC 的一个引脚有 0V 或 5V 两个状态，这个特性决定了计算机的信息采用二进制数来处理。</p><p>计算机处理信息的最小单位是位，位的英文 bit 是 binary digit 的缩写。由于 CPU 的位数一般是 8 的倍数，将 8 位二进制数称为一个字节 byte。</p><h2 id="2-补码"><a href="#2-补码" class="headerlink" title="2. 补码"></a>2. 补码</h2><p>正整数的二进制和十进制的转换不做具体介绍，这里主要介绍整数在计算机的表示：补码。</p><p>二进制数表示负数时，一般将最高位作为符号使用。假设整数用 8 位来表示，一个直观想法是 1 的二进制为 <code>0000 0001</code>，那么 - 1 的二进制为  <code>1000 0001</code>，这种符合人脑运算的表示称为原码。</p><p>但是原码对于计算机运算存在一定问题，例如 1+ (-1) 的二进制结果为 <code>1000 0010</code>，按照原码表示为 -2，与实际运算不相符。 针对运算问题引入补码的概念，补码的思想是使用正数来表示负数。</p><p>要计算补码之前，先要介绍一下反码，正数的反码等于自身，负数的反码在其原码的基础上，符号位不变，其余各位取反，例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure><p>反码的应用是用于计算补码，正数的补码等于自身，负数的补码等于其反码 + 1，例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure><p>补码虽然直观不易理解，但逻辑十分严谨，例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + (-1) = 00000001 + 11111111 = 1 0000 0000 = 0(舍弃溢出位)</span><br></pre></td></tr></table></figure><p>x 位有符号二进制数能表示的范围为 <script type="math/tex">-2^{x}</script> 到 <script type="math/tex">2^{x} -1</script>，在日常开发中，需要注意溢出问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2147483647</span>;</span><br><span class="line">        a++;</span><br><span class="line">        System.out.println(a); <span class="comment">// -2147483648</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>计算机使用补码来表示整数</p></li><li><p>正数的原码、反码、补码都等于自身</p></li><li>负数的补码 = 其绝对值的反码 + 1</li></ul><h2 id="3-浮点数"><a href="#3-浮点数" class="headerlink" title="3. 浮点数"></a>3. 浮点数</h2><h3 id="3-1-定点数"><a href="#3-1-定点数" class="headerlink" title="3.1 定点数"></a>3.1 定点数</h3><p>日常生活中并不是所有数据都是整数，那么如何用二进制表示实数呢？</p><p>假如用 32 bit 表示实数，一个直观的想法是每 4 bit 表示 0 - 9 的数字，并且规定最右边的 2 个 0 - 9 的整数当成小数部分，例如 <code>0000 0000 0000 0000 0000 0011 0001 0100</code> 表示为 3.14，这种表示称为定点数。定点数表示实数简单易读，但是存在以下问题：</p><ul><li>浪费位数。4 bit 能够表示 0 - 15 的数字，只使用了其中 0 - 9 的部分</li><li>无法同时表示很大和小数部分很精确的数字。由于定点只有一个，小数部分越精确，整数部分的范围就小了，如果程序中的同时存在很大和小数部分很精确的数，便无法用定点数表示</li></ul><h3 id="3-2-浮点数"><a href="#3-2-浮点数" class="headerlink" title="3.2 浮点数"></a>3.2 浮点数</h3><p>针对上述定点数的问题，引入了浮点数的概念，IEEE 对浮点数定义了两个基本格式，分为单精度 32 bit 和双精度 64 bit，这里以单精度进行介绍。</p><p>单精度浮点数可以分为三部分：</p><ul><li>符号位，1 bit，1 表示正数，0 表示负数，称为 s</li><li>指数位，8 bit，称为 e。8 bit 能够表示的无符号整数范围为 0 - 255，将其中的 1 - 254 映射到 -126 -127（不包含 0），例如 -126 为区间内第 1 个整数，表示为 <code>0000 0001(1)</code>；-1 为第 126 个，表示为<code>0111 1110(126)</code></li><li>有效位，23 bit，称为 f。每一位依次表示  <script type="math/tex">2^{-1}</script>，<script type="math/tex">2^{-2}</script>、<script type="math/tex">2^{-3}</script>  … 例如 <script type="math/tex">0.5 = 2^{-1}</script>，表示为 1000……，<script type="math/tex">0.75 = 2^{-1} + 2^{-2}</script>​，表示为 11000….</li></ul><p><img src="单精度浮点数.png" alt="alt"></p><p>浮点数即可表示为</p><script type="math/tex; mode=display">(-1)^s \times (1 + f) \times 2^e</script><p>这里给出两种计算方法：</p><h5 id="计算方法1"><a href="#计算方法1" class="headerlink" title="计算方法1"></a>计算方法1</h5><p>0.5 可以表示为</p><script type="math/tex; mode=display">0.5 = (-1)^0 \times 1.0 \times 2^{-1}</script><p>即 s = 0，e = -1（需要用 126 表示），f = 0。0.5 的浮点数二进制表示即为 <code>0-01111110-0000000 00000000 00000000</code>。</p><p>1.5 可以表示为</p><script type="math/tex; mode=display">1.5 = (-1)^0 \times 1.5 \times 2^0</script><p>即 s = 0，e = 0（需要为 127 表示），f = 0.5（2 的 -1 次方，二进制表示第一位为 1，其余为 0），二进制表示为 <code>0-011111111-0000000000000000000000</code></p><p>细心的同学会发现上述公式无法表示数字 0，故 IEEE 规定当 e 和 f 的比特位都全为 0 时，表示数字 0。</p><h5 id="计算方法2"><a href="#计算方法2" class="headerlink" title="计算方法2"></a>计算方法2</h5><p>另一种对浮点数的计算方式是对于实数 x，确定指数 e 使  <script type="math/tex">2^{e} \le x < 2^{e+1}</script>，将该区间分为  <script type="math/tex">2^{23}</script> 份，f 的整数表示 x 在的小区间的位置（以 0 开始）。</p><p>对于实数 0.5，确定指数 e 为 -1，并且 0.5 位于第 0 个小区间，二进制表示为  <code>0-01111110-0000000 00000000 00000000</code>。</p><p>对于实数 1.5，确定指数 e 为 0, 将 <script type="math/tex">2^{0}</script> ~ <script type="math/tex">2^{1}</script> 分为 <script type="math/tex">2^{23}</script> 个小区间，1.5 位于第   <script type="math/tex">2^{22}</script> 个小区间，二进制表示为 <code>0-01111111-10000000000000000000000</code>。</p><h3 id="3-3-浮点数精度丢失"><a href="#3-3-浮点数精度丢失" class="headerlink" title="3.3 浮点数精度丢失"></a>3.3 浮点数精度丢失</h3><p>浮点数的精度损失主要来源两方面，一方面是实数本身无法精确表示，例如数字 1.1 ，确定指数 e 为 0，将 1 - 2 划分 $2^{23}$ 个小区间后，1.1 不在区间的两端，无法进行精确表示。</p><p>另一方面来自运算可能导致的损失，浮点数进行加法运算的规则很简单：先对齐，再计算。</p><ul><li>先将两个浮点数的指数位变成一样的，选择更大的指数位</li><li>进行加法计算</li></ul><p>例如数字 0.5，e = -1, f = 0；0.125，e = -3, f = 0，计算 0.5 + 0.125 时，首先将两个指数位统一为较大的 -1，其中 0.125 的有效数位 1.00 要右移两位，变为 0.01，两者的有效数位相加为 1.01，而指数位是 -1，这样便得到相加后的结果。</p><p>可以发现，指数位较小的数需要进行右移运算，会丢弃最右侧的有效位，32 位浮点数的有效长度为 23 位，如果两个浮点数大小差 <script type="math/tex">2^{24}</script> 倍，相加之后，结果不会变化，即所谓的大数吃小数问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a = <span class="number">20000000.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> b = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> c = a + b;</span><br><span class="line">        System.out.println(<span class="string">&quot;c is &quot;</span> + c); <span class="comment">// c is 2.0E7</span></span><br><span class="line">        <span class="keyword">float</span> d = c - a;</span><br><span class="line">        System.out.println(<span class="string">&quot;d is &quot;</span> + d); <span class="comment">// d is 0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题可以通过 <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan-Summation</a> 算法解决，此处不进行具体介绍，感兴趣的可以自行搜索。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></li><li><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示</a></li><li><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li><li><a href="https://time.geekbang.org/column/intro/100026001">极客时间：深入浅出计算机组成原理</a></li><li><a href="https://book.douban.com/subject/30333948/">码出高效: Java开发手册</a></li><li><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1">程序员需要了解的计组知识(1): 二进制数</a>%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2">程序员需要了解的计组知识(2): CPU</a>%20CPU/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3">程序员需要了解的计组知识(3): 存储器</a>%20%E5%AD%98%E5%82%A8%E5%99%A8/)</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式相关理论</title>
      <link href="/2022/01/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
      <url>/2022/01/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-CAP"><a href="#1-CAP" class="headerlink" title="1. CAP"></a>1. CAP</h2><p>CAP 是分布式系统的三个指标：</p><ul><li>Consistency：一致性</li><li>Availability：可用性</li><li>Partition Tolerance：分区容错性</li></ul><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>一致性指在更新操作完成之后，所有节点在同一时间的数据完全一致，不存在中间状态。</p><p>数据一致性可分为：</p><ul><li>强一致性：任意时刻客户端获取到的各个节点数据都是一致的</li><li>最终一致性：允许存在中间状态，但要求经过一段时间之后，数据最终是一致的</li><li>弱一致性：允许部分数据不一致</li></ul><p>注：数据库事务也有一致性的概念，这个一致性指系统从一个正确的状态到另一个正确的状态；而分布式场景中的一致性指各副本数据之间的关系。两个一致性没有任何联系。</p><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>可用性要求系统提供的服务必须一致是可用的状态，对于用户的每一个请求能在有限的时间内返回正常的结果。</p><p>其两个指标：</p><ul><li>有限时间：系统的响应时间必须是一个用户可接受的值</li><li>正常结果：无论操作成功还是失败，系统能返回一个用户能够理解的响应。例如返回一个系统内存错误 OOM 便不是一个正常结果 </li></ul><h4 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h4><p>系统在遇到网络分区故障时，仍然能够保证对外提供服务。</p><p>网络分区是系统中存在多个子网络，子网络之间通信异常，但内部通信是正常的，从而使系统被分为若干个区域。</p><h3 id="1-2-CAP-的应用"><a href="#1-2-CAP-的应用" class="headerlink" title="1.2 CAP 的应用"></a>1.2 CAP 的应用</h3><p><img src="cap.png" alt="alt"></p><p>在分布式系统中，P 是基本条件，因为分区是一种错误，它是必然会发生的，而不是一个可选项，如果不能保证 P，那么出现分区，系统便无法工作，这是无法接受的。所以，对于分布式系统，我们只能选择  C 或者 A。</p><h4 id="CP系统"><a href="#CP系统" class="headerlink" title="CP系统"></a>CP系统</h4><p>系统发生分区故障之后，客户端的任何请求都卡死或者超时，但是系统的每个节点都鞥你返回一致的数据。</p><h4 id="AP系统"><a href="#AP系统" class="headerlink" title="AP系统"></a>AP系统</h4><p> 系统发生分区故障之后，客户端能够访问系统，但是不能保证获取到的数据是最新的数据。</p><h3 id="1-3-CAP-的不足"><a href="#1-3-CAP-的不足" class="headerlink" title="1.3 CAP 的不足"></a>1.3 CAP 的不足</h3><ul><li>CAP 理论没有考虑网络延迟的问题，认为各节点的数据同步是瞬时的，与现实不符。这导致分布式大多选用 AP 方式</li><li>CAP 只是一种状态的描述，对于工程领域以及系统设计并没有帮助</li></ul><h2 id="2-BASE定理"><a href="#2-BASE定理" class="headerlink" title="2. BASE定理"></a>2. BASE定理</h2><p>由于 CAP 的种种不足，ebay 的架构师提出了 BASE 理论，是对 AP 的延伸。</p><p>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终⼀致性）三个短语的缩写，核心思想是即使无法做到强一致性，但可以采用适合的方式达到最终一致性。</p><h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>基本可用指系统出现故障之后，系统仍是可用的，但允许损失部分可用性，例如</p><ul><li>响应时间增加</li><li>服务降级：流量高峰时，屏蔽一些功能维持系统稳定</li></ul><h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>软状态允许系统中的数据存在中间状态，这些中间状态不会影响系统的可用性，即允许不同节点的数据同步存在延迟</p><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性要求数据副本在一定时间之后，能够达到一致的状态。</p><p>最终一致性可分为</p><ul><li><p>因果一致性：进程 A 更新数据后通知进程 B，进程 B 对包含该项数据的范围都是 A 更新后的值</p></li><li><p>单调读：如果之前读到新的数据，后续读取不会得到更旧的数据。单调读一致性保证强于最终一致性，弱于强一致性</p></li><li><p>单调写：系统需要保证来⾃同⼀个进程的写操作被顺序执行</p></li><li><p>读写一致性：用户获取到的自身修改是最新的，其他用户的更新可能稍后才会看到</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/30329536/">数据密集型应用系统设计</a></li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a></li><li><a href="https://www.zhihu.com/question/31346392">如何理解数据库事务中的一致性的概念?</a></li><li><a href="https://www.zhihu.com/question/54105974/answer/1643846752">CAP中的P到底是个什么意思</a></li><li><a href="https://en.wikipedia.org/wiki/Eventual_consistency">Eventual consistency</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试常见智力题</title>
      <link href="/2022/01/26/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/2022/01/26/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>现在的互联网面试中，除了技术问题以外，还会出现一些智力题考验面试者的思维和应变能力，如果没提前看过在面试时并不容易做出来。本文主要介绍面试中常出现并且具有一定难度的智力题。</p><p>注：倒水问题、用天平找重球、烧绳记录时间、脑筋急转弯等性质题目较为简单，不在本文介绍。</p><h3 id="1-赛马问题"><a href="#1-赛马问题" class="headerlink" title="1. 赛马问题"></a>1. 赛马问题</h3><p>问题：25 匹马，5 个赛道，每次只能同时有 5 匹马跑，没有计时器，最少比赛几次选出前 3 名的马？</p><p>解答：</p><ul><li>将 25 匹马分为 1-5 组，进行 5 次赛马，得到每组的排名</li><li>根据排名将马重新划分，分为 A - E组，即原先 1-5 各组排名第一的马分到 A 组，排名第二的马分到 B 组，依次类推。A 组进行一次赛马，第一名即为 25 匹马的第一名</li><li>所有马的第二名和第三名只可能在 A 组的第二、三名，B 组的第一、二名，C 组的第一名，共 5 匹马。让这 5 匹马再进行一次赛马，即可得到二三名</li></ul><p>综上，共需要 5 + 1 + 1 = 7 次赛马。</p><p>如果是选出前 5 名的马，最少需要 8 次，详细可见 <a href="https://www.iteye.com/blog/hxraid-662643">25匹马的角逐</a></p><h3 id="2-病狗问题"><a href="#2-病狗问题" class="headerlink" title="2. 病狗问题"></a>2. 病狗问题</h3><p>问题：村里住着 100 户人家，每家都养了一条狗。已知这些狗中有病狗，疾病不会传染，每家都只能通过观察别人家的狗是否有病去判断自己家的狗，一旦判断出自家的狗有病，就必须打死自己家的狗（每家只能打自己的狗）。第一天过去没有枪声，第二天过去仍然没有枪声，第三天傍晚同时响起一片枪声，病狗全都死了，问村子里有几条病狗？</p><p>解答：</p><ul><li>假如有 1 只病狗。那么它的主人观察其他狗都没有病之后，便会知道自己的狗是病狗，第一天过后会出现枪声，与题意相背</li><li>假如有 2 只病狗。第一天病狗的主人观察发现其它 49 只狗中有 1 只病狗，因为不知道确切病狗的数量，所以都认为自己的狗没病；第一天过后两个主人发现没有狗被杀，说明还存在其它病狗，那么只能是自家的狗，第二天过后应该出现枪声，与题意相背</li><li>假如有 3 只病狗。根据假设2，到了第三天，病狗的主人发现其它两方的病狗还活着，说明存在 2 只以上的病狗，那么只能是自家的狗，故出现枪声杀死所有病狗，与题意符合，故共有 3 只病狗</li></ul><p>推论：x 天出现枪声，则村里共有 x 只病狗。</p><h3 id="3-找毒药问题"><a href="#3-找毒药问题" class="headerlink" title="3. 找毒药问题"></a>3. 找毒药问题</h3><p>问题：x 瓶药，有⼀瓶有毒，用老鼠来喝药，喝到有毒的一天后死亡。⼀天内至少需要多少只老鼠才能检测到哪些有毒？</p><p>解答：</p><p>因为老鼠只有死亡和存活两种状态，设死亡 = 1, 存活 = 0，对老鼠和药进行编号后，根据药的二进制对老鼠喂药。一周后根据死亡和存活老鼠的二进制表达即可知道有毒的药水，故需要的老鼠数量为 ceil(log2(x))，ceil 表示向上取整。</p><p>例如有 8 瓶药水，编号为 0 - 7， 则一共需要 3 只老鼠，老鼠编号为 1- 3，将 4、5、6、7号药水混合到一起喂给老鼠1，将 2，3，6，7号药水混合喂给老鼠2，将1、3、5、7药水混合喂给老鼠3，观察老鼠是否中毒。假如 1 号老鼠和 3 号老鼠死亡，那么有毒的药水编号为 5 （二进制为 101）。</p><h3 id="4-找变质的药"><a href="#4-找变质的药" class="headerlink" title="4. 找变质的药"></a>4. 找变质的药</h3><p>问题：有 10 瓶药，每瓶有10粒药，其中有一瓶是变质的。好药每颗重 1 克，变质的药每颗比好药重 0.1 克。问怎样用天秤称一次找出变质的那瓶药？</p><p>解答：</p><ul><li>将 10 瓶药编号 1 - 10</li><li>每瓶药取编号数量粒药，第 1 瓶取 1 粒，第 2 瓶取 2 粒，依次类推。如果药物没有变质，那么应该为 55 克，此时多出零点几克，哪瓶药就是变质的，例如现在为 55.5 克，那么 5 号药就是变质的。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.iteye.com/blog/hxraid-662643">25匹马的角逐</a></li><li><a href="https://zhuanlan.zhihu.com/p/395132338">路人张 字节面试常考智力题</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 智力题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(4)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍行为型的设计模式，主要解决的是类或对象的之间的交互问题，常见的有 观察者模式，模板方法模式、责任链模式。</p><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>观察者模式也称 发布-订阅 模式，在 GoF 的《设计模式》中对它的定义是，在对象之间定义一个一对多的依赖，当对象状态变化时，所有依赖都会收到通知。</p><p>一般而言，被依赖的对象称为被观察者（Observable），依赖的对象叫做观察者（Observer）。</p><p>现有一个气象台的例子，用户选择订阅气象台的数据，当天气参数发生变化时，需要通知给所有用户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> pressure, <span class="keyword">double</span> humidity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据变化，通知每个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nofityObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> pressure, <span class="keyword">double</span> humidity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            <span class="comment">// 调用观察者对应的接口</span></span><br><span class="line">            o.update(temperature, pressure, humidity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者的应用非常广泛，小到代码层面的解耦，大到系统层面的解耦（例如 MQ），都有这种模式的影子。</p><h2 id="2-模板方法模式"><a href="#2-模板方法模式" class="headerlink" title="2. 模板方法模式"></a>2. 模板方法模式</h2><p>模板方法模式在一个方法中定义一个骨架，并将某些步骤推迟到子类中实现。其实现模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        method1();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板方法模式的主要作用：</p><ul><li>复用，不可变的部分交由父类实现，将可变部分交由子类实现</li><li>拓展，通过一系列 hook 方法，交由用户实现自定义拓展</li></ul><p>jdk 中大量使用了模板方法模式，例如 concurrent 的包大量类继承了 AQS，重写 tryAcquire 等方法即可实现并发工具；HashMap 留下了 afterNodeInsertion 等方法，LinkedHashMap 继承 HashMap 并重写这些方法，在保留  HashMap 的功能基础上可实现 LRU 算法。</p><h2 id="3-责任链模式"><a href="#3-责任链模式" class="headerlink" title="3. 责任链模式"></a>3. 责任链模式</h2><p>GoF 对责任链模式的定义是，将请求的发送和接收解耦，让接收对象都有机会处理这个请求，将接收对象形成一条链，并沿着链条传递请求，直到某个接收对象能够处理为止。</p><p>GoF 给出的定义中，如果某个处理器能够处理请求，将不会向下传递，日常使用也有变体，请求会被所有处理器处理一遍，不会中止。</p><p>下面是责任链模式的通常实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">implements</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> heandled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">implements</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> heandled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(IHandler handler)</span> </span>&#123;</span><br><span class="line">        handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (IHandler handler : handlers) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> handled = hander.handle();</span><br><span class="line">            <span class="comment">// 根据业务需要是否提前中止</span></span><br><span class="line">            <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>netty 中的编解码使用了责任链模式，用户可以在入和出的方法定义自己的编解码器，对数据进行加工。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在 GoF 的《设计模式》中，存在 23 种设计模式，系列文章没有全部介绍，这不代表这些模式不重要，一是由于迭代器模式等在日常开发中较少自己实现，二是作者能力有限，很多模式未能确定最好的使用场景，只能选择最常用的一些模式进行介绍。</p><p>设计模式并非银弹，遇到某个场景，不能机械把模式插入，同时也要考虑选择模式带来的代价。有人说到设计模式学习的尽头是心中无模式，但使用处处是模式，如同《神雕侠侣》中的独孤求败，重剑无锋，大巧不工，四十岁前恃之横行天下，四十岁後，不滞於物，草木竹石均可为剑，自此精修，渐进於无剑胜有剑之境。希望你也能成为程序员中的独孤求败。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://book.douban.com/subject/1052241/">设计模式</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/">小话设计模式(1)</a></p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/">小话设计模式(2)</a></p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/">小话设计模式(3)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(3)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍结构型的设计模式，结构型模式总结了类或对象组合在一起的结构，常见的有代理模式、装饰器模式、适配模式、门面模式。</p><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><p>代理模式即在不改变原始类（被代理类）的情况下，引入代理类给原始类附加功能。主要分为静态代理和动态代理。</p><h3 id="1-1-静态代理"><a href="#1-1-静态代理" class="headerlink" title="1.1 静态代理"></a>1.1 静态代理</h3><p>静态代理要求代理类和被代理类实现同样的接口，在调用相同的接口时，在代理类中进行业务增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="function">UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 业务逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">  <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">(UserController userController)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userController = userController;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">    UserVo userVo = userController.login(telephone, password);</span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">IUserController userController = <span class="keyword">new</span> UserControllerProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>上述代码在原业务逻辑中引入性能监控，UserControllerProxy 也实现了 IUserController 接口，并在 login 业务中添加了性能监控。</p><p>静态代理实现简单，但缺点是需要为每一个原始类都需要创建一个代理类，造成代码膨胀。 </p><h3 id="1-2-动态代理"><a href="#1-2-动态代理" class="headerlink" title="1.2 动态代理"></a>1.2 动态代理</h3><p>为了解决静态代理类膨胀的问题，引入了动态代理。动态代理不事先编写代理类，而是在运行时动态创建代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsCollectorProxy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MetricsCollectorProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    DynamicProxyHandler handler = <span class="keyword">new</span> DynamicProxyHandler(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">      Object result = method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">      String apiName = proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MetricsCollectorProxy proxy = <span class="keyword">new</span> MetricsCollectorProxy();</span><br><span class="line">IUserController userController = (IUserController) proxy.createProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>通过动态代理，我们就得到了一个对于所有实现  IUserController 接口都能实现监控的效果。</p><p>动态代理在 RPC、监控、鉴权以及各种框架中被广泛使用，但也存在一定的性能损耗，在日常业务开发中选择静态代理还是动态代理，需要在性能和代码膨胀中进行权衡。</p><h2 id="2-装饰器模式"><a href="#2-装饰器模式" class="headerlink" title="2. 装饰器模式"></a>2. 装饰器模式</h2><p>装饰器模式允许向一个现有对象添加新的功能，同时不改变新的结构。</p><p>Java IO 中 InputStream 是一个接口，FileInputStream 用来读取文件，BufferedInputStream 支持缓存，可以提高速度。当我们带缓存读取文件时，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">InputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br></pre></td></tr></table></figure><p>可以看到，使用时需要先创建一个 FileInputStream，再将它传给 BufferedInputStream 才能使用，为什么不直接继承实现一个带缓存的文件流 BufferedFileInputStream呢？如果 InputStream 实现类较少的话，那我们直接继承是可以接受的，但是 InputStream 存在大量实现类，如果我们想给每种实现都带缓存，那么需要对每个实现类进行继承，产生大量派生类，类继承结构变得特别复杂。</p><p>设计原则中有 ”组合优于继承“，我们可以使用组合替代继承，引入装饰器模式，下面是 Java IO 流的类似实现思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            fill(); <span class="comment">// fill是读入缓冲区的代码</span></span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.in = in; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...实现读取基本类型数据的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferedInputStream 和  DataInputStream 继承了相同的 InputStream 父类，可以对原始类嵌套多个装饰器类，当我们需要某个功能时，只需要装饰（嵌套）对应功能的实现类即可。</p><p>通过装饰器模式，我们免除了复杂的继承机制，并且可以动态添加和撤销功能。</p><h2 id="3-适配模式"><a href="#3-适配模式" class="headerlink" title="3. 适配模式"></a>3. 适配模式</h2><p>适配模式目的是将不兼容的接口转换为可兼容的接口，让原先接口不兼容的类能够组合工作。生活中常见的例子是各种 USB 转接头，让原本无法直接连接的设备能够通讯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeCToUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleConnect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端typeC的充电线</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接TypeC充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// USB转接</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">TypeCToUSB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TypeC typeC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(TypeC typeC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeC = typeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        typeC.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adapter adapter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">power</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adapter.handleConnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们便实现使用双端 typeC 设备与电脑连接充电。</p><p>适配模式并不复杂，在日常开发中使用适配模式的场景如下：</p><ul><li>封装有缺陷的接口设计，抽象出更好的接口设计</li><li>兼容老版本接口</li><li>当依赖的外部系统被替换时，通过适配模式减少代码改动</li></ul><h2 id="4-门面模式"><a href="#4-门面模式" class="headerlink" title="4. 门面模式"></a>4. 门面模式</h2><p>GoF 中对门面模式的定义是，为子系统提供一组统一的接口，定义高层的接口让子系统更易使用。</p><p>假设有系统 A，提供 a、b、c、d 四个接口，另一个系统 B 想要使用 a、b、d 接口，利用门面模式，我们提供一个包含三个接口的 x 接口，供 B 使用。</p><p>那为什么需要 x 接口呢，直接调用 a、b、d 不可以吗？</p><p>如果 A 是我们平常的后端系统， 而 B 是前端，A 与 B 之间需要通过网络通信。那么如果直接调用 3 个接口，会产生三次网络通信，而调用 x 接口，只需要一次通信，为了加快响应速度，提高用户体验，我们应该尽可能减少网络通信的次数。</p><p>接下来举一个家庭影院的例子，家中有空调、影碟机和爆米花机，我们希望有一个上层系统进行控制，开启/关闭系统后自动打开/关闭所有设备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeFacade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DVDPlayer dvdPlayer;</span><br><span class="line">    <span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line">    <span class="comment">// 省略构造函数...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.on();</span><br><span class="line">        popcorn.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">        airCondition.down();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airCondition.off();</span><br><span class="line">        popcorn.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括而言，门面模式做接口整合，解决是多接口调用带来的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://www.bilibili.com/video/BV1G4411c7N4?from=search&seid=17614039806864782413&spm_id_from=333.337.0.0">尚硅谷：设计模式</a></li><li><a href="https://www.runoob.com/design-pattern/decorator-pattern.html">装饰器模式 菜鸟教程</a></li><li><a href="https://book.douban.com/subject/1052241/">设计模式</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/">小话设计模式(1)</a></p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/">小话设计模式(2)</a></p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/">小话设计模式(4)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(2)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍常见的创建型设计模式，主要有单例、工厂和建造者模式。</p><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><p>单例模式是一个很容易理解的概念，要求一个类只能创建一个对象，并提供全局访问点，常用场景是存储配置信息或者唯一高消耗资源。</p><p>实现单例模式的主要考虑点为：</p><ul><li>构造函数外部无法访问</li><li>对象创建时线程安全</li><li>是否需要延迟加载</li></ul><p>具体实现主要有两种方式，饿汉式和懒汉式，下文将会以一个 id 生成器进行举例。</p><h3 id="1-1-饿汉式"><a href="#1-1-饿汉式" class="headerlink" title="1.1 饿汉式"></a>1.1 饿汉式</h3><p>饿汉式实现即在类加载之后，该实例就已经创建完成，该实例创建的时候是线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式的优点是实现非常简单，有人认为这种方式提前初始化会提前创建对象却不使用，导致资源浪费，个人不认同这种观点，在系统启动后去执行耗时的操作，可能会影响系统的性能，不如将这耗时的操作提前到系统初始化之时。</p><h3 id="1-2-懒汉式"><a href="#1-2-懒汉式" class="headerlink" title="1.2 懒汉式"></a>1.2 懒汉式</h3><p>与饿汉式对应的是懒汉式，将对象的初始化延迟。在 java 中有多种方式可以实现懒汉式，这里主要推荐静态内部类和枚举的方式。</p><ul><li>静态内部类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式依赖类加载机制，当调用 getInstance() 方法时，内部类才会进行加载，instance 才会被创建，其唯一性和线程安全性由 JVM 进行保证。</p><ul><li>枚举：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式依赖 java 枚举为单例的性质，实现最为简单，推荐使用。</p><p>说明：懒汉式中还有一种双重检测的实现方式，但这种方式实现复杂，注意点多，甚至在低版本 jdk 下都无法保证正确实现单例模式。个人不推荐使用这种方式，但在此还是提供实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> IdGenerator instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (IdGenerator.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><p>工厂模式主要用于创建对象，可分为简单工厂、工厂方法和抽象工厂。其中抽象工厂较为复杂，在日常开发中较少使用，下文以一个车辆工厂举例介绍简单工厂和工厂方法。</p><h3 id="2-1-简单工厂"><a href="#2-1-简单工厂" class="headerlink" title="2.1 简单工厂"></a>2.1 简单工厂</h3><p>简单工厂将创建对象的逻辑汇集到一个工厂类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;五菱&quot;</span>.equals(car)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;特斯拉&quot;</span>.equals(car)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getWuling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getTesla</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建车辆的代码被汇集到 CarFactory 中，并且提供按品牌创建车辆对象的方法。简单工厂并不是一个设计模式，它没有用到面向对象的任何特性，它更像是一种编程习惯，将类似功能的代码整合，并没有提升代码的拓展性。</p><h3 id="2-2-工厂方法"><a href="#2-2-工厂方法" class="headerlink" title="2.2 工厂方法"></a>2.2 工厂方法</h3><p>当需要拓展新类型时，简单工厂仍需要在一堆 if-else 中进行改动，要避免这种情况，需要利用多态的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;特斯拉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wuling</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;五菱宏光&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WulingFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeslaFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了一个工厂接口，并且实现了五菱和特斯拉的工厂类。当我们需要创建对象时，先创建对应的工厂，再调用 create 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ICarFactory teslaFactory = <span class="keyword">new</span> TeslaFactory();</span><br><span class="line">Car tesla = teslaFactory.create();</span><br><span class="line">ICarFactory wulingFactory = <span class="keyword">new</span> WulingFactory();</span><br><span class="line">Car wuling = wulingFactory.create();</span><br></pre></td></tr></table></figure><p>工厂方法即提供创建对象的统一接口，并将创建对象的具体实现交由子类实现。</p><h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3 应用场景"></a>2.3 应用场景</h3><p>那什么时候选择简单工厂，什么时候选择工厂方法呢？</p><ul><li>如果创建对象的代码块比较简单，只有两三种类型，推荐不进行拆分</li><li>当创建对象的类型较多，并且各个对象的创建逻辑较为简单时，例如只需要简单的 new 操作，选择简单工厂模式</li><li>当各个对象的创建逻辑较为复杂，需要复杂的初始化时，选择工厂方法模式，将复杂的逻辑分散到各个工厂子类中</li></ul><h2 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h2><h3 id="3-1-头疼的初始化"><a href="#3-1-头疼的初始化" class="headerlink" title="3.1 头疼的初始化"></a>3.1 头疼的初始化</h3><p>在日常开发中，创建一个对象的常用方式是直接调用该类的构造函数。但是当成员属性较多，并且有部分属性初始化是可选的时，我们需要重载大量的构造函数，代码的可读性和易用性都降低了。</p><p>有一种解决方案是提供一个简单的构造函数和 setter 方法，在创建一个对象之后，调用 setter 给需要的属性赋值。这种方案能够解决一定问题，但仍存在缺陷：</p><ul><li>必须初始化的属性依赖程序员而不是编译器确认，如果使用者忘记初始化，会影响后续的业务逻辑</li><li>建造过程中可能处于不一致的状态，没法通过检查构造参数实现一致性</li><li>该类要求是不可变对象，不应该提供 setter</li></ul><h3 id="3-2-建造者模式"><a href="#3-2-建造者模式" class="headerlink" title="3.2 建造者模式"></a>3.2 建造者模式</h3><p>为了解决这些问题，建造者模式由此产生。建造者模式在类中内置一个建造者 Builder 类，并且区分必选项和可选项，摆脱陷入大量重载构造函数的泥泽之中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化必选项</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">        <span class="comment">// 初始化可选项，提供默认值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在对建造者模式都有很好的支持，lombok 插件只需要一个 @Builder 注解即可为该类低入侵式实现建造者模式，</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://www.bilibili.com/video/BV1G4411c7N4?from=search&seid=17614039806864782413&spm_id_from=333.337.0.0">尚硅谷：设计模式</a></li><li><a href="https://book.douban.com/subject/30412517/">effective java</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/">小话设计模式(1)</a></p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/">小话设计模式(3)</a></p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/">小话设计模式(4)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(1)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/</url>
      
        <content type="html"><![CDATA[<p>设计模式首次在 GoF 的《设计模式》书中提出，其副标题是可复用面向对象软件的基础，旨在实现可拓展、可维护的高质量代码。</p><p>学习设计模式往往有以下目的：</p><ul><li>面对面试中的设计模式相关问题</li><li>改善自己的代码质量</li><li>阅读源码、框架的基础</li></ul><p>在使用模式之前，我们需要先了解各种模式以及他们适用的场景，设计模式按类型可以分为：</p><ul><li>建造型</li><li>结构型</li><li>行为型</li></ul><p>在后续文章中会按类型对常用的设计模式进行介绍。</p><p>正如计算机领域的一句名言而言，“计算机领域的问题可以靠加一层抽象来解决”，良好的抽象会极大提升了代码的质量。但很多人也忽视了下一句，“而这往往会带来其他问题”，设计模式是面向对象大树上生长出的硕果，如果使用者还未踏入面向对象的殿堂，盲目使用设计模式往往会带来相反的效果。笔者刚学习设计模式之初，曾想方设法进行应用，大肆设计，后经时间验证，过度的设计不会带来任何优势，反而却增加了代码的复杂度，代码阅读者如果不了解该模式便会不知所云。引入设计模式的目的是为了让代码变得更容易理解和维护。</p><p>自然地使用设计模式，而不是被它们套上枷锁。软件设计的能力并不是一朝一夕就能培养出来的，不要妄图通过阅读一本《设计模式》抓到面向对象设计的精髓。设计模式如同张无忌学剑一般，忘记了，也便学会了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://book.douban.com/subject/1052241/">GoF 设计模式</a></p></li><li><p><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></p></li><li><p><a href="https://draveness.me/holy-grail-design-pattern/">圣杯与银弹 没用的设计模式</a></p></li><li><p><a href="https://www.zhihu.com/question/23757237">知乎：设计模式有何不妥，所谓的荼毒体现在哪</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/19835717">为什么我们需要学习（设计）模式</a></p></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/">小话设计模式(2)</a></p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/">小话设计模式(3)</a></p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/">小话设计模式(4)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈面向对象编程</title>
      <link href="/2022/01/24/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/24/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>面向过程是一种编程范式，以过程（函数）作为单元组织代码，数据与过程相分离，主要是对过程进行抽象，将其组合为函数，代表语言 C 语言。</p><p>而面向对象也是一种编程范式，以对象（类）作为组织代码的单元，主要是对数据进行抽象，将其组合为类，具有封装、继承、多态三个特性，代表语言有 C++、Java、C#。</p><p>面向对象相比于面向过程有以下优势：</p><ul><li>更适合于复杂大规模程序开发</li><li>OOP 风格的代码更容易复用、拓展和维护</li></ul><p>说明：面向过程也并一无是处，没有纯粹的 OOP，面向对象的编程语言在宏观上是面向对象，但在微观上仍是面向过程的。 面向过程的 C 语言也可以实现不完全的面向对象特性：</p><ul><li>封装：使用 static 关键字</li><li>继承：用组合代替</li><li>多态：利用函数指针实现，redis 和 linux 内核中的 VFS 就是使用这种方法实现多态</li></ul><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h2><h3 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h3><p>封装是将相关的数据和操作汇集到类模块，并暴露有限的接口供外部访问内部数据，用户不需要也无权访问其底层实现。</p><p>意义：</p><ul><li>降低修改的灵活性，提高代码的可控性</li><li>降低使用负担，使用者只需关注暴露的接口即可</li></ul><p>原则：</p><ul><li>当不确定内部属性的访问权限时，优先考虑最低的访问权限。当将一个属性的访问权限从 public 改为 private 可能导致大量的代码改动，反之只要小量或者没有代码改动。</li><li>有必要时才提供 setter 方法</li><li>当获取或者设置类的可变属性时，考虑采用防御性复制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(person.toString());</span><br><span class="line"><span class="comment">// Person&#123;birthday=Mon Jan 24 09:21:38 CST 2022&#125;</span></span><br><span class="line">Date birthday = person.getBirthday();</span><br><span class="line">birthday.setYear(<span class="number">98</span>);</span><br><span class="line">System.out.println(person.toString());</span><br><span class="line"><span class="comment">// Person&#123;birthday=Sat Jan 24 09:21:38 CST 1998&#125;</span></span><br></pre></td></tr></table></figure><p>上述测试代码中 <code>getBirthday</code> 方法返回的是可变的 <code>Date</code> 对象，在外部对该 <code>Date</code> 对象进行修改会导致 <code>Person</code> 业务逻辑错误。问题根源是 birthday 虽然是引用类型，但语意上应该是值类型，我们关心的是它的值，不希望不同引用对其进行同步修改。</p><p>修改方式是采用防御性复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> birthday == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Date(birthday.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>Date</code> 可变是一种设计错误，其一系列 getter/setter 已被弃用</li><li>是否采用防御性复制，需要根据其语意和实际类型是否统一判断</li></ul><h3 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h3><p>此处讨论的继承为广义的继承，不局限于继承具体类。</p><p>从可继承数量上分为：</p><ul><li>单继承：一个类只能继承一个父类，代表语言 Java、C#</li><li>多继承：一个类能继承多个父类，代表语言 C++。多继承会存在菱形问题，类 B 和 C 继承 A，都重写了某一个方法，现有类 D 继承 B 和 C，该方法继承 B 还是 C 会存在歧义 </li></ul><p>根据继承类型分为：</p><ul><li>接口继承：实现某一个接口，<strong>生成可复用的代码</strong>，Java 中采用 implements 关键字</li><li>实现继承：继承某个类，<strong>复用已有的代码</strong>，Java 中采用 extends 关键字</li></ul><p>原则：</p><ul><li>提倡接口继承，慎用实现继承</li><li>优先考虑组合而不是继承。一方面继承带来了更大的耦合，父类改动时需要谨慎考虑对子类的影响，降低了拓展性；另一方面子类可以通过重写破坏父类精心设计的封装</li><li><p>考虑使用继承的情况：1. 继承层次浅，继承关系不复杂；2.模板方法设计模式；</p><p>3.无法改变一个方法的参数类型，并且该参数不是接口，考虑使用继承进行拓展</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    client.encode(url);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedClient</span> <span class="keyword">extends</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写该方法实现自己的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">Client client = <span class="keyword">new</span> CustomizedClient();</span><br><span class="line">f(client);</span><br></pre></td></tr></table></figure><ul><li>继承应遵守里氏替换原则，能够向上转型，常规逻辑的 is-a 关系不是使用继承的充分条件，需要<strong>考虑父类/接口的契约，子类需要履行所有契约</strong>。一个直观的测试方法：子类能够通过父类的所有的单元测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List接口，供举例说明，与java.util.List定义不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个元素到列表的末尾</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体实现...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中 <code>SortedList</code> 实现了 <code>List</code> 接口，但 <code>SortedList</code> 在插入元素应该将其存放在合适的位置，并不一定是末尾，并不遵守 <code>List</code> 的契约。直觉上 <code>SortedList</code> 是<code>List</code>，但从设计角度不应该实现 <code>List</code> 接口，考虑使用更上级的 <code>Collection</code> 接口。</p><p>jdk 中的设计错误：</p><p>1.<code>Stack</code> 继承了 <code>Vector</code>，栈从定义上并不具备 <code>Vector</code> 中随机访问和删除等功能，不应该使用继承。正确方式是使用组合，在内部维护一个 <code>Vector</code>，对外提供入栈、出栈等方法。</p><p>2.<code>Properties</code> 继承了 <code>HashTable&lt;Object, Object&gt;</code>，<code>Properties</code> 相比 <code>HashTable</code> 而言多了 IO 读取和持久化等功能。但是其 key 和 value 都应该是 <code>String</code> 类型，如果 <code>Properties</code> 调用继承<code>HashTable</code> 的 <code>put</code> 方法插入非 <code>String</code> 类型的 k/v 时，在持久化时会导致强制转型失败。正确方式是继承 <code>HashTable&lt;String, String&gt;</code> 或者使用组合。</p><h3 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h3><p>广义的多态可分为：</p><ul><li>静态多态：也称参数多态，在编译期确定类型，让相同的代码应用在不同类型。例如 C++ 中的 template（采用异构翻译，即为每一个类型创建一份代码），Java 中的泛型（采用同构翻译，即类型擦除，所有类型都会被转为 Object）</li><li>动态多态：也称子类型多态，在运行期确定，让不同的实现代码应用在相同的场合。OOP 中讨论的多态通常指动态多态</li></ul><p>多态可以提高代码的拓展性和复用性，也是很多设计模式的继承。在 OOP 中多态依赖继承实现，继承是多态的基础，多态是继承的目的。</p><p>设计原则：</p><ul><li>设计接口和父类时，需要谨慎设计契约</li></ul><p>这里举一个常见的鸟类案例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;ostrich can&#x27;t fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了父类鸟类，并定义 <code>fly</code> 方法，子类鸵鸟继承了该类，但由于鸵鸟无法飞，<code>fly</code> 方法中抛出异常。一方面是上文所言鸵鸟无法实现父类的契约，不应该继承该类；另一方面，抽象出鸟类时应该考虑到不是所有鸟都会飞，不应该提供 <code>fly</code> 方法。更好的方式是将 <code>fly</code> 放到 <code>Flyable</code>接口中，而鸵鸟类不实现该接口。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="type">Flyable</span> &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AbstractBird</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eagle</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> <span class="title">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    void fly() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3.结语"></a>3.结语</h2><p>设计再良好的系统，在烂代码的侵蚀下最终会变得不可控。在考虑总体架构设计之后，也别忽略对模块、类、方法的设计，勿在浮沙筑高楼，好的架构师首先得是一个好的程序员。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/4031906/">冒号课堂 编程范式和OOP思想</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://book.douban.com/subject/2334288/">大话设计模式</a></li><li><a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">Google Tech Talk: How to design a good API</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 编程思维 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
