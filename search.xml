<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Reactor模式</title>
      <link href="/2022/03/08/Reactor%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/03/08/Reactor%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>在 <a href="https://blog.strokebun.top/2022/02/15/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">IO多路复用</a> 文章中提到，引入了 IO 多路复用解决了 C10K 问题，但直接基于 select/poll/epoll 编写服务端程序还是比较复杂的，于是对此做了一层封装，称为 Reactor 模式。</p><p>Reactor 模式也称为 Dispatcher 模式，使用 IO 多路复用监听事件，收到事件后，根据事件类型分配给某个线程。</p><p>下文将介绍常见 Reactor 模型的实现方案。</p><h2 id="2-单Reactor单线程"><a href="#2-单Reactor单线程" class="headerlink" title="2. 单Reactor单线程"></a>2. 单Reactor单线程</h2><p>单 Reactor 单线程是最简单的实现方案，示意图如下：</p><p><img src="单reactor单线程.png" alt="单Reactor单线程"></p><p>这里主要有三个对象 Reactor、Acceptor 和 Handler：</p><ul><li>Reactor 对象通过 IO 多路复用监听事件，如果是连接事件则分发给 Acceptor 对象，非连接事件则分发给 Handler 对象；</li><li>Acceptor 对象会获取连接，并为此连接创建一个 Handler 对象处理后续的业务；</li><li>Handler 对象进行 读数据 -&gt; 处理业务 -&gt; 发送数据 的流程。</li></ul><p>上面的三个对象都在同一个线程中，实现简单，不过也存在两个缺点：</p><ul><li>无法利用多核 CPU 的性能优势；</li><li>Handler 处理业务时， 无法处理其他事件，如果业务耗时较长或者阻塞，将会增加响应延迟。</li></ul><p>单 Reactor 单线程的实现方案适用在计算密集、业务处理时间短的场景，例如 Redis。</p><blockquote><p>早期版本的 Redis 使用了单 Reactor 单线程的方案，但由于单 Reactor 在处理大量网络 IO 上的不足，在 6.0 版本后改为了 多 Reactor 单线程的方案。 </p></blockquote><h2 id="3-单Reactor多线程"><a href="#3-单Reactor多线程" class="headerlink" title="3. 单Reactor多线程"></a>3. 单Reactor多线程</h2><p>要解决 单 Reactor 单线程 方案的缺点，一个直观的想法是引入多线程，单 Reactor 多线程的实现方案如下所示：</p><p><img src="单reactor多线程.png" alt="单Reactor多线程"></p><p>这个方案的 Reactor 对象和 Acceptor 对象与 单 Reactor 单线程 方案是一样的，不同的是：</p><ul><li>Handler 不再处理业务，而是负责数据的接收和发送，业务处理交由线程池中的 worker 线程实现；</li><li>worker 线程处理完业务后，将结果发送给主线程的 Handler 对象，由 Handler 将结果发送给客户端。</li></ul><p>引入多线程，充分利用了 CPU 多核处理的性能资源，但 worker 线程完成业务处理之后，需要将结果传递过主线程，这里需要考虑线程同步。</p><p>另一方面，只有一个 Reactor 对象承担所有事件的监听和响应，正在高并发场景中容易成为性能瓶颈。</p><h2 id="4-多Reactor多线程"><a href="#4-多Reactor多线程" class="headerlink" title="4. 多Reactor多线程"></a>4. 多Reactor多线程</h2><p>为了解决单 Reactor 在高并发连接的性能瓶颈，需要改为多 Reactor，方案示意图如下：</p><p><img src="多reactor多线程.png" alt="多Reactor多线程"></p><p>这个方案中，会包含一个主 Reactor、多个子 Reactor 线程和 worker 线程池：</p><ul><li>主 Reactor：负责监听客户端连接事件，并在同一个线程中让 Acceptor 处理连接事件，连接建立后，分发给子 Reactor 线程；</li><li>子 Reactor：监听客户端连接的后续事件，当发生读写事件时，让同一个线程中的 Handler 读取和发送数据，具体业务处理交由 worker 线程实现。</li><li>worker 线程池：实现业务处理。</li></ul><p><img src="多reactor多线程示意.png" alt="多Reactor多线程示意"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p><img src="Reactor模式总结.png" alt="Reactor模式总结"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Scalable IO in Java</a></li><li><a href="https://www.cnblogs.com/xiaolincoding/p/14706824.html">图解高性能网络架构：Reactor和Proacor</a></li><li><a href="http://yuanjava.cn/archives/-zhong-bang-tui-jian--yi-wen-pou-xi-reactormo-xing">带你深入理解Reactor模型</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP报文</title>
      <link href="/2022/03/03/HTTP%E6%8A%A5%E6%96%87/"/>
      <url>/2022/03/03/HTTP%E6%8A%A5%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>超文本传输协议 HyperText Transfer Protocol，HTTP 是 WEB 世界中最常用的协议，基于 TCP 协议，默认端口是 80。</p><p>HTTP 是无状态的协议，但使用 Cookie 和 Session 实现保持状态的功能。</p><p>本文主要介绍 HTTP 报文。</p><h2 id="2-HTTP报文"><a href="#2-HTTP报文" class="headerlink" title="2. HTTP报文"></a>2. HTTP报文</h2><p>用于 HTTP 协议交互的信息被称为 HTTP 报文，大致可分为报文首部 header 和报文主体 body 两部分，并由空行（CRLF）划分，HTTP 报文并不一定包含主体。</p><p><img src="http报文结构.png" alt="HTTP报文结构"></p><p>客户端的 HTTP 报文称为请求报文，请求报文的首部包括请求行和各种首部字段。服务端的称为响应报文，响应报文的首部包括状态行和各种首部字段。</p><p><img src="请求报文和响应报文.png" alt="请求报文和响应报文"></p><h2 id="3-常见状态码"><a href="#3-常见状态码" class="headerlink" title="3. 常见状态码"></a>3. 常见状态码</h2><p><img src="http状态码.png" alt="HTTP状态码"></p><h4 id="1xx"><a href="#1xx" class="headerlink" title="1xx"></a>1xx</h4><p>1xx 类状态码是一种中间状态，较少使用，一种使用方式是 <a href="https://blog.strokebun.top/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/">HTTP GET和POST的区别</a> 中提到的，上传文件时先传文件信息，服务端返回 100 再继续传输文件内容。</p><h4 id="2xx"><a href="#2xx" class="headerlink" title="2xx"></a>2xx</h4><p>2xx 类状态码表示服务器成功处理了客户端的请求。</p><p>200 OK 是常见的状态码，表示一切正常。</p><p>204 No Content 与 200 基本相同，但响应中没有 body 数据。</p><h4 id="3xx"><a href="#3xx" class="headerlink" title="3xx"></a>3xx</h4><p>3xx 类状态码代表资源发生了变动，客户端需要进行重定向。</p><p>301 Moved Permanently 表示永久重定向，需要使用新的 URL 访问。</p><p>302 Found 表示临时重定向，资源还在，但暂时需要用另一个 URL 访问。</p><blockquote><p>301 和 302 会在响应头中使用 <code>Location</code> 字段指明后续要跳转的 URL，浏览器自动跳转。</p></blockquote><p>304 Not Modified 表示资源未修改，重定向到已经存在的缓存。</p><h4 id="4xx"><a href="#4xx" class="headerlink" title="4xx"></a>4xx</h4><p>4xx 类状态码表示客户端发送的报文错误，服务端无法处理，属于客户端异常。</p><p>400 Bad Request 表示客户端发送的报文不符合服务端的格式要求。</p><p>401 Unauthorized 表示需要进行权限验证。</p><p>403 Forbidden 表示客户端的请求正确，但服务器禁止客户端访问该资源。</p><p>404 Not Found 表示请求的资源不存在。</p><h4 id="5xx"><a href="#5xx" class="headerlink" title="5xx"></a>5xx</h4><p>5xx 表示客户端的请求报文正确，但是服务器处理时发生错误，属于服务端异常。</p><p>500 Internal Server Eroor，表示服务器内部错误，是个笼统通用的错误码。</p><p>501 Not Implemented 表示客户端请求的功能目前还不支持，通常是因为客户端使用了 HTTP 的拓展特性。</p><p>502 Bag Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，但访问后端服务器发生了错误。</p><p>503 Service Unavailable 表示服务器当前很忙，暂时无法响应。</p><h2 id="4-常见首部字段"><a href="#4-常见首部字段" class="headerlink" title="4. 常见首部字段"></a>4. 常见首部字段</h2><h3 id="4-1-通用首部字段"><a href="#4-1-通用首部字段" class="headerlink" title="4.1 通用首部字段"></a>4.1 通用首部字段</h3><h4 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h4><p>该字段常用于客户端要求使用长连接，在 HTTP/1.1 后默认使用长连接，主要是为了兼容老版本，具体可见 <a href="https://blog.strokebun.top/2022/02/17/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/">HTTP发展史</a>。</p><h3 id="4-2-请求报文首部字段"><a href="#4-2-请求报文首部字段" class="headerlink" title="4.2 请求报文首部字段"></a>4.2 请求报文首部字段</h3><h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>该字段用来指定服务器的域名，可以查找同一台服务器上的不同网站。</p><h4 id="Accept"><a href="#Accept" class="headerlink" title="Accept"></a>Accept</h4><p>指明客户端能够处理的类型以及优先级。</p><h4 id="Accept-Encoding"><a href="#Accept-Encoding" class="headerlink" title="Accept-Encoding"></a>Accept-Encoding</h4><p>指明客户端能够使用的压缩算法。</p><h4 id="Authorization"><a href="#Authorization" class="headerlink" title="Authorization"></a>Authorization</h4><p>客户端携带的认证信息，通常在收到 401 状态码响应后设置该字段。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>客户端携带的 cookie。</p><h3 id="4-3-响应报文首部字段"><a href="#4-3-响应报文首部字段" class="headerlink" title="4.3 响应报文首部字段"></a>4.3 响应报文首部字段</h3><h4 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h4><p>服务器回应本次数据的格式，通常是 Accept 字段中的一种。</p><h4 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h4><p>表明服务器本次回应的数据长度。</p><h4 id="Content-Encoding"><a href="#Content-Encoding" class="headerlink" title="Content-Encoding"></a>Content-Encoding</h4><p>表明数据采用的压缩方法，通过是 Accept-Encoding 字段中的一种。</p><h4 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h4><p>将响应接收方引导至某个与请求 URL 位置不同的资源，通常与 301、302 状态码配合使用。</p><h4 id="Set-Cookie"><a href="#Set-Cookie" class="headerlink" title="Set-Cookie"></a>Set-Cookie</h4><p>服务器给客户端设置的 cookie。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.runoob.com/http/http-status-codes.html">HTTP状态码 菜鸟教程</a></li><li><a href="https://www.cnblogs.com/xiaolincoding/p/12442435.html">30张图解HTTP常见的面试题</a></li><li><a href="https://book.douban.com/subject/25863515/">图解HTTP</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(7): 解读ConcurrentHashMap</title>
      <link href="/2022/02/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(7)%20%E8%A7%A3%E8%AF%BBConcurrentHashMap/"/>
      <url>/2022/02/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(7)%20%E8%A7%A3%E8%AF%BBConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p><code>java.util.concurrent</code> 中包含大量线程安全的集合，一一介绍是不太现实的，而<code>ConcurrentHashMap</code> 在面试中最常考察，本文将对它进行介绍。</p><p><code>HashMap</code> 不是线程安全的，想要得到一个线程安全的 <code>Map</code> 集合，一个直观的想法是对每个方法使用 <code>synchronized</code> 加锁，实现最为简单，但是这种方式锁粒度过大，同一时间只有一个线程能够访问。</p><blockquote><p><code>HashTable</code> 就是这样的实现方式，一般不推荐使用。</p></blockquote><p><img src="hashtable.png" alt="HashTable"></p><p>改进方法是降低加锁的粒度，对 <code>Map</code> 中部分元素进行加锁，达到多线程访问的效果。</p><p><code>ConcurrentHashMap</code> 在 jdk 1.7 和 1.8 版本的实现方式是不同的，本文主要介绍 1.8 版本的实现。</p><blockquote><p>jdk 1.7 中的 <code>ConcurrentHashMap</code> 的实现思路是使用分段锁，这个思路在其他语言的线程安全集合中大量应用，推荐掌握。</p></blockquote><h2 id="2-设计思路"><a href="#2-设计思路" class="headerlink" title="2. 设计思路"></a>2. 设计思路</h2><p><code>ConcurrentHashMap</code> 的数据存储与获取与 <code>HashMap</code> 高度相似：</p><ul><li>使用 <code>Node</code> 数组存储元素，数组长度为 2 的幂，求余采用位运算实现；</li><li>采用拉链法解决哈希冲突，当链表长度达到 8 将转为红黑树；</li><li>元素个数达到负载因子 * 数组长度 时，将触发扩容，扩容时将原来的链表拆分为高位链表和低位链表。扩容后红黑树可能会退化为链表；</li><li>由于 <code>Node</code> 会对 key 的 hash 进行缓存，存放的 key 对象需要为不变的，否则有<code>ConcurrentHashMap</code> 中可能存在相同的 key 对象，或者使用 <code>get</code> 方法但取不到对应的 value 值。</li></ul><blockquote><p>key 对象应该不可变是一个小坑点，但很少博客提及这个问题。</p></blockquote><p><code>ConcurrentHashMap</code> 采用 <code>synchronized</code> + CAS 的方式保证线程安全。插入时需要获得 key 对应 <code>Node</code> 数组槽（也就是链表头节点或者红黑树根节点）的锁，对于同一个槽，同一时刻只能有一个线程进行插入，如果插入时正在发生扩容，则插入线程会帮助进行迁移元素。获取元素的操作则使用 CAS，实现无锁并发读取。</p><p>其中 <code>sizeCtl</code> 属性标记了不同的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br></pre></td></tr></table></figure><ul><li><code>sizeCtl &gt; 0</code>，进行扩容的阈值，等于 负载因子 * 数组长度；</li><li><code>sizeCtl = 0</code>，还未初始化；</li><li><code>sizeCtl = -1</code>，正在进行初始化；</li><li><code>sizeCtl = -(1+n)</code>，有 n 个线程正在协助扩容。 </li></ul><p>下面将从源码的角度介绍几个主要操作。</p><h2 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.  初始化"></a>3.  初始化</h2><p>类似 <code>HashMap</code>，<code>ConcurrentHashMap</code> 也是懒初始化的，会在插入第一个 k-v 时分配空间（可见下文的 <code>putVal</code> 方法），调用的方法是 <code>initTable()</code>。</p><p>在进行初始化时可能存在多线程竞争，而抢到初始化资格的标志就是能否成功用 CAS 将 <code>sizeCtl</code> 置为 -1，其他未成功的线程将进行自旋。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">    <span class="comment">// 使用自旋CAS进行初始化</span></span><br><span class="line">    <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// sizeCtl &lt; 0，则有其他线程进行初始化，让出CPU自旋</span></span><br><span class="line">        <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">            Thread.yield(); </span><br><span class="line">        <span class="comment">// 还未进行初始化，使用CAS竞争初始化的权力</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 进行初始化</span></span><br><span class="line">                <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                    table = tab = nt;</span><br><span class="line">                    <span class="comment">// sc = n - 0.25n = 0.75n</span></span><br><span class="line">                    sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// sizeCtl = 0.75 * 数组长度，为扩容阈值</span></span><br><span class="line">                sizeCtl = sc;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-put"><a href="#4-put" class="headerlink" title="4. put"></a>4. put</h2><h3 id="4-1-主流程"><a href="#4-1-主流程" class="headerlink" title="4.1 主流程"></a>4.1 主流程</h3><p><code>put</code> 方法是 <code>ConcurrentHashMap</code> 中最为复杂的部分，涉及初始化、树化、扩容、帮助迁移等。主要流程为：</p><ul><li>如果 <code>Node</code> 数组未初始化，则进行初始化</li><li>根据 key 的 hash 值定位某个槽后，分为以下情况：<ul><li>为空，则使用 CAS 将 k-v 对放入槽；</li><li>正在扩容，则帮忙转移节点；</li><li>该槽位不为空则未进行扩容，获取槽的锁，判断节点是链表节点还是红黑树节点，选择对应的插入/替换手段。插入后视情况进行树化。</li></ul></li><li>增加元素个数，并视情况进行扩容。</li></ul><p><img src="put流程.png" alt="put流程"></p><blockquote><p>上面的流程图并未完全遵循规范，主要是为了方便绘制和理解。</p></blockquote><p>源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">        <span class="comment">// 还未初始化则进行初始化</span></span><br><span class="line">        <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            tab = initTable();</span><br><span class="line">        <span class="comment">// 当前key对应的槽为null，则使用CAS进行设置</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                         <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                <span class="keyword">break</span>;                  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前正在扩容，则帮助扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            tab = helpTransfer(tab, f);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            V oldVal = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 锁定槽，即链表头节点或红黑树根节点</span></span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        binCount = <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 查找对应的key</span></span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                            K ek;</span><br><span class="line">                            <span class="comment">/**</span></span><br><span class="line"><span class="comment">                            * 如果key已存在，则更新值</span></span><br><span class="line"><span class="comment">                            * Node对hash进行了缓存，如果key对象改变，这里e.hash == hash结果将为false</span></span><br><span class="line"><span class="comment">                            */</span></span><br><span class="line">                            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                ((ek = e.key) == key ||</span><br><span class="line">                                 (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                oldVal = e.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    e.val = value;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">// key不存在，则插入链表尾部</span></span><br><span class="line">                            Node&lt;K,V&gt; pred = e;</span><br><span class="line">                            <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                          value, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 如果是红黑树，则执行红黑树的插入，较为复杂，不详细介绍</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; p;</span><br><span class="line">                        binCount = <span class="number">2</span>;</span><br><span class="line">                        <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                       value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            oldVal = p.val;</span><br><span class="line">                            <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                p.val = value;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 链表长度达到8，则进行树化</span></span><br><span class="line">                <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                    treeifyBin(tab, i);</span><br><span class="line">                <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> oldVal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过CAS增加Node个数，达到sizeCtl则进行扩容</span></span><br><span class="line">    addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-扩容-todo…"><a href="#4-2-扩容-todo…" class="headerlink" title="4.2 扩容(todo…)"></a>4.2 扩容(todo…)</h3><p><code>addCount</code> 方法增加元素个数，并判断是否进行扩容，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">    CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">    <span class="comment">// 分段计算元素个数，不用深入了解</span></span><br><span class="line">    <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">        !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        s = sumCount();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="comment">// 元素个数到达sizeCtl，则需要进行扩容 </span></span><br><span class="line">        <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">            <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 已经在扩容</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                    transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                    transfer(tab, nt);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前线程是第一个进行扩容的</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容的逻辑在 <code>transfer()</code> 方法中，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">    <span class="comment">// 计算一次迁移的步长，不用深究</span></span><br><span class="line">    <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">        stride = MIN_TRANSFER_STRIDE;</span><br><span class="line">    <span class="comment">// 还未分配新数组</span></span><br><span class="line">    <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 两倍扩容</span></span><br><span class="line">            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">            nextTab = nt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nextTable = nextTab;</span><br><span class="line">        transferIndex = n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">    ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">    <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">        Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line">        <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">            <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">            <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                     (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                      nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                   nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                bound = nextBound;</span><br><span class="line">                i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                advance = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">            <span class="keyword">int</span> sc;</span><br><span class="line">            <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                nextTable = <span class="keyword">null</span>;</span><br><span class="line">                table = nextTab;</span><br><span class="line">                sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">            advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">            advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                    Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                    <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">int</span> runBit = fh &amp; n;</span><br><span class="line">                        Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                            <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                runBit = b;</span><br><span class="line">                                lastRun = p;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                            ln = lastRun;</span><br><span class="line">                            hn = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            hn = lastRun;</span><br><span class="line">                            ln = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                        &#125;</span><br><span class="line">                        setTabAt(nextTab, i, ln);</span><br><span class="line">                        setTabAt(nextTab, i + n, hn);</span><br><span class="line">                        setTabAt(tab, i, fwd);</span><br><span class="line">                        advance = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 红黑树节点</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                        <span class="comment">// 红黑树与链表的迁移类似，这边省略</span></span><br><span class="line">                        ... </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-get"><a href="#5-get" class="headerlink" title="5. get"></a>5. get</h2><p><code>get</code> 方法逻辑比较简单，主要是判断当前是否在进行扩容，到相应的数组中查找元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">    <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否为链表头元素，是则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 正在进行扩容，在新数组和旧数组中进行查找</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 未进行扩容，则在链表中遍历</span></span><br><span class="line">        <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                <span class="keyword">return</span> e.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>从这里也可以看出，一般要求 ConcurrentHashMap 中 key 对象的 hashCode 为正数。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.bilibili.com/video/BV1FX4y1g7uC?spm_id_from=333.999.0.0">源码级解读ConcurrentHashMap</a></li><li><p><a href="https://www.cnblogs.com/dgutfly/p/11425599.html">JDK1.8 论ConcurrentHashMap是如何扩容的</a></p></li><li><p><a href="https://blog.csdn.net/every__day/article/details/114952602?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscan&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscan&amp;utm_relevant_index=1">ConCurrentHashMap扩容源码解析——transfer()方法</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2022/02/27/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>/2022/02/27/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>在 c++ 编译的过程中，需要指定文件之间的依赖关系，而编译器通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序。</p><p>大学中有些课程需要先修其他课程，学生需要在这个要求下，通过合理的选课修完所有课程。</p><p>以上两个例子都依赖一个图中的经典算法，拓扑排序。拓扑排序是有向图中对顶点的一种线性排序，使得对于从顶点 u 到顶点 v 的每个有向边，u 在排序结果中都在 v 之前。</p><p>拓扑排序有两种实现方法，Khan 算法和深度优先遍历 DFS 算法。</p><p>在此之前，先介绍本文会遇到的部分概念：</p><ul><li>入度：有向边 u -&gt; v 的个数称为顶点 v 的入度；</li><li>邻接表：图的一种实现方式，对于每个顶点，使用一个表存储与其连接的顶点。在有向图中，表中存储本节点指向的节点，例如有边 u -&gt; v1, u -&gt; v2，则 u 的邻接表为 {v1, v2}。下面为代码实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建立邻接表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n 节点个数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> edges 有向边数组，每个元素edge代表存在edge[0] -&gt; edge[1]的有向边</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 图的连接表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; buildGraph(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] edges) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> ArrayList&lt;&gt;(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> v = edge[<span class="number">1</span>];</span><br><span class="line">        graph.get(u).add(v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-Khan算法"><a href="#2-Khan算法" class="headerlink" title="2. Khan算法"></a>2. Khan算法</h2><p>Khan 算法基于贪心的思想，主要过程为：</p><ul><li>找到一个入度为 0 的节点 u，将该节点 u 加入结果集；</li><li>删除与 u 连接的所有边；</li><li>寻找下一个入度为 0 的节点，重复上述过程；</li><li>如果结果集的长度等于节点个数，则存在拓扑排序结果，反之则不存在。</li></ul><p>为此引入一个队列存储入度为 0 的节点。</p><p><img src="khan算法.png" alt="Khan算法"></p><p>代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] khanTopoSrot(List&lt;List&lt;Integer&gt;&gt; graph) &#123;</span><br><span class="line">    <span class="keyword">int</span> n = graph.size();</span><br><span class="line">    <span class="keyword">int</span>[] inDegrees = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 统计入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; edges = graph.get(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : edges) &#123;</span><br><span class="line">            inDegrees[v]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 选择入度为0的节点入队</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegrees[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.offer(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 结果集中顶点个数</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> vertex = queue.poll();</span><br><span class="line">        res[index++] = vertex;</span><br><span class="line">        List&lt;Integer&gt; edges = graph.get(vertex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v: edges) &#123;</span><br><span class="line">            <span class="comment">// 没有实际删除边，而是将对应节点的入度减少</span></span><br><span class="line">            inDegrees[v]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegrees[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue.offer(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不存在拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (index != n) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设图中顶点个数为 V，边的个数为 E，khan 算法对于每个边访问一次，每个节点访问一次，时间复杂度为 O(V + E)。</p><h2 id="3-DFS"><a href="#3-DFS" class="headerlink" title="3. DFS"></a>3. DFS</h2><p>用一个栈来存储已经搜索完的节点，假设我们当前搜索节点 u，如果 u 的所有相邻节点都已经搜索完成，那么这些节点都已经在栈中了，此时可以把 u 入栈。从栈顶往栈底的顺序看，u 出现在所有 u 的相邻节点的前面，满足拓扑排序的要求。</p><p>这样，对图进行深度优先遍历，最终栈底到栈顶的序列即为拓扑排序的结果。其主要过程是：</p><ul><li><p>选择一个未搜索的节点 u，遍历 u 的每个相邻节点 v。</p><ul><li><p>如果 v 已完成搜索，则跳过；</p></li><li><p>如果 v 未进行搜索，则搜索 v；</p></li><li>如果 v 搜索中，则图中存在环，无法实现拓扑排序；</li></ul></li><li><p>将 u 放入栈中，标记完成。</p></li></ul><p><img src="dfs拓扑排序.png" alt="DFS拓扑排序"></p><p>为此引入数组 visited 来标记节点的状态。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> NOT_SEARCH = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SEARCHING = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> SEARCHED = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] visited;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> Deque&lt;Integer&gt; stack;</span><br><span class="line"><span class="keyword">private</span> List&lt;List&lt;Integer&gt;&gt; graph;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] dfsTopoSrot(List&lt;List&lt;Integer&gt;&gt; graph) &#123;</span><br><span class="line">    <span class="keyword">this</span>.graph = graph;</span><br><span class="line">    <span class="keyword">int</span> n = graph.size();</span><br><span class="line">    <span class="keyword">this</span>.visited = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">this</span>.stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n &amp;&amp; valid; i++) &#123;</span><br><span class="line">        <span class="comment">// 寻找未搜索的节点进行搜索</span></span><br><span class="line">        <span class="keyword">if</span> (visited[i] == NOT_SEARCH) &#123;</span><br><span class="line">            dfs(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不存在拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从栈底到栈顶构建结果</span></span><br><span class="line">    <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">        res[index++] = stack.pollFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 改变节点u状态为搜索中</span></span><br><span class="line">    visited[u] = SEARCHING;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph.get(u)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[v] == NOT_SEARCH) &#123;</span><br><span class="line">            dfs(v);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == SEARCHING) &#123;</span><br><span class="line">            <span class="comment">// 存在环，无法拓扑排序</span></span><br><span class="line">            valid = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 节点u搜索完成</span></span><br><span class="line">    visited[u] = SEARCHED;</span><br><span class="line">    stack.push(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DFS 算法对于每个顶点访问两次，每个边访问一次，时间复杂度也为 O(V + E)。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological sorting Wikipedia</a></p></li><li><p><a href="https://time.geekbang.org/column/article/76207">数据结构与算法之美</a></p></li><li><a href="https://book.douban.com/subject/26745780/">数据结构与算法分析</a></li><li><a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/ke-cheng-biao-ii-by-leetcode-solution/">leetcode 210官方题解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ事务消息</title>
      <link href="/2022/02/26/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
      <url>/2022/02/26/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="1-事务消息的引入"><a href="#1-事务消息的引入" class="headerlink" title="1. 事务消息的引入"></a>1. 事务消息的引入</h2><p>当本地事务和发消息逻辑捆绑在一起的场景，普通消息可能导致逻辑不一致的问题。</p><p>例如下单成功后给客户发送短信，短信平台是单独的服务，将修改订单状态和发送消息组合成一个事务，下单成功后发送消息，如果消息发送失败，则回滚事务。由于网络阻塞，消息可能发送成功，而 Broker 的确认超时了，客户端认为消息没有成功，回滚了本地事务，下单未成功。但 Broker 已经存储了消息，导致消费者执行了发送短信的业务，出现给用户发送了短信但下单却没成功的情况。</p><p>RocketMQ 在 4.3.0 版本引入事务消息，事务消息将本地事务和发送消息定义到全局事务中，实现分布式事务的最终一致性，解决了上述问题。</p><h2 id="2-使用事务消息"><a href="#2-使用事务消息" class="headerlink" title="2. 使用事务消息"></a>2. 使用事务消息</h2><p>当使用事务消息，核心是实现 <code>TransactionListener</code> 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 用于实现本地事务，在得到半消息的响应后执行</span></span><br><span class="line">    <span class="function">LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(<span class="keyword">final</span> Message msg, <span class="keyword">final</span> Object arg)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查询本地事务状态，回应消息队列的检查请求</span></span><br><span class="line">    <span class="function">LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(<span class="keyword">final</span> MessageExt msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是官方给出的 demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionListenerImpl</span> <span class="keyword">implements</span> <span class="title">TransactionListener</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> AtomicInteger transactionIndex = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> ConcurrentHashMap&lt;String, Integer&gt; localTrans = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">executeLocalTransaction</span><span class="params">(Message msg, Object arg)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> value = transactionIndex.getAndIncrement();</span><br><span class="line">      <span class="keyword">int</span> status = value % <span class="number">3</span>;</span><br><span class="line">      localTrans.put(msg.getTransactionId(), status);</span><br><span class="line">      <span class="keyword">return</span> LocalTransactionState.UNKNOW; <span class="comment">// 事务开始为UNKNOWN状态</span></span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> LocalTransactionState <span class="title">checkLocalTransaction</span><span class="params">(MessageExt msg)</span> </span>&#123;</span><br><span class="line">      Integer status = localTrans.get(msg.getTransactionId());</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">null</span> != status) &#123;</span><br><span class="line">          <span class="keyword">switch</span> (status) &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                  <span class="keyword">return</span> LocalTransactionState.UNKNOW;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                  <span class="comment">// 提交成功为COMMIT_MESSAGE状态</span></span><br><span class="line">                  <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                  <span class="comment">// 事务异常为ROLLBACK_MESSAGE状态</span></span><br><span class="line">                  <span class="keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-事务消息的实现"><a href="#3-事务消息的实现" class="headerlink" title="3. 事务消息的实现"></a>3. 事务消息的实现</h2><p>RocketMQ 使用 2PC 的思想来实现事务消息，官方的流程图如下。</p><p><img src="事务消息流程.png" alt="事务消息流程"></p><p>事务消息主要分为两个流程：事务消息的发送及提交、补偿流程。</p><h4 id="发送与提交"><a href="#发送与提交" class="headerlink" title="发送与提交"></a>发送与提交</h4><ul><li><p>客户端发送半消息；</p></li><li><p>Broker 响应半消息写入结果；</p></li><li><p>客户端根据响应执行本地事务，发送结果；</p></li><li><p>Broker 根据结果执行 Commit 或者 Rollback；</p></li></ul><h4 id="补偿流程"><a href="#补偿流程" class="headerlink" title="补偿流程"></a>补偿流程</h4><ul><li><p>对没有 Commit/Rollback 的事务消息，Broker 发起一次回查；</p></li><li><p>客户端收到回查消息，检查对应本地事务的状态；</p></li><li><p>Broker 根据本地事务状态，重新 Commit 或 Rollback。</p></li></ul><h4 id="半消息"><a href="#半消息" class="headerlink" title="半消息"></a>半消息</h4><p>事务消息与普通消息最大的不同，就是引入了半消息的机制。半消息对消费端是不可见的，Broker 收到半消息后，会替换 topic 为特定的 RMQ_SYS_TRANS_HALF_TOPIC，此时消费端无法获取这个消息。Broker 会开启一个定时任务，从  RMQ_SYS_TRANS_HALF_TOPIC 的队列中拉取消息，根据客户端本地事务状态提交或回滚消息。</p><p>当二阶段为提交消息时，会根据半消息恢复出普通消息，走一遍消息写入流程。</p><h4 id="Op消息"><a href="#Op消息" class="headerlink" title="Op消息"></a>Op消息</h4><p>在收到半消息并写入 CommitLog 之后，当前消息的状态是未知的，需要一个操作来标识这条消息的最终状态。RocketMQ 引入了 Op 消息的概念，用 Op 消息标识事务消息已经确定的状态（Commit 或者 Rollback）。如果消息还没有 Op 消息，那么该事务消息的状态便是未知的。</p><p>在上文 <a href="https://blog.strokebun.top/2022/02/25/RocketMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/">RocketMQ的消息存储</a> 中提到，消息是顺序写入到 CommitLog 的，不会出现删除 CommitLog 中某个消息的情况。故二阶段 Commit 相对于 Rollback 操作只是在写入 Op 消息前创建半消息的索引。</p><p><img src="op消息.png" alt="Op消息"></p><h4 id="处理二阶段失败的消息"><a href="#处理二阶段失败的消息" class="headerlink" title="处理二阶段失败的消息"></a>处理二阶段失败的消息</h4><p>如果在事务消息的二阶段过程中失败了，例如在 Commit 时，出现网络问题导致失败，那么需要通过一定的策略使这条消息最终被 Commit。RocketMQ 采用了一种称为回查的补偿机制。</p><p>Broker 对未确定状态的消息（通过对比半消息和 Op 消息）发起回查，将消息发送到对应的 Producer 端，Producer 检查本地事务的状态，进而 Broker 执行 Commit 或者 Rollback。如果回查超过 15 次还无法得知事务状态， Broker 将回滚该消息。</p><blockquote><p>RocketMQ 的事务消息保证了生产者本地事务完成之后，一定会把消息发送给 Broker，但无法实现完全的分布式事务。例如 A 给 B 转账 200，本地事务中更改存款，发送事务消息成功，但之后 B 账户直接注销，消费者拉取到消息时发现无法转账，需要进行回滚，此时只能依靠消息队列再发送一条 转账回滚 的消息，这里就会引入不可靠性。这种场景出现的概率是比较低的，但在一致性要求很高的场景，需要依赖 TCC 等实现。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">RocketMQ docs</a></li><li><a href="https://www.bilibili.com/video/BV1nM4y1g7ga">RocketMQ消息中间件消费者专题 小刘讲源码</a></li><li><a href="https://juejin.cn/post/7051505735045218335">自顶向下学习 RocketMQ（七）：事务消息</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMQ的消息存储</title>
      <link href="/2022/02/25/RocketMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/"/>
      <url>/2022/02/25/RocketMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>上文 <a href="https://blog.strokebun.top/2022/02/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/">消息队列概述</a> 中说到，为了保证消息不丢失，要求 Broker 将消息落盘后再给客户端发送确认，这就涉及到了消息存储机制。消息存储是 RocketMQ 最为复杂和重要的部分，但官方文档对此介绍却十分简略。</p><p>下图为官方的说明图。</p><p><img src="消息存储官方图.png" alt="消息存储官方图"></p><p>RocketMQ 的消息存储主要由 CommitLog、ConsumeQueue 和 IndexFile 实现。</p><h4 id="CommitLog"><a href="#CommitLog" class="headerlink" title="CommitLog"></a>CommitLog</h4><p>Broker 收到信息后，把这个消息顺序写入到磁盘上的一个文件，叫作 CommitLog。所有 topic 下的消息都写入到 CommitLog 中，实现严格的顺序写，提高磁盘写入速率。</p><p><img src="commitlog示意.png" alt="CommitLog示意"></p><p>CommitLog 存储了消息内容和元数据，其存储文件单个大小默认为 1G，文件名是起始偏移量，长度为 20 位。第一个文件名为 00000000000000000000，当第一个文件写满了，第二个文件为 00000000001073741824（1G = 1073741824），以此类推。</p><h4 id="ConsumeQueue"><a href="#ConsumeQueue" class="headerlink" title="ConsumeQueue"></a>ConsumeQueue</h4><p>RocketMQ 是基于 topic 和 tag 的订阅模式，消费消息也是根据 topic 进行的，遍历 CommitLog 查找 topic 十分低效，故引入 ComsumeQueue 来提高搜索效率。</p><p>ComsumeQueue 可以看成是基于 topic 的 CommitLog 索引，采用定长设计，每个条目 20 个字节，保存了指定 topic 下的消息的在 CommitLog 中的偏移 offset（8 字节）、消息大小 size（4字节）、和消息 tag 的 hashCode 值（8 字节）。</p><p><img src="consumequeue示意.png" alt="ConsumeQueue"></p><p>每一个 topic 下的每个 MessageQueue 都有对应的一系列 ConsumeQueue文件，在磁盘中存储以文件树的形式存在：</p><p><img src="consumequeue存储.png" alt="ConsumeQueue存储"></p><h4 id="IndexFile"><a href="#IndexFile" class="headerlink" title="IndexFile"></a>IndexFile</h4><p>IndexFile 提供了一种可以通过 key 或时间区间来查询消息的方法。</p><p>IndexFile 的文件逻辑结构如下图，类似哈希表，主要由 Header、Slot Table、Index Linked List 三部分组成。</p><p><img src="indexfile.png" alt="IndexFile"></p><ul><li>Header：存储这个 IndexFile 文件的元信息，主要包括：<ul><li>beginTimestamp：包含消息的最小存储时间；</li><li>endTimestamp：包含消息的最大存储时间；</li><li>beginPhyoffset：包含消息的最小 CommitLog 文件偏移量；</li><li>endPhyoffset：包含消息的最大 CommitLog 文件偏移量；</li><li>hashSlotcount：包含 hashSlot 的数量；</li><li>indexCount：已使用的 index 数量。</li></ul></li><li>Slot Table：哈希表，每个槽存储相同 hash 值的 IndexItem 链表头节点；</li><li>Index Linked List：IndexItem 链表，包含：<ul><li>Key Hash：消息 key 的 hash；</li><li>Commit Offset：消息的物理偏移；</li><li>Next Index Offset：链表的下一个 IndexItem 的位置。</li></ul></li></ul><p>例如根据 key 查找，其效果类似哈希表的查找，会根据 key 的哈希值找到 IndexItem 链表头，遍历链表比对 key 自身，寻找匹配的 IndexItem。</p><h2 id="2-页缓存和mmap"><a href="#2-页缓存和mmap" class="headerlink" title="2. 页缓存和mmap"></a>2. 页缓存和mmap</h2><p>在介绍写入和读取消息前，需要先补充两个 RocketMQ 利用的操作系统的机制。</p><h3 id="2-1-页缓存"><a href="#2-1-页缓存" class="headerlink" title="2.1 页缓存"></a>2.1 页缓存</h3><p>Page Cache，页缓存是操作系统对磁盘的缓存，将磁盘的数据缓存到内存中。</p><ul><li>当内核进行一个读操作时，先检查数据是否命中（是否在页缓存中），如果是，则会直接从内存读取；否则则从磁盘中读取该页和相邻的页（称为预读），并加载到页缓存中；</li><li>当内核进行一个写操作时，将缓存中的数据标记为脏，并由一个后台进程写回磁盘，实现数据同步（称为回写）。用户层面的数据写入可以被近似为一个写内存的的操作。</li></ul><blockquote><p>页缓存的具体机制可见 《Linux 内核设计与实现》第 16 章。</p><p>可以发现，CommitLog 相对于 Page Cache，类似于 InnoDB 中的 redo log 相对于 Buffer Pool。Page Cache、Buffer Pool 与 CPU cache、分布式系统中的缓存也有共通之处，读者可以自行归纳。</p></blockquote><p>在对消息进行消费时，会对 ConsumeQueue 进行顺序读取，在 Page Cache 的预读机制作用下，极大提升读性能。</p><h3 id="2-2-mmap"><a href="#2-2-mmap" class="headerlink" title="2.2 mmap"></a>2.2 mmap</h3><p>mmap 可以将磁盘上的物理文件直接映射到用户态的内存地址中，减少了传统 IO 需要从用户态到内核缓冲区的拷贝操作。</p><blockquote><p>mmap 的具体介绍可见《Linux 内核设计与实现》第 15.5 小节。</p></blockquote><p>Java 中提供了 <code>MappedBuffer</code> 实现将文件操作转化为直接在内存地址进行操作。RocketMQ 通过 <code>MappedByteBuffer</code> 进行文件读写，提高了文件读写的效率。</p><h2 id="3-消息写入"><a href="#3-消息写入" class="headerlink" title="3. 消息写入"></a>3. 消息写入</h2><p>最底层消息写入逻辑在 CommitLog 的 <code>asyncPutMessage</code> 方法中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.store.CommitLog::asyncPutMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;PutMessageResult&gt; <span class="title">asyncPutMessage</span><span class="params">(<span class="keyword">final</span> MessageExtBrokerInner msg)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        putMessageLock.lock(); <span class="comment">//spin or ReentrantLock ,depending on store config</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取MappedFile</span></span><br><span class="line">            MappedFile mappedFile = <span class="keyword">this</span>.mappedFileQueue.getLastMappedFile();</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 向缓冲区写消息</span></span><br><span class="line">            result = mappedFile.appendMessage(msg, <span class="keyword">this</span>.appendMessageCallback, putMessageContext);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">// 提交刷盘请求</span></span><br><span class="line">            CompletableFuture&lt;PutMessageStatus&gt; flushResultFuture = submitFlushRequest(result, msg);</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            putMessageLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>asyncPutMessage</code> 主要分为获取 MappedFile、写缓冲区、提交刷盘请求三步。</p><h3 id="3-1-获取MappedFile"><a href="#3-1-获取MappedFile" class="headerlink" title="3.1 获取MappedFile"></a>3.1 获取MappedFile</h3><p>申请 <code>MappedFile</code> 会创建两个，这样下次请求即可使用已预创的 <code>MappedFile</code>，减少等待时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.AllocateMappedFileService::putRequestAndReturnMappedFile</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappedFile <span class="title">putRequestAndReturnMappedFile</span><span class="params">(String nextFilePath, String nextNextFilePath, <span class="keyword">int</span> fileSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//请求创建 MappedFile</span></span><br><span class="line">    AllocateRequest nextReq = <span class="keyword">new</span> AllocateRequest(nextFilePath, fileSize);</span><br><span class="line">    <span class="keyword">boolean</span> nextPutOK = <span class="keyword">this</span>.requestTable.putIfAbsent(nextFilePath, nextReq) == <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//请求预先创建下一个 MappedFile</span></span><br><span class="line">    AllocateRequest nextNextReq = <span class="keyword">new</span> AllocateRequest(nextNextFilePath, fileSize);</span><br><span class="line">    <span class="keyword">boolean</span> nextNextPutOK = <span class="keyword">this</span>.requestTable.putIfAbsent(nextNextFilePath, nextNextReq) == <span class="keyword">null</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取本次创建 MappedFile</span></span><br><span class="line">    AllocateRequest result = <span class="keyword">this</span>.requestTable.get(nextFilePath);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了预分配之外，还会进行文件预热。虽然建立了虚拟内存地址到物理内存地址的映射，但此时并没有加载 Page Cache，读写数据时发现未命中会从磁盘中加载，影响性能。预热实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.MappedFile::warmMappedFile</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warmMappedFile</span><span class="params">(FlushDiskType type, <span class="keyword">int</span> pages)</span> </span>&#123;</span><br><span class="line">        ByteBuffer byteBuffer = <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">        <span class="keyword">int</span> flush = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 通过写入 1G 的字节 0 来让操作系统分配物理内存空间，如果没有填充，操作系统不会实际分配物理内存</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.fileSize; i += MappedFile.OS_PAGE_SIZE, j++) &#123;</span><br><span class="line">            byteBuffer.put(i, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// force flush when flush disk type is sync</span></span><br><span class="line">            <span class="keyword">if</span> (type == FlushDiskType.SYNC_FLUSH) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i / OS_PAGE_SIZE) - (flush / OS_PAGE_SIZE) &gt;= pages) &#123;</span><br><span class="line">                    flush = i;</span><br><span class="line">                    mappedByteBuffer.force();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ... </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// force flush when prepare load finished</span></span><br><span class="line">        <span class="keyword">if</span> (type == FlushDiskType.SYNC_FLUSH) &#123;</span><br><span class="line">            mappedByteBuffer.force();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-写缓冲区"><a href="#3-2-写缓冲区" class="headerlink" title="3.2 写缓冲区"></a>3.2 写缓冲区</h3><p>CommitLog 中包含了消息内容、消息长度、魔数、发送时间、是否压缩等信息，<code>CommitLog::appendMessagesInner</code> 方法实现了写入逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// org.apache.rocketmq.store.MappedFile::appendMessagesInner</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">appendMessagesInner</span><span class="params">(<span class="keyword">final</span> MessageExt messageExt, <span class="keyword">final</span> AppendMessageCallback cb, PutMessageContext putMessageContext)</span> </span>&#123;</span><br><span class="line">    ByteBuffer byteBuffer = writeBuffer != <span class="keyword">null</span> ? writeBuffer.slice() : <span class="keyword">this</span>.mappedByteBuffer.slice();</span><br><span class="line">    ...</span><br><span class="line">    byteBuffer.position(currentPos);</span><br><span class="line">    AppendMessageResult result  = cb.doAppend(...);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// org.apache.rocketmq.store.CommitLog::doAppend</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AppendMessageResult <span class="title">doAppend</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> fileFromOffset, <span class="keyword">final</span> ByteBuffer byteBuffer, <span class="keyword">final</span> <span class="keyword">int</span> maxBlank, <span class="keyword">final</span> MessageExtBrokerInner msgInner, PutMessageContext putMessageContext)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 将消息写入缓冲区，未实际刷盘</span></span><br><span class="line">    byteBuffer.put(preEncodeBuffer);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>到此为此，消息被写入了 <code>ByteBuffer</code>，何时持久化将在刷盘中介绍。</p><p>此处只写入了 CommitLog，那么 ConsumeQueue 和 IndexFile 在哪写入呢？因为 CommitLog 内保存了 ConsumeQueue 和 IndexFile 的所需信息，即使 Broker 崩溃，也能依靠这些信息恢复。也就是说，存储 CommitLog 和存储 ConsumeQueue、IndexFile 没有必要的先后关系。在消息存储时，会启动一个异步线程用于存储 ConsumeQueue 和 IndexFile，进一步减少写入延迟。</p><h3 id="3-3-消息刷盘"><a href="#3-3-消息刷盘" class="headerlink" title="3.3 消息刷盘"></a>3.3 消息刷盘</h3><p>RocketMQ 的刷盘分为：</p><ul><li>同步刷盘：消息持久到磁盘后 Broker 才发送确认给客户端。如果保证消息不丢失，需要采用同步刷盘，但会降低性能；</li><li>异步刷盘：写入 Page Cache 后 Broker 就发送确认，消息刷盘依赖操作系统完成。异步刷盘能够提高性能和吞吐量，但 Broker 崩溃后可能丢失消失。</li></ul><p><img src="刷盘.png" alt="刷盘"></p><h2 id="4-消息读取"><a href="#4-消息读取" class="headerlink" title="4. 消息读取"></a>4. 消息读取</h2><p>消息读取逻辑简单许多，此处介绍根据 offset 和根据 key 查询两种方式。</p><h3 id="4-1-根据-offset-查询"><a href="#4-1-根据-offset-查询" class="headerlink" title="4.1 根据 offset 查询"></a>4.1 根据 offset 查询</h3><p>读取消息的过程为：</p><ul><li>根据 topic 和 queueId 找到相应路径的 ConsumeQueue；</li><li>根据 ConsumeQueue 找到消息在 CommitLog 文件中的物理偏移，读取消息内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.DefaultMessageStore::getMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> GetMessageResult <span class="title">getMessage</span><span class="params">(<span class="keyword">final</span> String group, <span class="keyword">final</span> String topic, <span class="keyword">final</span> <span class="keyword">int</span> queueId, <span class="keyword">final</span> <span class="keyword">long</span> offset,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> <span class="keyword">int</span> maxMsgNums,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">final</span> MessageFilter messageFilter)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 找到对应的 ConsumeQueue</span></span><br><span class="line">    ConsumeQueue consumeQueue = findConsumeQueue(topic, queueId);</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 根据offset找到对应的ConsumeQueue的MappedFile</span></span><br><span class="line">    SelectMappedBufferResult bufferConsumeQueue = consumeQueue.getIndexBuffer(offset);</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">for</span> (...) &#123;</span><br><span class="line">        <span class="comment">// CommitLog的物理地址</span></span><br><span class="line">        <span class="keyword">long</span> offsetPy = bufferConsumeQueue.getByteBuffer().getLong();</span><br><span class="line">        <span class="keyword">int</span> sizePy = bufferConsumeQueue.getByteBuffer().getInt();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 从CommitLog拿到具体的消息</span></span><br><span class="line">        SelectMappedBufferResult selectResult = <span class="keyword">this</span>.commitLog.getMessage(offsetPy, sizePy);</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">// 将消息放入结果集</span></span><br><span class="line">        getResult.addMessage(selectResult);</span><br><span class="line">        status = GetMessageStatus.FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 更新 offset</span></span><br><span class="line">    nextBeginOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">    ...</span><br><span class="line">    getResult.setStatus(status);</span><br><span class="line">    getResult.setNextBeginOffset(nextBeginOffset);</span><br><span class="line">    <span class="keyword">return</span> getResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-2-根据-key-查询"><a href="#4-2-根据-key-查询" class="headerlink" title="4.2 根据 key 查询"></a>4.2 根据 key 查询</h3><p>根据 key 查询的过程：</p><ul><li>根据 topic 和 key 找到 IndexFile 文件中的 IndexItem；</li><li>根据 indexItem 确定消息在 CommitLog 的物理偏移，读取消息内容。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.rocketmq.store.DefaultMessageStore::queryMessage</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> QueryMessageResult <span class="title">queryMessage</span><span class="params">(String topic, String key, <span class="keyword">int</span> maxNum, <span class="keyword">long</span> begin, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    QueryMessageResult queryMessageResult = <span class="keyword">new</span> QueryMessageResult(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 获取IndexFile文件中记录的消息在CommitLog文件的物理偏移</span></span><br><span class="line">        QueryOffsetResult queryOffsetResult = <span class="keyword">this</span>.indexService.queryOffset(topic, key, maxNum, begin, lastQueryMsgTime);</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; queryOffsetResult.getPhyOffsets().size(); m++) &#123;</span><br><span class="line">            <span class="keyword">long</span> offset = queryOffsetResult.getPhyOffsets().get(m);</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//在 CommitLog 文件获取消息内容</span></span><br><span class="line">            SelectMappedBufferResult result = <span class="keyword">this</span>.commitLog.getData(offset, <span class="keyword">false</span>);</span><br><span class="line">            ...</span><br><span class="line">            queryMessageResult.addMessage(result);</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queryMessageResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p><img src="总结.png" alt="总结"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md">RocketMQ docs</a></li><li><p><a href="https://book.douban.com/subject/6097773/">Linux内核设计与实现</a></p></li><li><p><a href="https://juejin.cn/post/7028385090036039717#heading-0">深入剖析RocketMQ源码 - 消息存储模块</a></p></li><li><a href="https://juejin.cn/post/6996536657818173453#heading-15">《高性能利器》-32张图带你解决RocketMQ所有场景问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列概述</title>
      <link href="/2022/02/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/"/>
      <url>/2022/02/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>消息队列 Message Queue，MQ 是现今系统中常用的中间件，一般有以下用途。</p><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p>同步请求需要阻塞等待服务端的响应，增加了调用时间，而 MQ 可以实现服务的异步处理，可以：</p><ul><li>更快地返回结果，减少等待；</li><li>自然实现并发，提升系统的总体性能。</li></ul><h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>在瞬间高并发的场景下，服务器无法处理可能被打挂，而其他阶段的流量又很少，服务器计算资源浪费。MQ 可以隔离网关和后端服务，达到削峰填谷的功能。</p><h4 id="服务解耦"><a href="#服务解耦" class="headerlink" title="服务解耦"></a>服务解耦</h4><p>MQ 的另一个作用，是实现系统应用间的解耦。例如一个服务 A，需要依次调用 B、C、D，服务中出现了强耦合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">service <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B();</span><br><span class="line">    C();</span><br><span class="line">    D();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而当出现新服务 E 需要调用时，需要改动 A 服务。而引入 MQ 后，A 可以通过发送消息到一个 Topic，下游服务通过订阅 Topic 获得消息处理，这样下游服务的变化对上游服务没有影响。</p><blockquote><p>虽然 MQ 具有上述好处，但引入 MQ 也会带来延迟、增加系统复杂度、导致数据不一致的问题，需要权衡选择。</p></blockquote><h2 id="2-主流的消息队列"><a href="#2-主流的消息队列" class="headerlink" title="2.主流的消息队列"></a>2.主流的消息队列</h2><p>消息队列种类繁多，其中最主流的有 RabbitMQ、RocketMQ、Kafka。</p><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><p>RabbitMQ 是老牌的消息队列，最早用于电信系统的可靠通信，其最大的优点是低延迟，可以达到微妙级，并且轻量易部署。</p><p>但是 RabbitMQ 也存在以下问题：</p><ul><li>消息堆积时性能急剧下降；</li><li>吞吐量较低，只能达到万级；</li><li>基于小众语言 Erlang 实现，二次开发困难。</li></ul><p>由于上述的缺点，RabbitMQ 已不再受大型互联网公司的青睐。</p><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><p>RocketMQ 是阿里开源的消息队列，后面捐赠给 Apache 成为顶级项目。</p><p>RocketMQ 基于 Java 开发，二次开发和拓展比较容易，并且对在线业务的响应时延做了大量优化，可以达到毫秒级别的延迟，适合快速响应的场景，吞吐量在十万级别。</p><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><p>Kafka 由 Linkedln 开发，目前是 Apache 的顶级项目，最初是为了处理海量日志。</p><p>Kafka 使用 Scala 和 Java 开发，拥有良好的生态，在大数据领域都会支持 Kafka，延迟和吞吐量都与 RocketMQ 相近，最适合处理海量消息例如日志、监控信息、埋点等。</p><div class="table-container"><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">RabbitMQ</th><th style="text-align:center">RocketMQ</th><th style="text-align:center">Kafka</th></tr></thead><tbody><tr><td style="text-align:center">单机吞吐量</td><td style="text-align:center">同 ActiveMQ</td><td style="text-align:center">10 万级，支撑高吞吐</td><td style="text-align:center">10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td style="text-align:center">topic 数量对吞吐量的影响</td><td style="text-align:center"></td><td style="text-align:center">topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td style="text-align:center">topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td style="text-align:center">时效性</td><td style="text-align:center">微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td style="text-align:center">ms 级</td><td style="text-align:center">延迟在 ms 级以内</td></tr><tr><td style="text-align:center">可用性</td><td style="text-align:center">同 ActiveMQ</td><td style="text-align:center">非常高，分布式架构</td><td style="text-align:center">非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td style="text-align:center">消息可靠性</td><td style="text-align:center">基本不丢</td><td style="text-align:center">经过参数优化配置，可以做到 0 丢失</td><td style="text-align:center">同 RocketMQ</td></tr><tr><td style="text-align:center">功能支持</td><td style="text-align:center">基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td style="text-align:center">MQ 功能较为完善，还是分布式的，扩展性好</td><td style="text-align:center">功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table></div><h2 id="3-常见设计问题"><a href="#3-常见设计问题" class="headerlink" title="3. 常见设计问题"></a>3. 常见设计问题</h2><h3 id="3-1-消息不丢失"><a href="#3-1-消息不丢失" class="headerlink" title="3.1 消息不丢失"></a>3.1 消息不丢失</h3><p>一条消息从生成到消费完成，一般需要经历三个阶段。</p><p><img src="消息的生命周期.png" alt="消息的三个阶段"></p><ul><li>生产阶段：Producer 创建消息，发送到 Broker；</li><li>存储阶段：Broker 存储消息；</li><li>消费阶段：Consumer 从 Broker 拉取消息，消息经过网络传输到 Consumer。</li></ul><p>三个阶段出错都可能导致消息丢失，都需要进行保障。</p><h4 id="生产阶段"><a href="#生产阶段" class="headerlink" title="生产阶段"></a>生产阶段</h4><p>类似 TCP 的可靠传输，消息队列使用了请求确认机制，只要客户端收到了 Broker 的确认，那么生产阶段的消息就不会丢失。</p><p>在编写消息发送的代码时，需要注意捕获异常和处理异步调用，发送失败进行重传，就能保证该阶段的消息不丢失。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    RecordMetadata data = producer.send(message.get());</span><br><span class="line">    System.out.println(<span class="string">&quot;发送成功&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">    <span class="comment">// 重传逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存储阶段"><a href="#存储阶段" class="headerlink" title="存储阶段"></a>存储阶段</h4><p>在单机情况下，通过合理的配置，Broker 在消息落盘后对客户端发送确认，此时已经保证消息不丢失。</p><p>对于集群模式，需要发送其他 2 个以上的节点，再给客户端发送确认，才能保证消息不丢失。</p><h4 id="消费阶段"><a href="#消费阶段" class="headerlink" title="消费阶段"></a>消费阶段</h4><p>消费阶段也采用确认机制，Broker 没收到消费端的确认，下一次仍返回同一条消息。</p><p>在消费端的业务代码中，需要执行完所有业务逻辑，再发送确认。</p><p>但再消费阶段可能存在一个坑点，消费失败，下次拉取消息继续消费失败，继续拉取，继续失败……这样会导致消费端死循环，真实场景一般会选用以下方案：</p><ul><li>消息失败将消息存到 Redis，记录消费次数，多次消费失败则丢弃，记录日志落库保存；</li><li>丢失该消息，记录日志，通过邮件、短信等手段通知负责人手动处理。</li></ul><h3 id="3-2-消息重复消费"><a href="#3-2-消息重复消费" class="headerlink" title="3.2 消息重复消费"></a>3.2 消息重复消费</h3><p>消息队列普遍采用请求确认机制，消费端难免拉取到重复的消息，一般的解决方案是实现消费幂等性。</p><h4 id="数据库唯一约束"><a href="#数据库唯一约束" class="headerlink" title="数据库唯一约束"></a>数据库唯一约束</h4><p>一个实现消费幂等性的手段是使用数据库的唯一约束，例如现在的场景是 给 B 增加 100元，可以建立一张转账表，其中有转账单 id、账户 id 和变更金额等字段，组合转账单 id 和账户 id 作为唯一约束，这样对于相同的转账单，表中只能存在一条记录，而消费消息的逻辑变为在转账表中添加转账记录，后续根据转账记录，异步更新用户余额，即实现了幂等消费。</p><p>类似的，也可以使用 Redis 的 SETNX 操作实现。</p><h4 id="设置版本号"><a href="#设置版本号" class="headerlink" title="设置版本号"></a>设置版本号</h4><p>另一个常用的手段是给消息和表都增加一个版本号，比较当前数据和消费的版本号是否一致，不一致则丢弃数据，一致则更新数据并将版本号 +1，实现幂等更新。</p><h4 id="分布式id"><a href="#分布式id" class="headerlink" title="分布式id"></a>分布式id</h4><p>在发送消息时，给消息指定分布式 id，消费时检查该 id 的消息是否被消费过，如果没有消费则更新数据，同时更改消费状态。</p><p>这种方式的通用性最强，可以处理绝大部分场景，但是分布式 id 的生成是一个难题。</p><h3 id="3-3-消息顺序性"><a href="#3-3-消息顺序性" class="headerlink" title="3.3 消息顺序性"></a>3.3 消息顺序性</h3><p>在 binlog 同步系统中，如果引入了消息队列，消费端消费的顺序需要与生产顺序一致，否则将会导致数据错误。最直接的手段是只采用一个 queue，消费者单线程拉取，这样就保证了顺序性，但却牺牲了吞吐量。</p><p>对于一般系统而言，通常有以下手段：</p><ul><li>生产端首先需要保证入队顺序，使用同步发送，一个消息发送成功再发送下一个消息；</li><li>通过哈希取模等方法，让同一个订单进入同一个队列；</li><li>消费端保证消费顺序性，使用多线程，但每个线程消费对应的队列。</li></ul><p><img src="顺序消费.png" alt="顺序消费"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="消息队列总结.png" alt="消息队列总结"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://time.geekbang.org/column/intro/100032301">消息队列高手课</a></li><li><a href="https://github.com/doocs/advanced-java">advanced-java</a></li><li><a href="https://juejin.cn/post/6977981645475282958#heading-0">RabbitMQ 可靠性、重复消费、顺序性、消息积压解决方案</a></li><li><a href="https://juejin.cn/post/7055156612528341022#heading-0">一看就会的kafka多线程顺序消费</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP GET和POST的区别</title>
      <link href="/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>GET 和 POST 是 HTTP 发送请求最常用的两种方法，当你搜索两者的区别时，很容易得到以下回答：</p><ul><li>GET 通过 URL 传递参数，而 POST 放在请求体 request body 中；</li><li>GET 直接在 URL 中暴露参数，相比 POST 更不安全；</li><li>对参数的数据类型，GET 只接受 ASCII 字符，而POST没有限制；</li><li>GET 传递数据大小有限制，而 POST 没有限制；</li><li>GET 发送一个请求，而 POST 发送两个请求；</li><li>……</li></ul><p>但如果查看相关 RFC 文档的话，便会产生质疑。</p><blockquote><p>The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some identifiable information via HTTP, they are generally referring to making a GET request.<br>A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.</p><p>The POST method requests that the target resource process the representation enclosed in the request according to the resource’s own specific semantics.</p></blockquote><p>大概意思是 GET 方法的语义是请求指定的资源，不修改数据、幂等、可缓存的，GET 请求的 request body 没有明确语义；而 POST 的语义是根据 request body 的内容处理资源，可能修改数据、不幂等、不缓存（大部分）。除此之外没有其他规定了。</p><blockquote><p>GET 的语义是读取，反复读取不应该有副作用，所以能进行缓存。而 POST 的语义是提交，这往往是有副作用的，因此不能被缓存。</p></blockquote><p>然而上述说明也不是强制性的，服务端完全可以实现无副作用的 POST 和有副作用的 GET 请求，前者往往没有影响，但后者往往会跟浏览器的预期不符合，所以在服务端往往会遵守 GET 幂等，POST 非幂等的设计。</p><blockquote><p>这不代表 POST 接口都是非幂等的，需要根据业务选择。</p></blockquote><p>那上面说的那些区别怎么解释呢？</p><h4 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h4><p>关于 GET 通过 URL 传递参数，这是因为在使用浏览器时，GET 请求只能由 URL 触发，要携带参数就只能通过 URL，所以才会出现这个说法。</p><p>但当把客户端的范围扩大，包括手机设备、postman 这类工具时，就没有类似浏览器的限制了，只需要遵守 HTTP 请求的格式即可。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">METHOD</span>&gt;</span> <span class="tag">&lt;<span class="name">URL</span>&gt;</span> <span class="tag">&lt;<span class="name">Version</span>&gt;</span>\r\n</span><br><span class="line"><span class="tag">&lt;<span class="name">Header1</span>&gt;</span>: <span class="tag">&lt;<span class="name">HeaderValue1</span>&gt;</span>\r\n</span><br><span class="line"><span class="tag">&lt;<span class="name">Header2</span>&gt;</span>: <span class="tag">&lt;<span class="name">HeaderValue2</span>&gt;</span>\r\n</span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">HeaderN</span>&gt;</span>: <span class="tag">&lt;<span class="name">HeaderValueN</span>&gt;</span>\r\n</span><br><span class="line">\r\n</span><br><span class="line"><span class="tag">&lt;<span class="name">Body</span> <span class="attr">Data....</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中的 METHOD 可以是 GET/POST，也可以是 PUT、DELETE 等。HTTP 协议并没有限制 GET 请求不能有 body，POST 不能将参数放到 URL 上。HTTP 协议交由用户自定义实现，例如 Elastic Search 的搜索功能就使用了携带 body 的 GET。</p><p>极高的自由反而是不自由，这样每次开发都得约定一系列规范，造成更多的不便。于是一些统一的规范便出现了，其中最典型的是 REST，REST 规定 GET、POST、PUT 和 DELETE 分别用于获取、创建、替换和删除资源。</p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>针对安全性有这样的说法，GET 由于在 URL 中暴露参数，相比 POST 更加不安全。但 HTTP 本身就是不安全的，所有的数据都是明文传输的，讨论 GET 和 POST 的安全性没有太大意义，保证安全性应该选用 HTTPS。</p><h4 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h4><p>另一个常见说法是 GET 的参数只支持 ASCII，而 POST 没有限制。出现这个说法是因为前一个说法 “GET 通过 URL 传递参数” 推导出来的，而 URL 只能使用 ASCII 字符，POST 使用 body 传输，所以没有限制。</p><p>一方面，URL 只能使用 ASCII 字符这个说法本身就是错误的，RFC 中的规定是 ASCII 的一部分字符可以在 URL 中直接使用，其他字符需要经过 Percent Encoding。例如本文的 URL <a href="https://blog.strokebun.top/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/">https://blog.strokebun.top/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/</a> 便经过了编码。</p><p>另一方面，上文也说到了，GET 和 POST 都能使用 URL 和 body 传递参数，所以 GET 的参数是没有限制的。 </p><h4 id="传递数据限制"><a href="#传递数据限制" class="headerlink" title="传递数据限制"></a>传递数据限制</h4><p>上面说到浏览器的 GET 请求通常使用 URL 传递数据，所以 GET 数据有长度限制（也就是 URL 长度限制）。</p><p>HTTP 协议对 URL 长度没有任何规定，实际的限制是客户端和服务端共同决定的。一方面，浏览器通常会对输入的 URL 进行了限制，例如 Chrome 限制为 2MB，其他浏览器也有各自的限制；另一方面，服务端例如 Tomcat 在处理 URL 时需要先分配内存，于是限制长度防止分配过大的内存。</p><p>对于 GET 请求的参数过多导致 URL 过长的问题，更推荐采用 body 传输参数。</p><h4 id="发送包数"><a href="#发送包数" class="headerlink" title="发送包数"></a>发送包数</h4><p>上面的说法有不少文章已经进行了分析，但其中大部分还提到一点，GET 产生一个 TCP 数据包，POST 产生两个 TCP 数据包。</p><p>浏览器会把 GET 请求的 header 和 data 一起发送，服务器响应 200；而对于 POST，浏览器先发送 header，服务器响应 100，浏览器再发送 data，服务器响应 200。</p><p>一个例子是上传文件，URL 包含文件名称，body 是二进制流。服务端接收请求后，先根据 header 校验是否符合规范，不符合就直接丢弃，符合的话响应 100，继续接收请求。于是客户端可以做一些优化，如果数据量大就先发送 header，但是不同的客户端实现是不一样的，也可以选择不做优化。</p><p>怎么发包是由客户端自主决定的，只要符合 HTTP 协议就行，这是一种优化，但不是 GET 和 POST 自身的区别。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>RFC 只规定了 GET 和 POST 的语义，二者没有本质的区别，网上提到的大部分区别只是一种约定。但在实际开发中也不用纠结 RFC，协议是人定的，遇到实际问题灵活运用工具，适当反规范没有问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.w3school.com.cn/tags/html_ref_httpmethods.asp">HTTP请求方法 w3school</a></li><li><p><a href="https://www.rfc-editor.org/info/rfc7231">RFC 7231</a></p></li><li><p><a href="https://mp.weixin.qq.com/s?__biz=MzI3NzIzMzg3Mw==&amp;mid=100000054&amp;idx=1&amp;sn=71f6c214f3833d9ca20b9f7dcd9d33e4#rd">99%的人都理解错了HTTP中GET与POST的区别</a></p></li><li><p><a href="https://www.zhihu.com/question/28586791/answer/767316172">GET 和 POST 到底有什么区别？ 大宽宽的回答</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP的粘包</title>
      <link href="/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/"/>
      <url>/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h2 id="1-粘包与半包"><a href="#1-粘包与半包" class="headerlink" title="1. 粘包与半包"></a>1. 粘包与半包</h2><p>之前的文章中一直提到，TCP 是面向流的协议，也就是说协议的内容像流水一样，没有明确的分割标志。</p><p>TCP 默认使用了 Nagle 算法，为了提高传输性能，会将多个包累积一起发送。 </p><p>例如 A 和 B 使用了 TCP 进行通信，A 向 B 发送了两个数据包，分别为 100 字节和 200 字节。B 可能先收到 100 字节，再收到 200 字节，这很美好；也可能先收到 50 字节，再收到 250 字节；也可能先收到 50 字节，再收到 100 字节，最后收到 150 字节……</p><p>发送方 A 是知道两个数据包的边界是 100 字节，然而对于接收方 B 而言，是不知道把收到的数据中多少字节作为一个包来处理的。</p><p>当发送方发送多个包以上的数据时，接收方一次读取的数据可能是大于等于 1 个（1 个，1.5 个，3 个…皆有可能）包的数据，这被称为粘包。相应的，如果一次发送数据很多，由于 TCP 受到底层 MTU 的限制，会将其分为多个 TCP 包发送，而接收方读取的数据可能只是包的一部分，这被称为半包。</p><p><img src="粘包.png" alt="TCP粘包与半包"></p><p>粘包不是 TCP 协议造成的，它的出现是由于设计了不合适的应用层协议。当被问到这个问题时，往往是想考验设计协议的能力。</p><blockquote><p>粘包和半包是应用层实现者的过错，不是 TCP 协议的问题，这里分享一个知乎用户的段子。</p><p>看到“TCP粘包”这个专有名词，我表示极度震惊。连夜打车回到家里，战战兢兢翻开《计算机网络》，拿着放大镜仔细看了半夜，也没看到“粘包”两个字。我的后背不觉地渗出致密的汗水，双手止不住地发抖。匆忙打开电脑，一篇篇地翻着论文，试图寻找关于这个词的信息。可眼看天就要亮了，我依旧一无所获。</p><p>我失望的躺在床上，满脑子都是“粘包，粘包，粘包！”，横竖睡不着，不得已打开了知乎，写下了一个问题“究竟什么是TCP粘包”。不一会儿答案就如雪花儿般涌了出来，每一片雪花上都写着一句话“TCP没有粘包”。我颤抖的双手终于停了下来，一股热流从我心底涌到泪腺。啊，原来我并不孤独。</p></blockquote><h2 id="2-解决方案"><a href="#2-解决方案" class="headerlink" title="2. 解决方案"></a>2. 解决方案</h2><p>解决 TCP 粘包的核心在于设计一个有消息边界的应用层协议，主要有以下方式。</p><h3 id="2-1-固定长度"><a href="#2-1-固定长度" class="headerlink" title="2.1 固定长度"></a>2.1 固定长度</h3><p>一个直观的思路每个包采用固定长度，接收方每次收满一个包长度的数据，再拿出来解析。</p><p>这种思路格式简单，但如果包内容不足固定长度，需要进行填充，造成空间浪费。另一方面灵活性差，包内容超过固定长度， 需要进行分包分片，增加额外的处理逻辑。一般不推荐使用。</p><p>在 netty 中可以用 <code>FixedLengthFrameDecoder</code> 实现固定长度的解析。 </p><h3 id="2-2-分割符"><a href="#2-2-分割符" class="headerlink" title="2.2 分割符"></a>2.2 分割符</h3><p>另一种思路是设置一个分割符标记包的末尾，例如 FTP 协议中通过 “\r\n” 表示一个包的结束。</p><p>分割符方案实现比较简单，也没有空间浪费，但有一个小缺点，当包的内容存在分割符时，需要进行转义和额外的解析工作。</p><p>在 netty 中可以用 <code>DelimiterBasedFrameDecoder</code> 实现基于分割符的解析。 </p><h3 id="2-3-固定长度首部-数据体"><a href="#2-3-固定长度首部-数据体" class="headerlink" title="2.3 固定长度首部+数据体"></a>2.3 固定长度首部+数据体</h3><p>类似 TCP、IP 等协议的设计，为数据添加固定长度的首部，在首部中指明数据长度和其他参数，在数据体部分添加实际传输的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bodySize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> version;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收方先读取固定长度的首部，再根据首部中的参数读取特定长度的数据。一般比较复杂的中间件和 RPC 框架都会采用这种方式。</p><p>在 netty 中可以用 <code>LengthFieldBasedFrameDecoder</code> 实现基于分割符的解析。 </p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.zhihu.com/question/20210025">怎么解决TCP网络传输粘包问题</a></p></li><li><p><a href="https://draveness.me/whys-the-design-tcp-message-frame/">为什么TCP协议有粘包问题</a></p></li><li><p><a href="https://www.zhihu.com/question/20210025/answer/1098672130">知乎用户hE5998的回答</a></p></li><li><p><a href="https://time.geekbang.org/course/intro/100036701">netty源码剖析与实现</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP连接的建立与释放</title>
      <link href="/2022/02/21/TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/"/>
      <url>/2022/02/21/TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>TCP 是面向连接的协议，TCP 的连接需要经过三个阶段：连接建立、数据传送、连接释放。上文 <a href="https://blog.strokebun.top/2022/02/20/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/">TCP可靠传输和拥塞控制</a> 介绍了 TCP 在数据传送阶段如何实现可靠传输和拥塞控制，本文主要介绍 TCP 连接的建立和释放。</p><p>再次祭出 TCP 的首部格式：</p><p><img src="TCP头格式.png" alt="TCP首部格式"></p><p>在本文中主要关注以下字段：</p><ul><li>SYN：同步位，该位为 1 时，希望建立连接；</li><li><p>FIN：中止位，该位为 1 时，希望断开连接；</p></li><li><p>ACK：确认位，该位为 1 时，确认应答的字段有效，除了最初的 SYN 包，其他的包都应该设置为 1。</p></li></ul><h2 id="2-连接建立"><a href="#2-连接建立" class="headerlink" title="2. 连接建立"></a>2. 连接建立</h2><h3 id="2-1-三次握手"><a href="#2-1-三次握手" class="headerlink" title="2.1 三次握手"></a>2.1 三次握手</h3><p>TCP 的连接用一个四元组 {源 IP，源端口，目标 IP，目标端口} 标记，TCP 建立连接的过程叫作握手，握手过程需要交换 3 个 TCP 报文段，通常称为三次握手。</p><blockquote><p>这里称为三次握手主要是遵循日常叫法，RFC 文档中的描述是 three way（three message）handshake，其实是在一次握手过程中交换了三个报文。</p></blockquote><p>TCP 建立连接的过程如下：</p><p><img src="三次握手.jpg" alt="TCP三次握手"></p><ul><li>起初客户端和服务端都处于 CLOSED 状态，服务端创建服务，进入 LISTEN（监听） 状态，等待客户端连接；</li><li>第一次：客户端创建随机初始化序号 x，并在首部 seq 字段中写入，同时设置 SYN 为 1，表示为 SYN 报文，发送后进入 SYN-SENT（同步发送）状态；</li><li>第二次：服务端收到请求后，也随机创建一个序号 y，并设置 TCP 首部中的确认应答 ack = x + 1（见可靠传输部分），同时置 SYN 和 ACK 为 1。发送后进入 SYN-REVD（同步收到） 状态；</li><li>第三次：客户端收到服务端的确认后，需要向服务端发送确认，设置首部 ACK 为 1，ack = y + 1，发送后进入 ESTABLISHED（连接建立）状态；</li><li>服务端收到客户端的确认，进入 ESTABLISHED 状态。</li></ul><h3 id="2-2-三次握手的原因"><a href="#2-2-三次握手的原因" class="headerlink" title="2.2 三次握手的原因"></a>2.2 三次握手的原因</h3><p>最常问到的一个问题是为什么使用三次握手，而不是两次或者四次呢？主要有两个原因。</p><h4 id="避免历史错误连接"><a href="#避免历史错误连接" class="headerlink" title="避免历史错误连接"></a>避免历史错误连接</h4><p>考虑采用两次握手，TCP 使用重传保证了可靠连接，考虑这种情况，客户端发送的 SYN 包 S1 阻塞在网络中，超时进行重传 S2，与服务端建立了连接。当释放连接之后，之前阻塞的 S1 到达了服务端，便会产生新的连接，并一直等待客户端发送数据，造成资源浪费，因此引入第三次确认。</p><p><img src="两次握手.png" alt="两次握手的问题"></p><h4 id="保证信息同步"><a href="#保证信息同步" class="headerlink" title="保证信息同步"></a>保证信息同步</h4><p>由于 TCP 协议依赖序列号等数据，而在一个不一定可靠的信道上，至少需要三次交换信息才能达到信息同步：</p><ul><li>1 次：A -&gt; B，A 不知道 B 是否进行了同步；</li><li>2 次：A -&gt; B，B -&gt; A，A 知道 B 同步了某个数据，但 B 无法确认 A 收到了这个同步；</li><li>3 次：A -&gt; B，B -&gt; A，A -&gt; B，双方完成了信息同步。</li></ul><blockquote><p>总结：两次握手无法避免历史错误连接，四次握手的通信次数过多，而三次握手是完成可靠通信的最优次数。</p></blockquote><h3 id="2-3-其他问题"><a href="#2-3-其他问题" class="headerlink" title="2.3 其他问题"></a>2.3 其他问题</h3><h4 id="SYN-洪泛攻击"><a href="#SYN-洪泛攻击" class="headerlink" title="SYN 洪泛攻击"></a>SYN 洪泛攻击</h4><p>在 Linux 中会维护两个队列来存储连接，一个是半连接 SYN 队列，存储完成了两次握手还没收到客户端 ack 的连接；另一个是全连接 Accept 队列， 存储已经完成三次握手的连接。</p><p>一个连接的在队列中的存储过程：</p><ul><li>服务端收到客户端的 SYN 报文，创建半连接资源，将该连接添加到 SYN 队列；</li><li>发送 SYN + ACK，等待客户端回应 ACK 报文；</li><li>服务端收到 ACK，将该连接移动到 Accept 队列；</li><li>应用调用 accept() 后，获取该连接。</li></ul><p><img src="连接处理.png" alt="连接处理"></p><p>但如果客户端恶意发送大量 SYN 报文，而不发送之后的 ACK 报文，将导致服务端分配大量半连接资源，导致资源消耗殆尽，称为 SYN 洪泛攻击。</p><p>一种有效的防御手段是使用 SYN cookie：</p><ul><li>在收到一个 SYN 报文后，不产生一个半连接，而是根据客户端的 IP 和端口，使用哈希算法生成一个初始序号 x，设置 seq = x 发送给客户端；</li><li>收到客户端的 ACK 报文后，会检验其中的 ack，合法的值应该为 x + 1。检验通过后会产生一个全连接；</li><li>如果未收到 ACK 报文，由于服务端并未分配资源，所以也没有危害。</li></ul><h4 id="握手过程丢失报文"><a href="#握手过程丢失报文" class="headerlink" title="握手过程丢失报文"></a>握手过程丢失报文</h4><p>第一次握手丢失：客户端发送 SYN 报文后，迟迟收不到服务端的 ACK，客户端将会触发超时重传，如果多次重传都失败（大概 1 分钟）后，将断开该连接。</p><p>第二次握手丢失：服务端收到了 SYN 报文，但发送的 ACK 报文丢失了。服务端未收到第三次确认，触发超时重传，客户端未收到 ACK，也会触发超时重传。当两者中任意一个达到重传上限，将断开连接。</p><p>第三次握手丢失：与上面类似，客户端将重传第三次握手 ACK 报文，服务端将重传第二次握手 ACK 报文，直到握手成功或者达到上限断开连接。</p><h2 id="3-连接释放"><a href="#3-连接释放" class="headerlink" title="3. 连接释放"></a>3. 连接释放</h2><h3 id="3-1-四次挥手"><a href="#3-1-四次挥手" class="headerlink" title="3.1 四次挥手"></a>3.1 四次挥手</h3><p>TCP 连接释放的过程如下：</p><p><img src="四次挥手.jpg" alt="TCP四次挥手"></p><ul><li>释放前 A 与 B 都处于 ESTABLISHED 状态，A 发送 FIN 为 1 的报文，即 FIN 报文，进入 FIN_WAIT_1（终止等待 1）状态；</li><li>服务端收到该报文后，发送应答报文，进入 CLOSED_WAIT（关闭等待）状态。此时 A -&gt; B 的传输结束，连接处于半关闭状态；</li><li>A 收到 B 的确认，进入 FIN_WAIT_2 状态；</li><li>B 发送完数据之后，也发送 FIN 报文，进入 LAST_ACK（最后确认）状态；</li><li>A 收到 FIN 报文，发送确认，进入 TIME_WAIT 状态；</li><li>B 收到 A 的报文，进入 CLOSED 状态，B 完成连接的关闭；</li><li>A 经过 2MSL 时间后，自动进入 CLOSED 状态，完成连接的关闭。</li></ul><p>上述过程每个方向都需要一个 FIN 和 ACK，需要交换 4 个报文段，称为四次挥手。并且主动关闭连接的一方，才有 TIME_WAIT 状态。</p><blockquote><p>客户端和服务端都可以是主动关闭方，为了描述方便，下文中的主动关闭方默认是客户端。</p></blockquote><h3 id="3-2-四次挥手的原因"><a href="#3-2-四次挥手的原因" class="headerlink" title="3.2 四次挥手的原因"></a>3.2 四次挥手的原因</h3><p>TCP 是全双工的协议，双方都具有收发能力，一个 FIN 和 ACK 标记一方的发送结束。</p><ul><li>客户端向服务端发送 FIN，仅表示客户端不再发送数据，进入半关闭状态；</li><li>收到 FIN 报文后，服务端仍能发送数据，当不再发送数据时，才发送 FIN 报文表示关闭全部连接。</li></ul><h3 id="3-3-引入-TIME-WAIT-状态的原因"><a href="#3-3-引入-TIME-WAIT-状态的原因" class="headerlink" title="3.3 引入 TIME_WAIT 状态的原因"></a>3.3 引入 TIME_WAIT 状态的原因</h3><h4 id="使旧连接的包失效"><a href="#使旧连接的包失效" class="headerlink" title="使旧连接的包失效"></a>使旧连接的包失效</h4><p>如果 TIME_WAIT 没有等待时间，被延迟的数据包到达后，如果相同端口的连接被复用了，可能导致数据错乱。</p><p><img src="数据错乱.png" alt="数据错乱"></p><p>因此，TCP 设置了足够长的时间，能够使旧连接的数据包都被丢弃，在网络中自然消失。</p><p>那么，足够长的时间是多久呢？TCP 采用了 2MSL，MSL 是 Maximum Segment Lifetime，报文最大生存时间，超过这个时间的报文将被丢弃。</p><p>而 2MSL 是当前连接所有包都能够被丢弃的时间。假如现在 A 发送 ACK 后，最坏情况下，这个 ACK 在 1MSL 时到达 B；此时 B 在收到这个 ACK 的前一刹那，一直在重传 FIN，这个 FIN 最坏会在 1MSL 时间内消失。因此从 A 发送 ACK 的那一刹那开始，等待 2MSL 可以保证 A 发送的最后一个 ACK，和 B 发送的最后一个 FIN 都在网络中消失。</p><h4 id="确保连接正常关闭"><a href="#确保连接正常关闭" class="headerlink" title="确保连接正常关闭"></a>确保连接正常关闭</h4><p>TIME_WAIT 的另一个作用是使客户端最后的 ACK 能被对方接收，确保连接正常关闭。如果没有 TIME_WAIT 状态，客户端发送最后一个 ACK 后，就会关闭连接，如果这个包在网络中丢失了， 服务端会一直处于 LAST_ACK 状态。而当客户端重新发起 SYN 请求连接时，服务端会当成错误处理，中止连接。</p><p><img src="连接未关闭.png" alt="连接未正常关闭"></p><p>而如果 TIME_WAIT 设置足够长的时间：</p><ul><li>服务端收到最后一个 ACK，则正常关闭连接；</li><li>服务端未收到最后一个 ACK，则重传 FIN 等待新的 ACK 报文。客户端收到 FIN 后会重传 ACK 报文并重新计时等待 2MSL。</li></ul><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><img src="TCP连接管理总结.png" alt="TCP连接管理总结"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/26960678/">计算机网络 谢希仁版</a></li><li><a href="https://book.douban.com/subject/30280001/">计算机网络 自顶向下方法</a></li><li><a href="https://www.cnblogs.com/xiaolincoding/archive/2020/04/05/12638546.html">35 张图解：被问千百遍的 TCP 三次握手和四次挥手面试题</a></li><li><a href="https://groups.google.com/g/pongba/c/kF6O7-MFxM0/m/5S7zIJ4yqKUJ?pli=1">TCP建立连接为什么是三次握手</a></li><li><p><a href="https://www.cnblogs.com/xiaolincoding/p/15131102.html">TCP才不傻</a></p></li><li><p><a href="https://www.zhihu.com/question/67013338/answer/248375813">为什么TCP4次挥手等待为2MSL</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TCP可靠传输与拥塞控制</title>
      <link href="/2022/02/20/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
      <url>/2022/02/20/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>传输控制协议 TCP（Transmission Control Proticol）是一种面向连接的、可靠的、基于字节流的通信协议，具有拥塞控制功能。在计算机网络 OSI 模型中，位于传输层。</p><blockquote><p>所谓连接，即双方维护了一组数据结构记录状态，并根据一个状态机进行状态转移或者相应的处理机制。</p><p>在同一层还有用户数据报协议 UDP（User Datagram Protocol），与 TCP 基本相反，UDP 无连接、不可靠、面向报文。但这不代表使用 UDP 就无法实现可靠传输，只要在上面的应用层精心设计，也能够达到可靠传输的效果，例如 Google 的 QUIC 协议。</p></blockquote><p>由于 TCP 非常复杂，在一文中介绍其全部特性是不太现实的，本文主要介绍可靠传输和拥塞控制两个特性。</p><p>首先需要关注一下 TCP 的头格式，如下所示。</p><p><img src="TCP头格式.png" alt="TCP头格式"></p><p>其中关于可靠传输和拥塞控制主要关注以下几个部分：</p><ul><li>Sequence Number：包的序号，用来解决网络包乱序问题。下文统一称作 seq；</li><li>Acknowledgement Number：确认收到的包序号，解决可靠传输问题。下文统一称作 ack；</li><li>Window：接收窗口，可以用于用于实现拥塞控制；</li><li>CheckSum：校验和，用来验证包数据的正确性。</li></ul><h2 id="2-可靠传输"><a href="#2-可靠传输" class="headerlink" title="2. 可靠传输"></a>2. 可靠传输</h2><p>TCP 的可靠传输依赖校验和、确认应答、重传多个机制共同实现。</p><h3 id="2-1-校验和"><a href="#2-1-校验和" class="headerlink" title="2.1 校验和"></a>2.1 校验和</h3><p>TCP 首部的校验和 CheckSum 是对 TCP 首部和数据共同计算的结果，在发送方生成，由接收方进行验证，校验不通过则会丢弃这个包，保证了 TCP 数据包在网络传输中的数据正确性。</p><h3 id="2-2-确认应答"><a href="#2-2-确认应答" class="headerlink" title="2.2 确认应答"></a>2.2 确认应答</h3><h4 id="2-2-1-停止等待协议"><a href="#2-2-1-停止等待协议" class="headerlink" title="2.2.1 停止等待协议"></a>2.2.1 停止等待协议</h4><p>TCP 是面向流的，其中 seq 表示包中的第一个数据字节的序号。当接收方收到包后，需要向接收方发送已经收到的数据字节序号 ack。例如发送方的包的 seq 为 1024，长度为 100（即 1024 - 1123），那么接收方收到这个包后，需要发送 ack = 1123 的确认，。</p><p>那么如何协调发送和确认呢？一个直观想法是发送方发送一个包后，需要等待这个包的确认，才能发送下一个包，这被称为停止等待协议。</p><p><img src="停止等待协议.png" alt="停止等待协议"></p><h4 id="2-2-2-滑动窗口"><a href="#2-2-2-滑动窗口" class="headerlink" title="2.2.2 滑动窗口"></a>2.2.2 滑动窗口</h4><p>上述方案是串行发送，网络利用率很低，于是引入了连续 ARQ 协议和滑动窗口。</p><p>滑动窗口是 TCP 协议的关键所在，发送方和接收方分别会维护一个发送窗户和接收窗口，窗口的单位是字节。下面以一个发送窗口举例：</p><blockquote><p>TCP 是双工的，即客户端和服务器可以为发送方和接收方，这里以单工的形式进行介绍，不影响对 TCP 的理解。</p></blockquote><p><img src="滑动窗口.png" alt="滑动窗口"></p><p>上图分为 4 个部分：</p><ul><li><code>#1</code> 是已收到 ack 确认的数据，无需再发送；</li><li><code>#2</code> 是还没收到 ack；</li><li><code>#3</code> 是在窗口中还没发送的，接收方还有空间接收；</li><li><code>#4</code> 是窗口以外的数据，接收方没有空间。</li></ul><p>其中 <code>#2</code> 和 <code>#3</code> 为发送窗口，连续 ARQ 协议规定，当发送方收到一个 ack 后，就把发送窗口往前滑动一个分组的位置，而接收方一般采用累计确认的方式，即对收到的最后一个分组进行确认，例如接收方收到 1023、1024、1026 - 1100 的数据，也只会对 1024 进行确认。</p><p>当发送方收到确认后，对窗口进行相应的移动。例如收到了 36 的 ack 后，就可以发送 46 - 51 的数据。</p><p><img src="arq.png" alt="连续ARQ协议示意"></p><h4 id="2-2-3-糊涂窗口综合症"><a href="#2-2-3-糊涂窗口综合症" class="headerlink" title="2.2.3 糊涂窗口综合症"></a>2.2.3 糊涂窗口综合症</h4><p>如果服务端（接收方）处理很慢，接收窗口不断缩小，那么发送方如何处理？根据上面的理论，当接收窗口大小为 0 时，发送方不会发送数据了。等到接收方处理完数据之后，腾出几个字节的窗口，发送方会立马发送这几个字节的数据。</p><p>这被称为糊涂窗口综合症，它的问题是 TCP 的首部需要 40 字节，却只携带了少量数据，类似可以坐上千人的高铁，却只坐了几个人，造成极大的资源浪费。</p><p>对于糊涂窗口综合症，一般有两个方案：</p><ul><li><p>接收方处理：采用 David D Clark’s 方案，在接收窗口很小时，直接给发送方回复接收窗口大小为 0，阻止发送数据，等待接收方处理了一部分数据之后再恢复发送；</p></li><li><p>发送方处理：采用 Nagle 算法，在未收到之前发送数据的 ack 时，即使发送窗口有剩余也不进行发送，而是积攒数据。</p><blockquote><p>Nagle 算法是默认打开的，如果程序需要较高的交互性，记得关闭这个算法。</p></blockquote></li></ul><h3 id="2-3-重传"><a href="#2-3-重传" class="headerlink" title="2.3 重传"></a>2.3 重传</h3><p>上述方案针对的理想的网络环境，如果发送的包或者确认的包在网络中丢失，为了保证可靠传输，就必须引入重传机制。常见的重传机制有：超时重传、快速重传、SACK。</p><h4 id="2-3-1-超时重传"><a href="#2-3-1-超时重传" class="headerlink" title="2.3.1 超时重传"></a>2.3.1 超时重传</h4><p>超时重传即发送数据时，设定一个计时器，超过指定时间仍没有收到 ack，则重发这个数据。</p><p><img src="超时重传.png" alt="超时重传"></p><blockquote><p>超时时间设定具体可看《计算机网络 谢希仁》 5.6.2 小节。</p></blockquote><h4 id="2-3-2-快速重传"><a href="#2-3-2-快速重传" class="headerlink" title="2.3.2 快速重传"></a>2.3.2 快速重传</h4><p>超时重传用时间驱动，每次都需要等待超时时间，周期较长，因此 TCP 引入了以数据驱动的快速重传机制。</p><p>快速重传当收到三个连续相同的 ack 之后，即使未超时，也会立即重传数据。</p><p><img src="快速重传.png" alt="快速重传"></p><h4 id="2-3-3-SACK"><a href="#2-3-3-SACK" class="headerlink" title="2.3.3 SACK"></a>2.3.3 SACK</h4><p>如果发送方发送了 1 - 100 的数据，其中 3 的数据丢失，即使引入了快速重传，接收方仍然只会对 2 进行确认，发送方需要发送 3 - 100 的数据。</p><p>一种更好方式是 SACK 机制，在 TCP 头部中会添加 SACK 字段，SACK 字段记录已经收到的数据，接收方根据 SACK 字段选择性的发送数据。</p><p><img src="sack.png" alt="SACK机制"></p><p>SACK 机制需要消耗发送方的资源，发送方收到 SACK 字段后，经过遍历才能确认需要发送的数据。SACK 机制默认打开，需要根据业务需要进行控制。 </p><h2 id="3-拥塞控制"><a href="#3-拥塞控制" class="headerlink" title="3. 拥塞控制"></a>3. 拥塞控制</h2><p>上文说到 TCP 使用了滑动窗口做了流量控制（根据发送窗口和接收窗口同时限制），但是不止于此，TCP 是个无私的协议，当拥塞发生时，会主动降低自己的发送速率。</p><p>发送方维护了一个拥塞窗口 cwnd，发送窗口会取 cwnd 和接收窗口的最小值。</p><p>在 1990 年 TCP Reno 之后，拥塞控制主要有 4 个算法：慢开始、拥塞避免、拥塞发生和快恢复。</p><h3 id="3-1-慢开始"><a href="#3-1-慢开始" class="headerlink" title="3.1 慢开始"></a>3.1 慢开始</h3><p>慢开始的思想是刚加入网络的连接，慢慢进行提速：</p><ul><li>初始化 cwnd = 1，发送报文 m1；</li><li>每收到一个 ack，cwnd 自增。例如收到 m1的 ack，则 cwnd = 2，可以发送 m2 和 m3；当收到 m2 和 m3 的 ack 之后，cwnd = 4；下一轮收到 m4 - m7 的 ack 后，cwnd = 8。</li><li>每经过一个传输轮次，cwnd = cwnd * 2，指数上升；</li><li>到达 ssthresh（slow start threshold），进行拥塞避免。</li></ul><p><img src="慢启动.png" alt="慢启动"></p><h3 id="3-2-拥塞避免"><a href="#3-2-拥塞避免" class="headerlink" title="3.2 拥塞避免"></a>3.2 拥塞避免</h3><p>当 cwnd &gt;= ssthresh 之后，就会进入拥塞避免算法，ssthresh 一般为 65535 字节。</p><p>拥塞避免的规则是：收到一个 ack，cwnd 增加 1/cwnd，即每经过一个传输轮次，cwnd = cwnd + 1，变为线性增长。</p><p><img src="拥塞避免.png" alt="拥塞避免"></p><h3 id="3-3-拥塞发生"><a href="#3-3-拥塞发生" class="headerlink" title="3.3 拥塞发生"></a>3.3 拥塞发生</h3><p>拥塞发生算法即在发生拥塞时，降低发送速率。</p><p>当网络出现拥塞之后，就会出现分组丢失，进而触发重传。也就是说，出现重传是网络拥塞的特征。上文提到，重传包括超时重传和快速重传，拥塞发生算法对两种重传的处理机制有所不同：</p><ul><li><p>超时重传：触发了超时，证明网络拥塞已经很严重了。此时会设置 ssthresh = cwnd / 2，cwnd = 1，随后采用慢启动算法。</p><p><img src="超时重传拥塞发生.png" alt="拥塞发生算法-超时重传"></p></li><li><p>快速重传：还能收到 ack，网络情况比超时重传的时候好，可以采用比较温和的方式。此时会设置 cwnd = cwnd / 2，ssthresh = cwnd，进行快恢复算法。</p></li></ul><h3 id="3-4-快恢复算法"><a href="#3-4-快恢复算法" class="headerlink" title="3.4 快恢复算法"></a>3.4 快恢复算法</h3><p>快恢复算法一般配合快速重传使用，其算法如下：</p><ul><li>cwnd = ssthresh + 3（收到了 3 个 ACK，证明 3 个数据包都被收到了）；</li><li>重传丢失的数据包，执行拥塞避免算法。</li></ul><p><img src="快恢复.png" alt="快恢复"></p><h3 id="3-5-其他拥塞控制算法"><a href="#3-5-其他拥塞控制算法" class="headerlink" title="3.5 其他拥塞控制算法"></a>3.5 其他拥塞控制算法</h3><p>上面已经介绍 TCP Reno 的 4 个机制，但 Reno 毕竟是 1990 年的产物了，在随后的发展中产生了 BIC 和 CUBIC 算法，具体可见 <a href="https://zhuanlan.zhihu.com/p/366392032">深入理解TCP拥塞控制——从BIC到CUBIC</a>。</p><blockquote><p>linux 2.6.8 默认使用 BIC，BIC 的思想是使用二分查找去搜索合适的 cwnd。</p><p>linux 2.6.19 默认使用 CUBIC，用公式了摆脱了对 RTT 的依赖。</p></blockquote><p>上面介绍的拥塞控制算法都是基于分组丢失来控制 cwnd 的大小，而简单而粗暴地将窗口大小的数据全部突发出去，这往往会造成路由器的排队。</p><p>linux 4.9 中引入了 BBR 算法，BBR 是 Google 在 2016年发布的拥塞算法，BBR 在计算 cwnd 的同时，还会计算数据的发送时间间隔，具体可见 <a href="https://dl.acm.org/doi/fullHtml/10.1145/3009824">BBR:Congestion-Based Congestion Control</a>。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p><img src="总结.png" alt="总结"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">Transmission_Control_Protocol Wikipedia</a></li><li><p><a href="https://nmap.org/book/tcpip-ref.html">TCP/IP Reference</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/133307545?utm_source=zhihu&amp;utm_medium=social&amp;utm_oi=746445333860450304">30张图解： TCP 重传、滑动窗口、流量控制、拥塞控制</a></p></li><li><a href="https://coolshell.cn/articles/11564.html">TCP的那些事儿</a></li><li><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">The TCP/IP Guide</a></li><li><a href="https://book.douban.com/subject/26960678/">计算机网络</a></li><li><a href="https://book.douban.com/subject/1088054/">TCP/IP详解 卷1：协议</a></li><li><p><a href="https://zhuanlan.zhihu.com/p/366392032">深入理解TCP拥塞控制——从BIC到CUBIC</a></p></li><li><p><a href="https://dl.acm.org/doi/fullHtml/10.1145/3009824">BBR:Congestion-Based Congestion Control</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP发展史</title>
      <link href="/2022/02/17/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/"/>
      <url>/2022/02/17/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/</url>
      
        <content type="html"><![CDATA[<p>HTTP 基于 TCP 协议，默认端口是 80，HTTP 是 Web 世界中的基础协议，是现如今 Web 开发的必备知识，它也经历了多个版本的发展。</p><p>本文将介绍 HTTP 协议的发展历史。</p><h2 id="1-HTTP-0-9"><a href="#1-HTTP-0-9" class="headerlink" title="1. HTTP/0.9"></a>1. HTTP/0.9</h2><p>HTTP/0.9 在 1991 年发布，协议内容非常简单，没有请求头，只支持 <code>GET</code> 命令，然后没了。</p><h2 id="2-HTTP-1-0"><a href="#2-HTTP-1-0" class="headerlink" title="2. HTTP/1.0"></a>2. HTTP/1.0</h2><p>1996 年，HTTP/1.0 发布，拓展了不少功能：</p><ul><li>除了 <code>GET</code> 命令外，引入了 <code>POST</code> 和 <code>HEAD</code> 命令；</li><li>添加了 HTTP header，请求和响应都有 header 了，并且在请求 header 中指明了 HTTP 版本；</li><li>添加了状态码，例如 200，404 等；</li><li>可以传输图像、视频等，使用 <code>Content-Type</code> 指明文件类型。</li></ul><p>HTTP/1.0 极大拓展了 Web 世界的丰富程度，但也有一个主要缺点：每个 TCP 连接都只能发送一个请求。TCP 的连接需要三次握手，每次 HTTP 请求都得建立一个连接，速度较慢。除此之外，请求是串行的，每个请求必须等待上一个请求完成才可以发送。</p><p>为了解决 HTTP 短连接的问题，当时有些浏览器在请求时，会添加一个非标准的字段：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br></pre></td></tr></table></figure><p>这个字段要求服务器不关闭 TCP 连接，以便请求复用，服务端同样会在响应中添加这个字段。</p><h2 id="3-HTTP-1-1"><a href="#3-HTTP-1-1" class="headerlink" title="3. HTTP/1.1"></a>3. HTTP/1.1</h2><p>1997 年，HTTP/1.1 发布，主要解决 HTTP/1.0 的网络性能问题，并增加一些新特性：</p><ul><li>默认采用了长连接，减少 TCP 三次握手的开销。当需要关闭时，添加字段 <code>Connection: close</code>；</li><li>引入了管道（pipeling）机制，在同一个 TCP 连接里，客户端可以发送多个请求。例如需要发送 A 和 B 两个请求，HTTP/1.0 中会先发送 A 请求，收到回应之后再发送 B 请求。在 HTTP/1.1 中，允许客户端同时发出 A 和 B 请求，但服务端仍根据请求顺序进行处理，即客户端并行，服务端串行；</li><li>增加了 <code>PUT</code>、<code>PATCH</code>、<code>OPTIONS</code>、<code>DELETE</code> 命令；</li><li>添加了 <code>HOST</code> 字段，指定服务器的域名；</li></ul><p>虽然 HTTP/1.1 维持了长连接和引入了管道机制，提升了网络性能，但仍存在性能瓶颈：服务器按照请求的顺序进行响应的，处理完一个才会处理下一个，如果服务端响应慢，会导致客户端请求不到数据，这被称为队头阻塞问题。</p><h2 id="4-HTTP-2"><a href="#4-HTTP-2" class="headerlink" title="4. HTTP/2"></a>4. HTTP/2</h2><p>Google 开源了自行研发的 SPDY 协议，主要解决 HTTP/1.1 的性能问题，在 SPDY 的基础上，HTTP/2 在 2015 年发布。</p><p>HTTP/2 采用了 TLS，可以保证安全传输，除此之外，其主要特性有 多工、二进制协议、头部压缩、数据流和服务端推送。</p><p><img src="http2.png" alt="HTTP/2"></p><h4 id="多工"><a href="#多工" class="headerlink" title="多工"></a>多工</h4><p>在一个 TCP 连接里，客户端和服务端可以同时发送多个请求或回应，而且不用按照顺序一一对应，可以解决队头阻塞问题，这被称为多工，也称多路复用。</p><p><img src="多工.png" alt="多路复用"></p><h4 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h4><p>HTTP/1.1 的 header 是文本，body 可以是文本或者二进制，而 HTTP/2 是彻底的二进制协议，header 和 body 都为二进制，称为头信息帧和数据帧。</p><p><img src="二进制协议.png" alt="二进制协议"></p><h4 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h4><p>如果发送多个请求，它们的头是一样或者类似的，协议会通过 HPACK 算法消除重复的部分。</p><p>HPACK 算法的思想是在客户端和服务器维护一张头信息表，所有的字段都会存在这张表中，相同的字段在后续不发送完整信息，而是发送表中的索引。</p><h4 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h4><p>由于采用了多工，同一个连接里面连续的数据包，可能属于不同的响应，需要对数据包进行标记和区分。</p><p>HTTP/2 将每个请求或响应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号，发送数据包时，必须携带数据流的编号。</p><p><img src="数据流.png" alt="数据流"></p><h4 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h4><p>服务端推送允许服务端未经请求，主动向客户端发送数据。</p><p>例如客户端请求 index.html，服务端在响应这个请求时，可以主动推送 main.js 文件到客户端的缓存，当客户端需要 main.js 时，从缓存中获取即可，不需要发送请求。</p><h4 id="HTTP-2-的不足"><a href="#HTTP-2-的不足" class="headerlink" title="HTTP/2 的不足"></a>HTTP/2 的不足</h4><p>HTTP/2 为了解决队头阻塞问题，引入了多工，多个 HTTP 请求在复用一个 TCP 连接，而这些对于 TCP 而言是无感知的。由于 TCP 的重传机制，如果发生丢包，所有的 HTTP 请求都需要等待这个包被重传，即使这个包不属于我这个 HTTP 请求。</p><h2 id="5-HTTP-3"><a href="#5-HTTP-3" class="headerlink" title="5. HTTP/3"></a>5. HTTP/3</h2><p>HTTP/2 的重传问题使用 TCP 是无解的，但是 UDP 可以，于是 HTTP/3 将底层的 TCP 协议改为基于 UDP 的 QUIC 协议。</p><p>QUIC 是 Google 设计的基于 UDP 的可靠协议，拥有以下特点：</p><ul><li>无队头阻塞。QUIC 也采用了数据流，流之间相互独立，由于 UDP 没有重传机制，即使发送丢包，只会阻塞包对应的流；</li><li>建立连接速度快。HTTPS 建立一个连接，需要 6 次交互，而 QUIC 将其合并到 3 次；</li><li>连接迁移。QUIC 取消了（源地址，源端口，目标地址，目标端口）的四元组，而是采用 connection id 来标识一个连接，只要保留上下文，即使网络发生变化，也可以复用该连接。例如设备从 4G 切换到 WIFI，连接不会中断。</li></ul><p>HTTP/3 采用 QPACK 替换 HPACK 实现头部压缩，目前看来，HTTP/3 主要涉及底层协议改造，在业务逻辑层面并没有太大变化。但也因为改动了底层协议，HTTP/3 的普及还是一个较为长久的过程。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p><img src="总结.png" alt="总结导图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2016/08/http.html">HTTP协议入门</a></li><li><a href="https://coolshell.cn/articles/19840.html">HTTP的前世今生</a></li><li><a href="https://blog.csdn.net/qq_36894974/article/details/120037166">再过5分钟，你就懂HTTP 2.0了</a></li><li><a href="https://blog.csdn.net/qq_34827674/article/details/115188998">HTTP/3 强势来袭</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTPS的加密原理</title>
      <link href="/2022/02/17/https%E7%9A%84%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/"/>
      <url>/2022/02/17/https%E7%9A%84%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>HTTP 协议在 web 世界得到广泛使用，但由于采用明文传输，会存在以下问题：</p><ul><li>通信的内容可能会被窃听，可能会泄露用户的信息；</li><li>无法验证通信方的身份，可能遭遇伪装的服务器；</li><li>无法验证报文是否遭遇篡改。</li></ul><p>因此，在高可靠性的场合，例如银行登录、转账等，都会采用安全的 HTTPS 协议。HTTPS 其实是将HTTP 的通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已，默认端口是 443。</p><blockquote><p>SSL 是由 Netspace 公司设计的，3.0 版本得到大规模使用。后来互联网标准化组织 ISOC 接替 Netspace，发布了 SSL 的升级版 TLS 1.0（设计上与 SSL 3.0 几乎没有区别，TLS 1.0 通常被标示为 SSL 3.1），并在后续分别推出 TLS 1.1、TLS 1.2 和 TLS 1.3。</p></blockquote><p>HTTP 直接和 TCP 通信，HTTPS 先与 SSL 通信，再由 SSL 和 TCP 通信。</p><p><img src="ssl.png" alt="HTTPS和SSL"></p><h2 id="2-密码学基础"><a href="#2-密码学基础" class="headerlink" title="2. 密码学基础"></a>2. 密码学基础</h2><p>在了解 HTTPS 的加密原理之前，需要先介绍一点密码学基础。</p><h3 id="2-1-对称加密"><a href="#2-1-对称加密" class="headerlink" title="2.1 对称加密"></a>2.1 对称加密</h3><p>密码学中有以下几个基础概念：</p><ul><li>明文：原始数据，一般是有意义的字符和数据，例如用户密码</li><li>密文：对明文进行加密便成为了密文</li><li>加密：将明文转换为密文的变换过程</li><li>解密：将密文恢复为明文</li></ul><p>对称加密指的是加密和解密用的密钥是相同的，类似日常生活中的钥匙。</p><p><img src="对称加密.png" alt="对称加密"></p><h3 id="2-2-非对称加密"><a href="#2-2-非对称加密" class="headerlink" title="2.2 非对称加密"></a>2.2 非对称加密</h3><p>非对称加密也称公钥加密，有两把密钥：公钥和私钥，顾名思义，公钥是公开给所有人的，而私钥是自己持有的。用公钥加密的内容只有私钥才能解开，私钥加密的内容只有公钥才能解开。</p><p><img src="非对称加密.png" alt="非对称加密"></p><h2 id="3-加密分析"><a href="#3-加密分析" class="headerlink" title="3. 加密分析"></a>3. 加密分析</h2><p>接下来将对各种加密方式进行分析，并推导出 SSL 的加密方式。</p><h3 id="3-1-使用对称加密"><a href="#3-1-使用对称加密" class="headerlink" title="3.1 使用对称加密"></a>3.1 使用对称加密</h3><p>如果通信双方持有相同的密钥，并且密钥没有泄露，那么通信安全是可以保证的。</p><p>遗憾的是防止密钥泄露是很困难的。如果由服务器生成密钥传输给浏览器，中间的传输过程密钥可能被劫持，那么劫持者可以使用密钥解密双方的传输内容，这么做显然不可行。</p><p><img src="对称加密的问题.png" alt="中间人劫持"></p><h3 id="3-2-使用非对称加密"><a href="#3-2-使用非对称加密" class="headerlink" title="3.2 使用非对称加密"></a>3.2 使用非对称加密</h3><p>使用对称加密是无法保证安全的，需要采用非对称加密。一个直观想法是服务器保留一组公钥和私钥，服务器先把公钥以明文方式传输给浏览器， 浏览器传给服务器的数据都用这个公钥加密，那么浏览器到服务器的数据就是安全的，但服务器发送公钥的过程仍可能会被劫持，劫持者可以通过公钥解密服务器传给浏览器的数据了，只能保证单向传输的安全。</p><p>如果浏览器也维护一组公钥和私钥，就能解决上面的问题了：</p><ul><li>服务器拥有公钥 A 和 私钥 A‘，浏览器拥有公钥 B 和私钥 B’；</li><li>浏览器把 B 传输给服务器，服务器把 A 传输给浏览器；</li><li>浏览器向服务器发送的数据使用 A 加密，服务器使用 A’ 解密，保证了浏览器到服务器的数据安全；</li><li>服务器向浏览器的数据使用 B 加密，浏览器使用 B’ 解密，保证了服务器到浏览器的数据安全。</li></ul><p><img src="可行的非对称加密.png" alt="可行的非对称加密"></p><p>抛开一个漏洞（中间人攻击，下文将进行介绍）不谈，使用两组公钥和私钥是能实现安全传输的，但是非对称加密非常耗时，会大幅度增加通信延时。</p><h3 id="3-3-非对称加密-对称加密"><a href="#3-3-非对称加密-对称加密" class="headerlink" title="3.3 非对称加密+对称加密"></a>3.3 非对称加密+对称加密</h3><p>非对称加密耗时严重，需要尽量减少，可以组合非对称加密和对称加密：</p><ul><li>服务器拥有公钥 A 和 私钥 A‘；</li><li>浏览器向服务器发送请求，服务器把公钥 A 明文传给浏览器；</li><li>浏览器生成一个对称加密的密钥 X，用公钥 A 加密后传给服务器；</li><li>服务器使用私钥 A’ 解密出 X；</li><li>双方使用 X 进行对称加密传输。</li></ul><p><img src="混合加密.png" alt="混合加密"></p><p>上面的过程只有一次非对称加密，并解决了安全问题，HTTPS 基本采用了这种思路，但仍存在漏洞，那就是中间人攻击。</p><h3 id="3-4-CA证书"><a href="#3-4-CA证书" class="headerlink" title="3.4 CA证书"></a>3.4 CA证书</h3><h4 id="3-4-1-中间人攻击"><a href="#3-4-1-中间人攻击" class="headerlink" title="3.4.1 中间人攻击"></a>3.4.1 中间人攻击</h4><p><img src="中间人攻击.png" alt="中间人攻击"></p><p>中间人攻击指中间人掉包了服务器的公钥，进而得到了对称加密的密钥：</p><ul><li>服务器向浏览器发送公钥 A 的过程中，中间人劫持并保存 A，替换成自己的公钥 B 发送给浏览器；</li><li>浏览器生成对称加密的密钥 X，并使用 B 加密发送给服务器；</li><li>中间人劫持后，解密得到 X，再用 A 加密发送给服务器。中间人可以得到浏览器和服务器中传输的所有数据。</li></ul><h4 id="3-4-2-CA证书"><a href="#3-4-2-CA证书" class="headerlink" title="3.4.2 CA证书"></a>3.4.2 CA证书</h4><p>上述问题的根本原因是浏览器无法确认收到的公钥是不是网站自己的，解决方案是 CA 机构颁布的证书。网站使用 HTTPS 时，需要向 CA 机构申请一份数字证书，证书中包含网站的信息和公钥。</p><p>为了防止证书被篡改，数字证书采用了数字签名，生成过程如下：</p><ul><li>CA 机构拥有非对称加密的公钥和私钥；</li><li>CA 对证书明文进行哈希，再对哈希值用私钥加密，得到数字签名。</li></ul><p>浏览器拿到服务器发送的证书之后，进行如下验证：</p><ul><li>得到明文和数字签名，使用 CA 机构的公钥（保存在浏览器）对数字签名解密，得到哈希 H；</li><li>用证书中的哈希算法对明文进行哈希，得到 H’；</li><li>H = H‘，则证书可信。</li></ul><p><img src="数字签名.png" alt="数字签名"></p><p>综上，便可以使用对称加密 + 非对称加密 + CA 证书实现安全又比较高效的通信了，这也是 HTTPS 真正采用的方式。</p><blockquote><p>既然 HTTPS 安全可靠，为什么所有的网站不都用 HTTPS呢？一方面是虽然混合加密减少了计算量，但 HTTPS 仍比 HTTP 慢很多，可以达到 2 - 100 倍；另一方面，证书的费用是一笔不小的开销。 </p></blockquote><p><img src="安全传输.png" alt="HTTPS安全传输"></p><h2 id="4-SSL连接过程"><a href="#4-SSL连接过程" class="headerlink" title="4. SSL连接过程"></a>4. SSL连接过程</h2><p>上文已经介绍了 HTTPS 的加密原理，加下来将介绍 SSL 的连接过程，如下图所示：</p><p><img src="连接过程.png" alt="SSL连接过程"></p><ul><li>步骤 1：客户端发送 Client Hello 报文开始 SSL 通信，报文中包含支持的 SSL 版本、加密算法和一个随机字符串 client random；</li><li>步骤 2：服务端应答 Server Hello 报文，报文中也包含支持的 SSL 版本、加密算法（从 Client Hello 报文中筛选的）和一个随机字符串 server random；</li><li>步骤 3：服务端发送 Certificate 报文，包含数字证书（公钥+电子签名）；</li><li>步骤 4：服务端发送 Server Hello Done，最初的握手协商结束；</li><li>步骤 5：客户端验证数字签名后，生成密钥 premaster secret，并用公钥加密，发送 Client Key Exchange 报文；</li><li>步骤 6：客户端继续发送 Change Cipher Spec 报文，提醒服务端之后的通信都会采用对称加密；</li><li>步骤 7：客户端和服务器根据 client random、server random、 premaster secret 三个字符串和加密算法生成对称加密的密钥。客户端发送对称加密后的 Finished 报文，此次握手协商能否成功，取决于服务端能否解密这个报文；</li><li>步骤 8：服务器同样发送 Change Cipher Spec 报文；</li><li>步骤 9：服务器同样发送 Finished 报文；</li><li>步骤 10：SSL 连接建立，可以发送数据报文。</li></ul><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>本文介绍了 HTTP 协议存在的问题，引出 HTTPS 协议，HTTPS 可以看成 HTTP 和 SSL/TLS 的组合。从密码学的基础出发，介绍了对称加密、非对称加密、混合加密三种方案，对称加密无法实现安全通信，非对称加密耗时严重，混合加密综合了两者的优势。对于都存在的中间人攻击问题，引入 CA 证书进行验证，最后介绍了 SSL 连接建立的过程。</p><p><img src="总结.png" alt="总结导图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/25863515/">图解HTTP</a></li><li><a href="http://www.ruanyifeng.com/blog/2014/02/ssl_tls.html">SSL/TLS协议运行机制的概述</a></li><li><p><a href="https://blog.csdn.net/qq_36894974/article/details/104856083">看完这篇 HTTPS，和面试官扯皮就没问题了</a></p></li><li><p><a href="https://sectigostore.com/blog/types-of-encryption-what-to-know-about-symmetric-vs-asymmetric-encryption/">Types of Encryption: What to Know About Symmetric vs Asymmetric Encryption</a></p></li><li><a href="https://zhuanlan.zhihu.com/p/43789231">彻底搞懂HTTPS的加密原理</a></li><li><a href="https://blog.pradeo.com/man-in-the-middle-attack">What is a man in the middle attack</a></li><li><a href="https://segmentfault.com/a/1190000021559557">HTTPS详解二： SSL/TLS工作原理和详细握手过程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>死锁和处理死锁</title>
      <link href="/2022/02/16/%E6%AD%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D/"/>
      <url>/2022/02/16/%E6%AD%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-死锁"><a href="#1-死锁" class="headerlink" title="1. 死锁"></a>1. 死锁</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>死锁的定义是：如果一个进程/线程集合中的每个进程/线程都在等待只能由该集合中其他进程/线程才能引发的事件，那么该集合是死锁的。</p><p>在大多数情况下，这个事件是释放占用的资源，换句话说，死锁就是进程/线程集合中的每个进程/线程都在等待被占用的资源，都不能被唤醒运行。</p><p>很容易用 java 实现死锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程A获得资源A, 等待资源B&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程A获得资源B&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;线程B获得资源B, 等待资源A&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;线程B获得资源A&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">线程A获得资源A, 等待资源B</span><br><span class="line">线程B获得资源B, 等待资源A</span><br></pre></td></tr></table></figure><h3 id="1-2-死锁条件"><a href="#1-2-死锁条件" class="headerlink" title="1.2 死锁条件"></a>1.2 死锁条件</h3><p>计算机科学家们总结了死锁的 4 个必要条件：</p><ul><li>互斥条件：资源只能被分配给一个进程/线程；</li><li>占用和等待：已经得到某个资源后，该进程/线程可以再请求其他资源；</li><li>不可抢占：资源只能自愿释放；</li><li>环路等待：系统中有两个或两个以上的进程/线程组成环路，该环路上的每个进程/线程都在等待下一个进程/线程占用的资源。</li></ul><p><img src="互斥条件.png" alt="互斥条件"></p><p><img src="环路等待.png" alt="环路等待"></p><h2 id="2-解决死锁"><a href="#2-解决死锁" class="headerlink" title="2. 解决死锁"></a>2. 解决死锁</h2><p>对于死锁，通常有 4 种处理策略：</p><ul><li>忽略</li><li>检测并恢复</li><li>死锁避免</li><li>死锁预防</li></ul><h3 id="2-1-忽略"><a href="#2-1-忽略" class="headerlink" title="2.1 忽略"></a>2.1 忽略</h3><p>最简单的解决方案是鸵鸟算法，把头埋到沙子里，假装根本没有问题发生，即忽略死锁问题。</p><p>对于数学家而言，这种方案往往无法接受，但对于工程师而言，如果死锁出现的概率很低，或者很长时间才会出现一次，并且能用重启的方式解决该问题， 那么完全可以忽略不管。</p><blockquote><p>实际上，由于忽略死锁的代价最小，虽然对解决死锁问题没有任何帮助，但却是最广泛使用的手段。通用操作系统例如 Windows 和 Linux 都忽略了死锁。</p></blockquote><h3 id="2-2-检测和恢复"><a href="#2-2-检测和恢复" class="headerlink" title="2.2 检测和恢复"></a>2.2 检测和恢复</h3><p>死锁检测和恢复并不阻止死锁的发生，而是当检测到死锁发生后，采取措施进行恢复。</p><h4 id="2-2-1-死锁检测"><a href="#2-2-1-死锁检测" class="headerlink" title="2.2.1 死锁检测"></a>2.2.1 死锁检测</h4><p>假设每个类型只有一个资源，那么我们就可以构造一个资源分配图，例如 A 进程持有 R 资源，且需要 S 资源，那么图中便有 R -&gt; A 和 A-&gt; S 的路径，那么死锁检测便转化为了判断图中是否存在环，可以采用深度优先搜索、拓扑排序等算法进行判断。</p><p><img src="资源图.png" alt="alt"></p><p>图 (a) 即为系统中的资源分配图，而图 (b) 展示了图中存在的环，此时系统发生了死锁。</p><blockquote><p>对于多种相同资源的死锁检测，需要基于矩阵和向量判断，感兴趣的读者可以阅读《现代操作系统》6.4.2 小节。</p></blockquote><p>那么何时检测死锁呢？一种方案是每次资源分配就进行检测，优点是检测及时，但显然会极大增加资源分配的时间；另一种方案是固定时间间隔或者等 CPU 的使用率降到一定阈值进行检测。</p><h4 id="2-2-2-死锁恢复"><a href="#2-2-2-死锁恢复" class="headerlink" title="2.2.2 死锁恢复"></a>2.2.2 死锁恢复</h4><p>死锁恢复通常有两个手段：</p><ul><li>杀死环中的进程：如果幸运的话，杀死环中的一个进程，其他进程就可以运行了。如果行不通的话，则继续杀死进程直到死锁被打破；</li><li>回滚：周期性的设置检查点，在检查点中保存进程的状态，包括资源状态和资源分配情况。当发生死锁时，恢复到上一个检查点运行，遗憾的是，这个检查点之后的工作将全部失去。</li></ul><h3 id="2-3-死锁避免"><a href="#2-3-死锁避免" class="headerlink" title="2.3 死锁避免"></a>2.3 死锁避免</h3><p>死锁避免的常用算法是银行家算法，由 Dijkstra 提出。该模型基于一个小镇的银行家，向客户分别承诺了一定贷款额度，当每个客户发起贷款请求时，需要判断该请求是否会进入不安全状态，如果是便拒绝该请求。那么什么是安全状态呢？假设 4 个客户 A、B、C、D，分别的贷款额度是 6、5、4、7，银行家只保留 10 的资源，针对下图三种情况进行分析：</p><p><img src="安全状态.png" alt="安全状态和非安全状态"></p><ul><li>(a) 中所有贷款都未被分配，是安全状态；</li><li>(b) 中银行家可以拖延 C 以外的贷款请求，让 C 先完成，等到 C 还贷后得到 4 个单位资源，可以继续给 B 或者 D 分配所需的贷款，因此该状态是安全的；</li><li>(c) 中银行家无法满足任何一个客户的最大贷款，因此该状态是不安全的。</li></ul><p>将上述的银行家比作操作系统，客户比作进程，贷款比作资源，那么银行家算法就可以避免进程的死锁。</p><blockquote><p>上述举例针对的是单个资源的情况，银行家算法可以推广处理多个资源，在 《现代操作系统》6.5.4 小节进行了介绍。</p></blockquote><h3 id="2-4-死锁预防"><a href="#2-4-死锁预防" class="headerlink" title="2.4 死锁预防"></a>2.4 死锁预防</h3><p>死锁预防思想是破坏死锁的 4 个必要条件中的任意一个。</p><h4 id="破坏互斥条件"><a href="#破坏互斥条件" class="headerlink" title="破坏互斥条件"></a>破坏互斥条件</h4><p>如果资源不被一个进程独占，那么死锁便不会发生，但锁之类的资源从语意上就是互斥的，对于这类资源这个方案无法执行。</p><h4 id="破坏占用和等待"><a href="#破坏占用和等待" class="headerlink" title="破坏占用和等待"></a>破坏占用和等待</h4><p>只要禁止持有资源的进程进行等待便可以消除死锁，一个方法是规定所有进程再执行前获取所有的资源，但这个方案有以下问题：</p><ul><li>很多进程直到运行时才知道需要的资源，无法提前分配；</li><li>大量资源被一个进程持有但不使用，造成浪费。</li></ul><h4 id="破坏不可抢占"><a href="#破坏不可抢占" class="headerlink" title="破坏不可抢占"></a>破坏不可抢占</h4><p>大量的资源被设计为不可抢占的，无法进行破坏。</p><h4 id="破坏环路等待"><a href="#破坏环路等待" class="headerlink" title="破坏环路等待"></a>破坏环路等待</h4><p>对资源类型进行排序，资源申请必须按序进行，不会出现环路等待，缺点是仍然造成资源浪费。</p><h2 id="3-其他问题"><a href="#3-其他问题" class="headerlink" title="3. 其他问题"></a>3. 其他问题</h2><h3 id="3-1-两阶段加锁"><a href="#3-1-两阶段加锁" class="headerlink" title="3.1 两阶段加锁"></a>3.1 两阶段加锁</h3><p>在数据库中，一个经常的操作是请求锁住一些记录，然后更新所有锁住的记录，当同时有多个进程运行时，就有死锁的危险。</p><p>常用的方法是两阶段加锁，第一阶段对所需的记录进行加锁，加锁成功才进入第二阶段更新，更新完成后释放所有的锁。</p><blockquote><p>例如 MySQL InnoDB 中的行锁，在事务中第一次更改数据时进行加锁，等到事务结束才会释放所有的锁。</p></blockquote><h3 id="3-2-通信死锁"><a href="#3-2-通信死锁" class="headerlink" title="3.2 通信死锁"></a>3.2 通信死锁</h3><p>上述的死锁都是针对资源而言，但资源死锁只是最普遍的一种，但不是唯一的一种。另一种死锁发生在网络中，一个普遍情形是进程 A 向进程 B 中发送数据，然后阻塞直到 B 回复，假设消息丢失，A 将阻塞等待 B 的回复，B 将阻塞等待 A 的数据，于是发生了死锁。</p><p>TCP 通过超时重传解决了上述问题。</p><h3 id="3-3-活锁"><a href="#3-3-活锁" class="headerlink" title="3.3 活锁"></a>3.3 活锁</h3><p>在某些场景下，进程通过轮询获取资源，获取失败不会挂起，而是重新尝试。假设进程 A 和进程 B 都需要两个资源 1 和 2，并且都是通过轮询去获取资源，如果 A 先运行获得资源 1，然后 B 获得资源 2，并通过轮询去获取对方的资源。</p><p>结果是两个进程都不会阻塞，但是会不断消耗 CPU 分给它们的时间片，没有任何进展，从现象上看好像死锁发生了。这个现象被称为活锁。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>上面介绍了死锁的产生条件和解决手段，不幸的是，解决死锁更多是学术上的研究，这些解决手段或多或少都存在一定问题，在实际中很少使用。实际开发还是需要程序员精心设计程序，减少死锁的发生，或在死锁发生时运用工具分析解决，在 Java 中可以使用 jconsole 或者 VisualVM 进行排查。</p><p><img src="总结.png" alt="总结导图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Deadlock">Deadlock wikipedia</a></li><li><a href="https://book.douban.com/subject/27096665/">现代操作系统</a></li><li><a href="https://zhuanlan.zhihu.com/p/361475700">小林coding 面试官：什么是死锁？</a></li><li><a href="https://www.bilibili.com/video/BV1iW411Y73K?p=35">哈尔滨工业大学 操作系统</a></li><li><a href="https://time.geekbang.org/column/article/70215">MySQL实战45讲 行锁功过</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(6) 生产者消费者模型</title>
      <link href="/2022/02/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(6)%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/02/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(6)%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是多线程同步问题的一个经典案例。</p><p>该问题描述了共享固定大小缓冲区的两个角色——即所谓的“生产者”和“消费者”。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p><img src="生产者消费者问题.png" alt="生产者消费者问题"></p><p>生产者消费者问题经常出现 Java 面试之中，一般有以下写法。</p><h2 id="2-使用wait和notify"><a href="#2-使用wait和notify" class="headerlink" title="2. 使用wait和notify"></a>2. 使用wait和notify</h2><p>这是最简单的实现，缓冲区满和空都调用 <code>wait</code> 方法等待，当生产或者消费了一个产品，则使用 <code>notfityAll</code> 唤醒所有的生产者/消费者。</p><p>注意：<code>wait</code> 和 <code>notify</code> 需要和 <code>synchronized</code> 配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟生产耗时</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() &gt;= CAPACITY) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟消费</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者消费，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Producer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用可重入锁ReentrantLock"><a href="#3-使用可重入锁ReentrantLock" class="headerlink" title="3. 使用可重入锁ReentrantLock"></a>3. 使用可重入锁ReentrantLock</h2><p><code>java.util.ReentrantLock</code> 配合 <code>Condition</code> 可以实现跟 <code>synchronized</code> 和 <code>wait</code> 类似的效果。</p><p><code>await</code> 需要和 <code>signal</code>、<code>signalAll</code> 配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition full = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition empty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟生产耗时</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() &gt;= CAPACITY) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            full.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                    empty.signalAll();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟消费</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            empty.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者消费，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                    full.signalAll();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用阻塞队列"><a href="#4-使用阻塞队列" class="headerlink" title="4. 使用阻塞队列"></a>4. 使用阻塞队列</h2><p>使用阻塞队列实现最为简单，选择 <code>java.util.concurrent.ArrayBlockingQueue</code>，初始化时指定容量，其 <code>put</code> 方法会向队列中添加一个元素，如果队列满则阻塞，直到有元素出队；<code>take</code> 方法会从队列中出队一个元素，如果队列中没有元素则阻塞，直到有元素入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟生产耗时</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 此处计数不准确，视情况删除或者进行额外同步</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟消费</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    <span class="comment">// 此处计数不准确，视情况删除或者进行额外同步</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者消费，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中 <code>println</code> 中队列长度与 <code>put</code>、<code>take</code> 操作没有同步，如果需要准确输出队列长度需要额外加锁。 </p></blockquote><h2 id="5-信号量Semaphore"><a href="#5-信号量Semaphore" class="headerlink" title="5. 信号量Semaphore"></a>5. 信号量Semaphore</h2><p>信号量用来控制特定资源的线程数量，由 Dijkstra 提出。用于保持在0至指定最大值之间的一个计数值，当线程完成一次对信号量的等待时，该计数值减一；完成一次释放时，计数值加一。</p><p><code>java.util.concurrent.Semaphore</code> 实现了信号量，<code>acquire</code> 方法会使信号量 -1，<code>release</code> 方法会使信号量 +1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Semaphore notFull = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    Semaphore notEmpty = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                    notFull.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    queue.add(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    notEmpty.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">200</span>);</span><br><span class="line">                    notEmpty.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者者消费，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    notFull.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Producer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.n<span class="function">ew <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">producer-consumer problem Wikipedia</a></li><li><p><a href="https://www.educative.io/edpresso/what-is-the-producer-consumer-problem">What is the producer consumer problem</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1777705">生产者消费者的三种实现</a></p></li><li><a href="https://en.wikipedia.org/wiki/Semaphore_(programming">Semaphore Wikipedia</a>)</li><li><a href="https://blog.csdn.net/ldx19980108/article/details/81707751">Java多种方式解决生产者消费者问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty介绍</title>
      <link href="/2022/02/16/netty%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/02/16/netty%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p> netty 是一款事件驱动的异步网络框架， 是对 Java NIO 的封装，用于快速开发高性能、高可靠的网络服务器和客户端，在大量中间件例如 Dubbo、RocketMQ 中得到广泛应用。</p><p>上文 <a href="https://strokebun.github.io/2022/02/15/Java-NIO/">Java NIO</a> 对 NIO 进行了介绍，NIO 存在以下问题：</p><ul><li>类库和 API 繁琐，上手难度高；</li><li>需要熟悉多线程编程；</li><li>存在 epoll 空轮询 bug。</li></ul><p>Netty 对 NIO 进行了封装，简单易用，并且内置了多种编解码器，支持多种协议，可用于快速开发。</p><h2 id="2-ByteBuf"><a href="#2-ByteBuf" class="headerlink" title="2. ByteBuf"></a>2. ByteBuf</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p><code>ByteBuffer</code> 是 NIO 中网络的数据容器，但这个类使用繁琐复杂，netty 中的替代品是 <code>ByteBuf</code>。<code>ByteBuf</code> 拥有以下优势：</p><ul><li>内置零拷贝</li><li>容量可以按需增长</li><li>同时具有读模式和写模式，不需要进行转换</li></ul><h3 id="2-2-分配"><a href="#2-2-分配" class="headerlink" title="2.2 分配"></a>2.2 分配</h3><p>与 <code>ByteBuffer</code> 类似，<code>ByteBuf</code> 可在堆中分配，也可在直接内存分配。</p><p>为了降低内存分配和释放的开销，netty 使用 <code>PooledByteBufAllocator</code> 实现了池化，并且基于引用计数实现内存回收，其主要 API 如下：</p><ul><li><code>buffer(int initialCapacity)</code>：返回一个基于堆或直接内存的 <code>ByteBuf</code></li><li><code>heapBuffer(int initialCapacity)</code>：返回一个基于堆内存的 <code>ByteBuf</code></li><li><code>directBuffer(int initialCapacity)</code>：返回一个直接内存的<code>ByteBuf</code></li></ul><h2 id="3-ChannelHandler"><a href="#3-ChannelHandler" class="headerlink" title="3. ChannelHandler"></a>3. ChannelHandler</h2><h3 id="3-1-ChannelHandler"><a href="#3-1-ChannelHandler" class="headerlink" title="3.1 ChannelHandler"></a>3.1 ChannelHandler</h3><p>对于开发人员而言， netty 最重要的组件的 <code>ChannelHandler</code>，它充当了入站和出战数据的处理器。</p><p>其中 <code>ChannelInboundHandler</code> 处理入站数据，<code>ChannelOutboundHandler</code> 处理出战数据。</p><h3 id="3-2-ChannelPipeline"><a href="#3-2-ChannelPipeline" class="headerlink" title="3.2 ChannelPipeline"></a>3.2 ChannelPipeline</h3><p><code>ChannelPipeline</code> 是一个 <code>ChannelHandler</code> 实例链，使用了责任链设计模式。。如果一个入站<br>事件被触发，它将被从 <code>ChannelPipeline</code> 的头部开始一直被传播到尾端。</p><p><img src="channelpipeline.png" alt="ChannelPipeline"></p><h3 id="3-3-ChannelHandlerContext"><a href="#3-3-ChannelHandlerContext" class="headerlink" title="3.3 ChannelHandlerContext"></a>3.3 ChannelHandlerContext</h3><p><code>ChannelHandlerContext</code> 代表了<code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关<br>联，每当有 <code>ChannelHandler</code> 添加到 <code>ChannelPipeline</code> 中时，都会创建 <code>ChannelHandler-Context</code>。<code>ChannelHandlerContext</code> 的主要功能是管理它所关联的 <code>ChannelHandler</code> 和在<br>同一个 <code>ChannelPipeline</code> 中的其他 <code>ChannelHandler</code> 之间的交互。</p><p><img src="channelhandlercontext.png" alt="ChannelHandlerContext"></p><p>最主要使用的方法是 <code>writeAndFlush</code>，将数据写入刷新并经过 <code>ChannelPipeline</code>。</p><h2 id="4-EventLoop"><a href="#4-EventLoop" class="headerlink" title="4. EventLoop"></a>4. EventLoop</h2><p><code>EventLoop</code> 是 netty 中的事件机制，一个 <code>EventLoop</code> 由一个 <code>Thread</code> 驱动，同时 <code>Runnable</code> 或者 <code>Callable</code> 任务可以直接交给 <code>EventLoop</code> 是实现，立即执行或者调度执行。</p><h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h2><h3 id="5-1-粘包问题"><a href="#5-1-粘包问题" class="headerlink" title="5.1 粘包问题"></a>5.1 粘包问题</h3><p>由于 TCP 是面向流的，消息是无边界的，接收缓冲区可能得到多个包或者不完整的包，需要在应用层对包进行区分。</p><p>有三种实现方式：</p><ul><li>固定长度：即每个包都是固定长度的，每次读取固定长度解析，netty 中提供了 <code>FixedLengthFrameDecoder</code> 作为实现。优点是实现简单，缺点是造成空间浪费，不推荐使用。</li><li>分割符：利用分割符对包进行区分，netty 中提供了 <code>DelimiterBasedFrameDecoder</code> 作为实现。优点是实现比较简单， 也没有空间浪费，缺点是当内容出现分割符需要进行转义，推荐使用。</li><li>自定义格式：通常使用 长度 + 内容 的方式，netty 中提供了 <code>LengthFieldBasedFrameDecoder</code> 作为实现。优点是空间紧凑，但需要自定义协议，实现较为复杂。</li></ul><h3 id="5-2-keepalive"><a href="#5-2-keepalive" class="headerlink" title="5.2 keepalive"></a>5.2 keepalive</h3><p>在对方服务不可用或者网络连接故障时，如果未关闭连接，会浪费资源。 TCP 层有 keepalive 机制，但需要 2 小时以上才能判断连接失效，耗时过长，在服务器应用需要自行实现 keepalive 机制。</p><p>Idle 监测是一种检测机制，会固定时间发送询问机制，测试对端服务是否正常。当发生 Idle 之后，才发生 keepalive。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://book.douban.com/subject/27038538/">netty实战</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/181239748">超详细Netty入门，看这篇就够了</a></p></li><li><p><a href="https://time.geekbang.org/course/intro/100036701">Netty 源码剖析与实战</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO</title>
      <link href="/2022/02/15/Java-NIO/"/>
      <url>/2022/02/15/Java-NIO/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>传统的服务端同步阻塞 IO BIO（Blocking IO）调用 <code>read</code> 之后，如果接收缓冲区中没有数据，会一直阻塞直到收到新数据。在 <a href="https://strokebun.github.io/2022/02/15/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">IO多路复用</a> 中提到，传统的 BIO + 多线程的解决方案无法解决 C10K 问题，需要使用 IO 多路复用。</p><p>NIO（Non-blocking IO，也称 New IO），是 Java 的一种同步非阻塞 IO 模型，底层使用了 IO 多路复用，可以有效解决 C10K 问题。</p><p>Java NIO 有三个核心组件，<code>Buffers</code>、<code>Selector</code> 和 <code>Channel</code>，将在下文中陆续介绍。</p><h2 id="2-Buffer"><a href="#2-Buffer" class="headerlink" title="2. Buffer"></a>2. Buffer</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><p><code>Buffer</code> 是存储数据的缓冲区，提供读写操作，底层使用数组实现。使用 <code>Buffer</code> 一般遵守 4 个步骤：</p><ol><li><p>写入数据到 <code>Buffer</code></p></li><li><p>调用 <code>flip()</code> 方法</p></li><li>从 <code>Buffer</code> 中读取数据</li><li>调用 <code>clear()</code> 或 <code>compact()</code> 方法清除缓存</li></ol><p>向 <code>Buffer</code> 写入数据后，内部会记录写入数据量，一旦需要读取数据，需要通过 <code>flip()</code> 方法将 <code>Buffer</code> 从写模式切换到读模式。在读模式下，可以读取之前写入到 <code>Buffer</code> 的所有数据。</p><p>当读完所有数据之后，需要清空缓冲区，有两者方式。<code>clear()</code> 清空整个缓冲区，<code>compact()</code> 清除已经读过的数据。 </p><p>下面是一个使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"><span class="comment">// 创建48 byte大小的Buffer</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">// 写入数据到Buffer</span></span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">   buf.flip();  <span class="comment">// 切换为读模式</span></span><br><span class="line">   <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) buf.get()); <span class="comment">// 每次读取一个byte</span></span><br><span class="line">   &#125;</span><br><span class="line">   buf.clear(); <span class="comment">// 情况缓冲</span></span><br><span class="line">   bytesRead = inChannel.read(buf); <span class="comment">// 重新写入Buffer</span></span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure><h3 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h3><p><code>Buffer</code> 在内部维护 4 个核心变量：</p><ul><li><code>capacity</code>：缓冲区的最大容量，设定后不可改变</li><li><code>limit</code>：缓冲区的数据个数，<code>flip()</code> 调用前等于 <code>capacipty</code>，调用后等于 <code>position</code></li><li><code>position</code>：下一个要读写的元素下标，由 <code>get()</code> 和 <code>put()</code> 自动更新</li><li><code>mark</code>：记录当前 <code>position</code> 的位置，可以通过 <code>reset()</code> 恢复到 <code>mark</code> 的位置</li></ul><p><img src="buffer.png" alt="Buffer示意"></p><h3 id="2-3-类型"><a href="#2-3-类型" class="headerlink" title="2.3 类型"></a>2.3 类型</h3><h4 id="2-3-1-Heap-Buffer"><a href="#2-3-1-Heap-Buffer" class="headerlink" title="2.3.1 Heap Buffer"></a>2.3.1 Heap Buffer</h4><p><code>Heap Buffer</code> 在堆中分配，在 Java NIO 中，<code>Buffer</code> 有以下类型：</p><ul><li><code>ByteBuffer</code>、<code>CharBuffer</code>、<code>DoubleBuffer</code>、<code>FloatBuffer</code>、<code>IntBuffer</code>、<code>LongBuffer</code>、<code>ShortBuffer</code></li><li><code>MappedByteBuffer</code></li></ul><p>其中第一类 <code>Buffer</code> 代表了不同的数据类型，通过以下方式创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>而 <code>MappedByteBuffer</code> 是 <code>FileChannel</code> 提供的内存映射操作，使用 <code>map</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mode:映射文件方式</span></span><br><span class="line"><span class="comment"> * position:起始位置</span></span><br><span class="line"><span class="comment"> * size:映射区大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MappedByteBuffer <span class="title">map</span><span class="params">(<span class="keyword">int</span> mode,<span class="keyword">long</span> position,<span class="keyword">long</span> size)</span></span>; </span><br></pre></td></tr></table></figure><blockquote><p><code>MappedByteBuffer</code> 底层依赖 <code>mmap</code> 实现，将在下文介绍。</p></blockquote><p>其中 <code>mode</code> 可取值为：</p><ul><li><code>READ_ONLY</code></li><li><code>READ_WRITE</code></li><li><code>PRIVATE</code>：修改只对缓冲区有效，不会作用到文件</li></ul><p><code>MappedByteBuffer</code> 的使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    RandomAccessFile f = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        RandomAccessFile world = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;world.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel fc = f.getChannel();</span><br><span class="line">        MappedByteBuffer buf = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        FileChannel worldChannel = world.getChannel();</span><br><span class="line">        MappedByteBuffer worldBuf = worldChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">        worldBuf.put(buf);</span><br><span class="line"></span><br><span class="line">        fc.close();</span><br><span class="line">        f.close();</span><br><span class="line">        world.close();</span><br><span class="line">        worldChannel.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-Direct-Buffer"><a href="#2-3-2-Direct-Buffer" class="headerlink" title="2.3.2 Direct Buffer"></a>2.3.2 Direct Buffer</h4><p>除了 <code>Heap Buffer</code>，<code>Buffer</code> 还可分为  <code>Direct Buffer</code>，<code>Direct Buffer</code> 在直接内存分配，在 GC 时不会移动。使用 <code>DirectBuffer</code> 可以减少一次内存拷贝，<code>Heap Buffer</code> 写入前，会先创建一个 <code>Direct Buffer</code>，再去执行真正的写操作，这是因为在写入时，这个 <code>Buffer</code> 的地址不能够变化，而 <code>Heap Buffer</code> 可能在 GC 过程中被移动。所以在调用底层写入之前，数据要在堆外内存。但是 <code>Direct Buffer</code> 依赖 <code>malloc</code> 实现，效率相比堆内创建更低，并且更不宜维护，通常会使用内存池来提高性能。</p><h2 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3. Channel"></a>3. Channel</h2><p><code>Channel</code> 与 <code>java.io</code> 中的流类似，但有以下不同：</p><ul><li><code>Channel</code> 是双向的，支持写入和读取；</li><li><code>Channel</code> 和 <code>Buffer</code> 强依赖，读写都需要通过 <code>Buffer</code>。</li></ul><p><img src="channel.png" alt="Channel"></p><p>Java NIO 中的 <code>Channel</code> 可分为：</p><ul><li>文件：<code>FileChannel</code>，用于读写文件</li><li>socket<ul><li><code>ServerSocketChannel</code>：用于服务端，可以监听 TCP 连接</li><li><code>SocketChannel</code>：通过 TCP 读写网络数据</li><li><code>DatagramChannel</code>：通过 UDP 读写网络数据</li></ul></li></ul><h2 id="4-Selector"><a href="#4-Selector" class="headerlink" title="4. Selector"></a>4. Selector</h2><p><code>Selector</code> 绑定了多个 <code>Channel</code> 和事件，调用 <code>select</code> 将阻塞 到至少有一个 <code>Channel</code> 触发事件，<code>select()</code> 返回就绪的 <code>Channel</code> 个数。</p><p>事件类型包括：</p><ul><li><code>SelectionKey.OP_READ</code>：读就绪</li><li><code>SelectionKey.OP_WRITE</code>：写就绪</li><li><code>SelectionKey.OP_CONNECT</code>：客户端连接成功，用于 socket 通道</li><li><code>SelectionKey.OP_ACCEPT</code>： 服务器接收新连接，用于 socket 通道</li></ul><blockquote><p>jdk 1.7 之前的 select 可能有空轮询问题，这是由于部分 Linux 内核的底层存在假唤醒问题，此时 select() 返回 0，但是 jdk 官方将这个问题甩锅给操作系统，没有进行修改，后续造成大量问题。</p><p>对于这个问题，使用 NIO 封装的 netty 的处理方式是记录 select() = 0 的持续次数，到达阈值则重新构建 Selector。</p></blockquote><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 切换成非阻塞模式</span></span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 将通道注册到选择器上，指定事件</span></span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * select() &gt; 0则有IO就绪，需要遍历查看具体哪个IO就绪</span></span><br><span class="line"><span class="comment">         * 注: 调用时会阻塞</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前选择器所有注册的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator= selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                <span class="comment">// 接收事件就绪，此处为有TCP连接</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123; <span class="comment">// 读事件就绪</span></span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 取消选择键(已经处理过的事件，就应该取消掉了)</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="selector.png" alt="Selector"></p><h2 id="5-零拷贝"><a href="#5-零拷贝" class="headerlink" title="5. 零拷贝"></a>5. 零拷贝</h2><p>Java NIO 底层除了使用 IO 多路复用外，还使用了零拷贝技术。</p><p>通过网络发送文件通常使用 <code>read</code> 和 <code>write</code> 函数，需要经历 4 次拷贝：</p><ul><li>第 1 次：将磁盘的数据拷贝到操作系统内核的的缓冲区，通过 DMA 实现；</li><li>第 2 次：将内核缓冲区的数据拷贝到用户进程缓冲区，通过 CPU 实现；</li><li>第 3 次：将用户进程缓冲区的数据拷贝到内核 socket 的缓冲区，通过 CPU 实现；</li><li>第 4 次：将 socket 缓冲区的数据拷贝到网卡中，通过 DMA 实现。</li></ul><p><img src="4次拷贝.png" alt="4次拷贝"></p><p>上述过程开销严重，要想提高文件的传输效率，必须减少 <strong>内存拷贝</strong> 的次数，通常有两种实现方式：</p><ul><li>mmap</li><li>sendfile</li></ul><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p><code>mmap</code> 可以将内核缓冲区的数据映射到用户空间，共享缓冲区，内核和用户空间之间就不需要进行拷贝操作，此时传输文件的拷贝次数如下：</p><ul><li>将磁盘数据拷贝到内核缓冲区，与用户程序共享；</li><li>用户程序调用 <code>write</code>，操作系统将内核缓冲区的拷贝到 socket 缓冲区，由 CPU 完成；</li><li>将 socket 缓冲区的数据拷贝到网卡中，通过 DMA 实现。</li></ul><p><img src="mmap.png" alt="mmap过程"></p><p>这种方式减少了内核缓冲区到用户空间的 1 次拷贝。</p><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p><code>sendfile</code> 函数可以将内核缓冲区的数据直接拷贝到 socket 缓冲区，而不用经过用户空间，效果如下：</p><p><img src="sendfile.png" alt="sendfile过程"></p><p>数据拷贝都使用 DMA 实现，没有内存层面的拷贝，这被称为零拷贝。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://tech.meituan.com/2016/11/04/nio.html">Java NIO浅析</a></li><li><a href="http://tutorials.jenkov.com/java-nio/index.html">Java NIO Tutorial</a></li><li><a href="https://zhuanlan.zhihu.com/p/27625923">Direct Buffer</a></li><li><a href="https://zhuanlan.zhihu.com/p/26243285">Java NIO编程实例之三 Selector</a></li><li><a href="https://zhuanlan.zhihu.com/p/258513662">原来 8 张图，就可以搞懂零拷贝了</a></li><li><a href="https://www.jianshu.com/p/3ec120ca46b2">JDk Epoll空轮询Bug</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2022/02/15/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2022/02/15/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Socket-基础"><a href="#1-Socket-基础" class="headerlink" title="1. Socket 基础"></a>1. Socket 基础</h2><p>网络通信依赖 Socket 实现，内核对应用层提供 socket 接口供用户进程访问。</p><p><img src="socket.png" alt="socket示意"></p><p>socket 维护了读写缓冲区，当使用操作系统提供的 write 写入数据时，需要先将数据从用户态拷贝到内核态的缓冲区，由操作系统发送。对端的网卡收到数据后，通过触发中断， 将网卡数据拷贝到内核的缓冲区，再拷贝到用户空间供进程读取。</p><p><img src="缓冲区.png" alt="sockey传输"></p><p>对于传统的阻塞IO BIO（Blocking IO），一次阻塞读取的工作流程如下：</p><ul><li>阻塞式读取 Socket，缓冲区中没有数据；</li><li>进程进入阻塞状态，从 CPU 的运行队列中出队，进入 Socket 的等待队列；</li><li>客户端的数据到达网卡，通过 DMA 将数据拷贝到缓存区，完成后发起中断；</li><li>系统响应中断，将进程从 Socket 的等待队列移动到 CPU 的运行队列，进程有机会获得 CPU 时间片。</li></ul><h2 id="2-IO多路复用"><a href="#2-IO多路复用" class="headerlink" title="2. IO多路复用"></a>2. IO多路复用</h2><h3 id="2-1-C10K问题"><a href="#2-1-C10K问题" class="headerlink" title="2.1 C10K问题"></a>2.1 C10K问题</h3><p>一个 TCP 服务器如何处理多个请求呢？直观的想法对于多个请求按顺序处理，由于使用 BIO，后一个请求需要等待前一个请求完成，这样的处理方式完全没有并发能力，对于多核 CPU 服务器而言导致大量的计算资源浪费。</p><p>另一个更合适的做法是使用一个线程处理连接，为每一个连接创建一个新线程来处理业务，这样处理能够运用多核特性。</p><p><img src="c10k.png" alt="per connection per thread"></p><p>但存在大量不活跃的长连接时，上述方案仍会出现问题，这是因为线程是很贵的资源：</p><ul><li>线程的内存开销大。每一个线程内核需要为其分配 512K - 1M 的空间，如果系统中的线程数量过 10k，JVM 的内存也会被消耗殆尽，无法提供服务；</li><li>线程的切换成本高。操作系统的线程切换需要保存上下文，并执行系统调用，过高的线程数，可能导致线程切换的时间占比更高，使用多线程反而导致了性能的下降。</li></ul><p>上述单机服务器实现大量连接的问题被称为 C10K 问题。</p><h3 id="2-2-IO多路复用"><a href="#2-2-IO多路复用" class="headerlink" title="2.2 IO多路复用"></a>2.2 IO多路复用</h3><p>IO 多路复用由此产生，其思想就是用一个线程，同时监听若干个 socket 连接是否可以执行 IO 操作，在单线程的情况下可以同时处理多个客户端请求。</p><blockquote><p>IO 多路复用的核心优势在于处理更多的连接，在连接数不高的情景下，使用 IO 多路复用的性能可能比 BIO + 多线程的方式低。</p></blockquote><p>Linux 上的 IO 多路复用有 select、poll、epoll 三个实现。</p><h2 id="3-select"><a href="#3-select" class="headerlink" title="3. select"></a>3. select</h2><p><code>select</code> 方法定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> max_fd, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, </span></span></span><br><span class="line"><span class="params"><span class="function">           struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 <code>max_fd</code> 是最大文件描述符的值，<code>readfds</code>、<code>writefds</code> 和<code>exceptfds</code>  分别对应读、写、异常条件的文件描述符，<code>timeout</code> 为超时时间。</p><blockquote><p>Linux 的思想是一切皆文件，网络 IO 也被看成文件处理，会分配文件描述符。</p></blockquote><p><code>fd_set</code> 数据结构使用位图实现，默认大小为 1024，传给内核之后，内核根据 IO 完成情况给 <code>fd_set</code> 置位，并返回 IO 就绪的文件描述符个数。例如传入的 <code>read_fds</code> 的第 1、2、3 位为1，那么传入内核之后，内核会监听文件描述符 1、2、3 对应的 socket 连接并将 <code>read_set</code> 清零，如果此时 1、3 完成读 IO，那么 <code>read_fds</code> 的第 1、3 位将被设置为 1，<code>select</code> 函数的返回值为 2。</p><p><img src="select示例.png" alt="select示例"></p><p><code>select</code> 会阻塞直到有 IO 完成或者超时返回，在这期间，内核需要扫描整个 <code>fd_set</code> 才能判断是否有事件发生，效率低下。</p><p><code>fd_set</code> 的使用涉及以下几个 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">// 将 fd_set 所有位置 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">// 将 fd_set 的第 fd 位置 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fd_set)</span></span>;  <span class="comment">// 将 fd_set 的第 fd 位置 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">// 检测 fd_set 的第 fd 位是否为 1</span></span><br></pre></td></tr></table></figure><p>例如完成一个 TCP 服务器，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 初始化socket</span></span><br><span class="line"><span class="keyword">int</span> maxfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> <span class="title">read_set</span>;</span></span><br><span class="line"><span class="keyword">int</span>[] accept_fds[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 从已连接队列中取出5个连接，用于后续的select</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    accept_fds[i] = accpet(...);</span><br><span class="line">    <span class="comment">// 获得文件描述符的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (accept_fds[i] &gt; maxfd) &#123;</span><br><span class="line">        maxfd = accept_fds[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 每次执行select之前，都需要重新设置read_set</span></span><br><span class="line">    FD_ZERO(&amp;read_set);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 置位，表示对这些连接感兴趣</span></span><br><span class="line">        FD_SET(accept_fds[i], &amp;read_set);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    select(maxfd + <span class="number">1</span>, &amp;rest, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(accept_fds[i], &amp;rest)) &#123;</span><br><span class="line">            <span class="comment">// 处理业务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的说明也可以看出 <code>select</code> 有以下缺点：</p><ul><li><code>fd_set</code> 固定长度为 1024，最多监听 1024 个连接，增加连接需要改动内核源码重新编译；</li><li><code>fd_set</code> 需要从用户态传入内核态。并且传入内核中都会被改写，不可重用，每次调用 <code>select</code> 前需要重新初始化；</li><li>拿到结果后，需要遍历整个 <code>fd_set</code>，才能知道哪些连接可以处理。</li></ul><h2 id="4-poll"><a href="#4-poll" class="headerlink" title="4. poll"></a>4. poll</h2><p><code>poll</code> 的函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">               <span class="keyword">int</span>   fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">               <span class="keyword">short</span> events;     <span class="comment">// 感兴趣的响应事件，通过掩码设置</span></span><br><span class="line">               <span class="keyword">short</span> revents;    <span class="comment">// 实际响应事件，通过掩码设置</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>fds</code> 是 <code>pollfs</code> 类型的数组，<code>nfd</code> 是 <code>fds</code> 数组的长度。</p><p><code>poll</code>与 <code>select</code> 的功能基本相同，主要是解决了连接上限的问题，<code>select</code> 的其他缺点 <code>poll</code> 仍然具有。</p><blockquote><p>限于篇幅，<code>poll</code> 的编程使用不在此处介绍，感兴趣的话可以阅读 《UNIX网络编程卷1》 6.11 小节。</p></blockquote><h2 id="5-epoll"><a href="#5-epoll" class="headerlink" title="5. epoll"></a>5. epoll</h2><h3 id="5-1-epoll介绍"><a href="#5-1-epoll介绍" class="headerlink" title="5.1 epoll介绍"></a>5.1 epoll介绍</h3><p><code>epoll</code> 是对 <code>select</code> 和 <code>poll</code> 的改进，使用了三个函数，下面将依次介绍。</p><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><code>epoll_create</code> 会创建一个实例，并返回对应的文件描述符，参数 size 是 <code>epoll</code> 监听的文件描述符个数，并不是上限值，而是对内核初始化数据结构的一个建议。</p><p>内部的数据结构：</p><ul><li>监听列表：所有要监听的文件描述符，用红黑树存储</li><li>就绪列表：所有就绪的文件描述符，使用链表存储</li></ul><p><img src="epoll数据结构.png" alt="epoll的数据结构"></p><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p><code>epoll_ctl</code> 是事件注册函数，<code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，<code>fd</code> 即要监听的文件描述符，<code>event</code> 是要监听的事件。</p><p><code>epoll_ctl</code> 会将文件描述符 <code>fd</code> 添加到监听列表中，并监听事件 <code>event</code>，当 <code>fd</code> 上发生相应事件时，将 <code>fd</code> 添加到 <code>epoll</code> 实例的就绪队列上。</p><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><code>epoll_wait</code> 会等待 <code>epfd</code> 上的 IO 事件，最多返回 <code>maxevents</code> 个事件，<code>events</code> 参数即从内核得到事件的集合。</p><h3 id="5-2-触发形式"><a href="#5-2-触发形式" class="headerlink" title="5.2 触发形式"></a>5.2 触发形式</h3><p>水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。</p><p>边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。该模式效率更高，但必须使用非阻塞读写。</p><blockquote><p>epoll 默认使用水平触发。</p></blockquote><h3 id="5-3-改进点"><a href="#5-3-改进点" class="headerlink" title="5.3 改进点"></a>5.3 改进点</h3><p>相较于 <code>select</code> 和 <code>poll</code>，<code>epoll</code> 有两个改进点：</p><ul><li><code>epoll_wait</code> 在检测是否有事件发生时，只要检测链表是否为空即可，并将发生的事件复制到用户态；</li><li><code>epoll</code> 对于每个描述符，只需要在 <code>epoll_ctl</code> 传递一次，之后 <code>epoll_wait</code> 不需要再次传递，这也大大提高了效率。</li></ul><h2 id="6-对比"><a href="#6-对比" class="headerlink" title="6. 对比"></a>6. 对比</h2><p><code>select</code>、<code>poll</code>、<code>epoll</code> 的对比如下：</p><ul><li>最大连接数：<code>select</code> 最大连接数为 1024，增加连接数需要改动内核；<code>poll</code> 和 <code>epoll</code> 没有连接上限；</li><li>文件描述符剧增的 IO 效率：<code>select</code> 和 <code>poll</code> 需要对所有连接进行扫描，在多连接时效率低；<code>epoll</code> 只对活跃的连接进行扫描，性能不会大幅度下降，但面对大量活跃连接仍有性能问题；</li><li>数据拷贝：<code>select</code> 和 <code>poll</code> 每次都需要向内核拷贝，<code>epoll</code> 只需要拷贝一次。</li></ul><p>三者的适用场景：</p><ul><li><code>epoll</code>：大量不活跃连接场景，限制 Linux 平台。</li><li><code>select</code> ：少量活跃短连接场景，不同于 <code>epoll</code> 和 <code>poll</code>，<code>select</code> 有移植性。</li><li><code>poll</code> ：大量活跃短连接场景。 </li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://tech.meituan.com/2016/11/04/nio.html">Java NIO浅析</a></li><li><a href="https://zhuanlan.zhihu.com/p/353850099">深入理解高性能网络开发路上的绊脚石 - 同步阻塞网络 IO</a></li><li><a href="http://www.kegel.com/c10k.html">C10K Problem</a></li><li><a href="https://imageslr.com/2020/02/27/select-poll-epoll.html#fd_set-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86%E5%90%88">IO多路复用, select/poll/epoll详解</a></li><li><p><a href="https://book.douban.com/subject/1500149/">UNIX网络编程卷1</a></p></li><li><p><a href="https://my.oschina.net/lscherish/blog/4492873">详解IO多路复用和其三种模式—select/poll/epoll</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的redo log和binlog</title>
      <link href="/2022/02/11/MySQL%E4%B8%AD%E7%9A%84redo-log%E5%92%8Cbinlog/"/>
      <url>/2022/02/11/MySQL%E4%B8%AD%E7%9A%84redo-log%E5%92%8Cbinlog/</url>
      
        <content type="html"><![CDATA[<p>使用 MySQL 的过程中难免会与其日志系统打交道，主要有 redo log，binlog，undo log 和慢查询日志等，本文主要介绍 redo log 和 binlog。</p><h2 id="1-redolog"><a href="#1-redolog" class="headerlink" title="1. redolog"></a>1. redolog</h2><h3 id="1-1-buffer-pool"><a href="#1-1-buffer-pool" class="headerlink" title="1.1 buffer pool"></a>1.1 buffer pool</h3><p>数据库中的行数据、索引等，都是存储在磁盘上面的，当访问某个页时，需要从磁盘把整个页的数据加载到内存，读写完成之后释放内存。</p><p>磁盘访问是十分低效的，为此 InnoDB 引入缓冲池 buffer pool，在 MySQL 启动时申请一片连续的内存，作为磁盘页的缓存。对数据库进行读取页的操作，首先从磁盘读到的页存放在 buffer pool，从磁盘读入数据时，会将该页放入 buffer pool，下一次读取相同的页时，先判断在 buffer pool 中是否存在；对数据的修改也是先对 buffer pool 中的页进行修改，并由后台线程在系统空闲时进行刷盘。</p><p>buffer pool 的空间也是有上限的，其淘汰策略采用优化的 LRU 算法。</p><blockquote><p>具体实现可见 《MySQL技术内幕 InnoDB 存储引擎》2.3.2 小节。</p></blockquote><h3 id="1-2-redo-log"><a href="#1-2-redo-log" class="headerlink" title="1.2 redo log"></a>1.2 redo log</h3><p>磁盘中的数据会落后于 buffer pool，如果进程或者机器崩溃， buffer pool 中未能落盘的数据将会丢失。事务中的持久性要求提交之后，对数据的修改不能丢失，一个直观的思路是事务提交前保证修改的页全部刷盘，但这个思路有两个不足：</p><ul><li>刷新一个页过于浪费，有时候只改动了页中一点数据，却要将整个页的数据刷入磁盘</li><li>随机 IO，一个事务可能改动多个页面，传统的机械硬盘随机 IO 效率十分低下</li></ul><p>为此 InnoDB 维护了 redo log，redo log 的思路是用轻量的数据记录改动，并把随机 IO 转化为顺序 IO，极大提升了写入效率。事务在 redo log 全部落盘后才能提交，即使崩溃也可以通过重放 redo log 复原数据，保证了持久性。</p><blockquote><p>这种机制被称为 WAL，Write Ahead Log，被广大事务数据库采用。</p></blockquote><p>那么 redo log 的格式应该是什么样呢？首先，redo log 的数据量需要尽可能小，否则会影响性能。其次，系统崩溃后重放数据不知道哪些页已经刷盘，redo log 应该保证幂等。因此，redo log 的格式为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(PageId, Record Offset, (Field 1, Value 1), (Field 2, Value 2)...)</span><br></pre></td></tr></table></figure><p>PageId 确定了修改的页，Record Offset 为修改的数据在页中的偏移，后面的 Field-Value 对记录了修改的列以及数据。</p><blockquote><p>redo log 是 InnoDB 特有的机制。</p></blockquote><h3 id="1-3-redo-log刷盘"><a href="#1-3-redo-log刷盘" class="headerlink" title="1.3 redo log刷盘"></a>1.3 redo log刷盘</h3><p>InnoDB 为了解决磁盘速度过慢的问题引入 buffer pool，相应的，redo log 也不是直接写入磁盘，而是先写入 redo log buffer，默认在以下场景刷新到磁盘：</p><ul><li>redo log buffer 空间过半</li><li>事务提交前</li><li>buffer pool 的页刷盘前</li><li>正常关闭服务等</li><li>做 checkpoint </li></ul><blockquote><p>redo log 的刷盘时机可以通过 innodb_flush_log_at_trx_commit 控制，可以通过牺牲持久性来换取运行效率，一般不推荐修改。</p></blockquote><p>不幸的是，在磁盘上存储的 redo log 大小是有上限的，分为 4 块 1GB 大小的文件，总共 4 GB。从头开始写，写到末尾又从开头循环写，也就是说，后写的日志可能覆盖以前的位置。</p><p><img src="checkpoint.png" alt="redo log存储"></p><p>write pos 是当前 redo log 记录的位置，而 checkpoint 是当前要擦除的位置， 中间是还可以记录的部分。当 buffer pool 中的页刷盘之后，其 redo log 便可以被覆盖了，checkpoint 则进行相应的改变。</p><h2 id="2-binlog"><a href="#2-binlog" class="headerlink" title="2. binlog"></a>2. binlog</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>上文说到 redo log 可以用于故障后恢复，但只限于 InnoDB，而 InnoDB 是在 MySQL 比较后面的版本才引入的。对于早期的 MySQL，使用的是 binlog。binlog 是 binary log 的缩写，即二进制日志，记录了对数据库执行的更改操作，主要用于全量数据备份。</p><p>binlog 可以通过启动选项 binlog-format 配置记录形式：</p><ul><li>statement： 记录 SQL 更新语句</li><li>row：记录行的内容，包括更新前和更新后的值</li><li>mixed：通常使用 statement，某些特殊情况转为 row，具体可见 <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-log-mixed.html">binary log mixed</a></li></ul><blockquote><p>binlog 另一个用途是 MySQL 主从服务器之间的数据同步，在主从复制中 binlog-format 需要选择 row。</p></blockquote><h3 id="2-2-两阶段提交"><a href="#2-2-两阶段提交" class="headerlink" title="2.2 两阶段提交"></a>2.2 两阶段提交</h3><p>两阶段提交是将 redo log 的写入分为 prepare 和 commit 两个部分，其中 commit 需要在 binlog 写入之后完成。</p><blockquote><p>这里的两阶段提交与分布式事务中的两阶段提交不同，需要进行区分。</p></blockquote><p><img src="两阶段提交.png" alt="两阶段提交"></p><p>两阶段提交的目的是让 redo log 和 binlog 的逻辑一致。如果 binlog 写入成功但 commit 未提交，mysql 启动时会自动提交这个事务；如果 prepare 完成但 binlog 写入失败，mysql 启动时会自动回滚这个事务。</p><p>如果直接先写 redo log 后写 binlog，或者反过来，那么效果会如何，以下将 id = 2 的行中 c 从 0 更新到 1 进行分析：</p><ul><li>先写 redo log 后写 binlog：redo log 写完，binlog 还没写完产生了 crash，通过回放 redo log 可以恢复 c = 1，但是 binlog 未写完，丢失了这个更新，那么在进行数据库备份时将会丢失这条数据，以后用这个备份进行恢复会导致数据错误；</li><li>先写 binlog 后写 redo log：回放 redo log 事务无效，c = 0，但在 binlog 中已经记录了 “c 从 0 变为 1” 这个日志，那么以后用 binlog 备份恢复时将会多出来这个事务。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>redo log 用于恢复主机故障时未更新的数据，binlog 用于备份操作，两阶段提交就是保持故障恢复和备份恢复的结果一致性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/book/6844733769996304392">MySQL是怎样运行的</a></li><li><a href="https://time.geekbang.org/column/intro/100020801?tab=catalog">MySQL实战45讲</a></li><li><a href="https://book.douban.com/subject/24708143/">MySQL技术内幕</a></li><li><a href="http://mysql.taobao.org/monthly/2020/02/01/">庖丁解InnoDB之REDO LOG</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247486774&amp;idx=1&amp;sn=bac4946a1ad1479837b58f6746475ab7&amp;chksm=979684c4a0e10dd2b393814bed9bbac28608f9df2eec89d1437eaac80bd976cc52f5dc87aaaf&amp;sessionid=0&amp;scene=126&amp;clicktime=1644559487&amp;enterid=1644559487&amp;ascene=3&amp;devicetype=android-30&amp;version=28000b5b&amp;nettype=WIFI&amp;abtest_cookie=AAACAA%3D%3D&amp;lang=zh_CN&amp;exportkey=A%2B93mW%2BVOVZnE31E5Ki5JiU%3D&amp;pass_ticket=DuSjQXj3xDf0Of3ww7KcjiFL1S359iz%2BhlLBi3gCKgQZOvbi2UpW0ruhmMlmcjgJ&amp;wx_header=3">我们都是小青蛙 公众号</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(3) 垃圾回收</title>
      <link href="/2022/02/09/JVM%E7%B3%BB%E5%88%97(3)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/02/09/JVM%E7%B3%BB%E5%88%97(3)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-垃圾识别"><a href="#1-垃圾识别" class="headerlink" title="1. 垃圾识别"></a>1. 垃圾识别</h2><h3 id="1-1-GC介绍"><a href="#1-1-GC介绍" class="headerlink" title="1.1 GC介绍"></a>1.1 GC介绍</h3><p>在 C 语言中，程序员需要手动管理内存，使用 malloc 分配内存，当对象不再使用时，需要使用 free 回收内存。如果忘记调用，这块内存将一直占用无法被使用，导致内存泄露，如果放任内存泄露的程序运行，在某一刻内存将占满，程序崩溃。另外，程序员可能会错误释放使用中的内存空间，下一次程序使用此空间时将会发生故障，往往会遇到令人头疼的段错误。以上问题出现的时间可能不一致，导致这类 BUG 难以定位。</p><p>为了摆脱手动管理内存的困境，Garbarge Collection，GC，垃圾回收机制应运而生。对象如果不再使用，其占用的内存将会自动被回收，后来出现的大部分语言，例如 Java、Go、C# 等都引入了垃圾回收机制。</p><h3 id="1-2-垃圾识别"><a href="#1-2-垃圾识别" class="headerlink" title="1.2 垃圾识别"></a>1.2 垃圾识别</h3><p>在回收对象内存之前，需要先判断该对象是否存活，有两种经典的算法：</p><ul><li>引用计数</li><li>可达性分析</li></ul><h4 id="1-2-1-引用计数"><a href="#1-2-1-引用计数" class="headerlink" title="1.2.1 引用计数"></a>1.2.1 引用计数</h4><p>引用计数的思路是，在对象中添加一个引用计数器，当被引用时，计数 +1，引用失效时，计数 -1。如果计数器的值为 0，则该对象不再被使用，可以进行回收。</p><p>引用计数的优点是思路简单，可以立即回收垃圾，暂停时间短。</p><p>引用计数无法解决循环依赖的问题，例如 A 引用了 B，B 又引用了 A，那么两个对象的计数永远不为 0，也不会被回收。</p><p>使用引用计数的语言有 Swift、C++ 11 中的 shared_ptr 等，为了解决循环依赖问题，这两种编程语言都提出了弱引用的概念，弱引用不会增加引用计数。</p><blockquote><p>虽然使用弱引用可以解决循环依赖问题，但是程序员需要判断该场景是否需要使用弱引用，在复杂的循环引用中这仍是一件痛苦的事情。</p></blockquote><h4 id="1-2-2-可达性分析"><a href="#1-2-2-可达性分析" class="headerlink" title="1.2.2 可达性分析"></a>1.2.2 可达性分析</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>另一种更加主流的机制是使用可达性分析，其思路是通过存活的一些根节点对象，根据他们的引用关系向下搜索，所经过的路径称为引用链，如果对象在引用链上不可达，便可以被回收。大部分商用语言 Java、C#、Go 都使用了可达性分析。</p><p>在 Java 中，这些存活的根节点称为 GCRoots，固定包含：</p><ul><li>虚拟机栈中引用的对象，例如栈帧中的方法参数、局部变量等；</li><li>与虚拟机栈类似，本地方法栈引用的对象；</li><li>类静态属性引用的对象；</li><li>常量引用的对象，例如字符串对象；</li><li>虚拟机内部的引用，例如基本数据类型包装类的 Class 对象，常驻异常对象，系统类加载器；</li><li>被 synchronized 锁持有的对象。</li></ul><h5 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h5><p>直接利用可达性分析识别垃圾时需要暂停所有用户线程，即 STW（Stop The World）来保证引用关系的正确性。其中枚举 GCRoots 在优化下已经十分高效，但根据引用链遍历的过程与对象数量和结构相关，耗时严重。</p><p>为了解决上述问题，引入了三色标记算法。</p><p>顾名思义，这个算法将 GC 过程中的对象分为三种：</p><ul><li>白色：还未搜索过的对象</li><li>灰色：正在搜索的对象</li><li>黑色：搜索完成的对象</li></ul><p>GC 开始前所有对象都是白色，首先将 GCRoots 标记为灰色，利用广度优先搜索的思想，不断取出灰色对象 G，并将 G 引用的所有对象 S1、S2 都标记为灰色，最后将 G 标记为黑色。之后将不断重复上述过程，标记结束之后存活对象均为黑色，垃圾均为白色。</p><p>三色标记过程可以与用户线程并发执行，但在标记过程中用户线程可能改变引用关系，导致将存活的对象标记为白色，程序发生错误，如下图所示。</p><p><img src="漏标记.png" alt="漏标记问题"></p><p>(a) 中 A 为黑色，B 为灰色，此时将要遍历 B 引用的对象，(b) (c) 中用户线程去掉了 B 到 C 的引用，增加了 A 到 C 的引用，此时 C 理应存活，但 A 已经遍历结束，已经没有引用链可以到达 C，C 被标记为白色，GC 过程中将被回收。</p><p>科学家们证明了上述漏标出现需要同时满足两个条件：</p><ul><li>插入了黑色对象到白色对象的引用</li><li>删除了所有灰色对象到该白色对应的引用</li></ul><p>破坏条件 1 的方案为增量更新，黑色对象新增对白色对象的引用，将变为灰色。</p><p>破坏条件 2 的方案为原始快照，当灰色对象删除到白色对象的引用时，记录这些灰色对象，在并发扫描结束后，重新扫描这些灰色对象。</p><h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h2><h3 id="2-1-分代收集"><a href="#2-1-分代收集" class="headerlink" title="2.1 分代收集"></a>2.1 分代收集</h3><p>主流的垃圾收集器都遵守了分代收集的理论，即在不同的区域使用不同的垃圾收集算法，其建立在两个假设上：</p><ul><li>绝大多数对象创建后不久就会被回收；</li><li>多次未被垃圾回收的对象越难消亡。</li></ul><p>这两个假设给出了垃圾收集器的设计原则，将堆分为不同的区域，新生代和老年代。新生代中的对象大概率会被回收，而存活的对象将逐步晋升到老年代。</p><p>但如果新生代和老年代的对象互相引用，即跨代引用，将导致每次 GC 都需要使用可达性分析遍历新生代和老年代，性能开销大。为此在新生代建立一种数据结构卡表，卡表会标记老年代的某一块内存存在跨代引用，当新生代发生 Minor GC 时，只有那块内存会被加入了 GCRoots 进行扫描，提高了 GC 的效率。</p><h3 id="2-2-术语定义"><a href="#2-2-术语定义" class="headerlink" title="2.2 术语定义"></a>2.2 术语定义</h3><p>hotspot 常用的 GC 类型：</p><ul><li>部分收集：针对堆中某些部分进行垃圾收集<ul><li>Minor GC：也成 Young GC，在新生代进行收集；</li><li>Major GC：也称 Old GC，在老年代进行收集，只有 CMS 的并发收集是这个模式；</li><li>Mixed GC：收集新生代和部分老年代，只有 G1 使用该模式。</li></ul></li><li>整堆收集：Full GC，收集整个堆，包括新生代、老年代、永久代（如果有的话）。</li></ul><blockquote><p>Major GC 通常等价于 Full GC，hotspot 历史悠久，外界对各种名词的解读已经完全混乱了，需要仔细辨别。</p></blockquote><p>接下来将介绍三个常见的垃圾收集算法。</p><h3 id="2-3-标记-清除算法"><a href="#2-3-标记-清除算法" class="headerlink" title="2.3 标记-清除算法"></a>2.3 标记-清除算法</h3><p>标记-清除算法首先标记需要回收的对象，在标记完成后，回收被标记的对象。</p><p>该算法优点是直观简单，但有以下缺点：</p><ul><li>执行效率随需要被回收的对象数量增加</li><li>产生内存碎片</li><li>与 copy on write 机制不兼容，需要引入其他机制弥补</li></ul><p><img src="标记清除.png" alt="标记清除算法"></p><h3 id="2-4-标记-复制算法"><a href="#2-4-标记-复制算法" class="headerlink" title="2.4 标记-复制算法"></a>2.4 标记-复制算法</h3><p>标记-复制算法将内存分为相等的两块 T1 和 T2，每次只使用其中一块，发生 GC 时，将 T1 存活的对象复制到 T2，并回收 T1，交换 T1 和 T2 的角色。</p><p>标记-复制算法解决了标记-清除算法面对大量可回收对象效率低下的问题，但是可用内存缩小了原来的一半，更容易发生 GC，故常用在新生代。</p><p><img src="标记复制.png" alt="标记复制算法"></p><h3 id="2-5-标记-整理算法"><a href="#2-5-标记-整理算法" class="headerlink" title="2.5 标记-整理算法"></a>2.5 标记-整理算法</h3><p>标记-整理算法的标记过程与标记-清除算法相同，但后续不是直接回收对象，而是让存活的对象往一端移动，并清理到边界以外的对象。</p><p><img src="标记整理.png" alt="标记整理算法"></p><p>整理的过程需要 STW，如果内存中只有少量存活对象，那么标记-整理算法既高效又节约内存，常用在老年代。但如果存在大量存活对象，标记-整理算法将十分低效。</p><h2 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3. 垃圾收集器"></a>3. 垃圾收集器</h2><p>接下来将介绍 hotspot 中的垃圾收集器。</p><h3 id="3-1-Serial-和-Serial-Old"><a href="#3-1-Serial-和-Serial-Old" class="headerlink" title="3.1 Serial 和 Serial Old"></a>3.1 Serial 和 Serial Old</h3><p>Serial 是新生代的收集器，使用标记-复制算法，只使用一个线程去完成 GC 工作，并且整个过程需要 STW。</p><p>Serial Old 是老年代的收集器，使用标记-整理算法，其他特点与 Serial 相同。</p><h3 id="3-2-ParNew"><a href="#3-2-ParNew" class="headerlink" title="3.2 ParNew"></a>3.2 ParNew</h3><p>ParNew 是 Serial 的多线程版本，使用多线程在新生代进行 GC，其余均与 Serial 相同，整个过程仍需 STW。</p><h3 id="3-3-Parallel-Scavenge-和-Paralllel-Old"><a href="#3-3-Parallel-Scavenge-和-Paralllel-Old" class="headerlink" title="3.3 Parallel Scavenge 和 Paralllel Old"></a>3.3 Parallel Scavenge 和 Paralllel Old</h3><p>Parallel Scavenge 是新生代的收集器，采用标记-复制算法，关注吞吐量，其中 吞吐量 = 用户代码运行时间 / (用户代码运行时间 + GC 运行时间)，它会根据用户设置的预期吞吐量自行分配堆运行。</p><p>Parallel Old 是 Parallel Scavenge 的老年代版本，采用标记-整理算法。</p><h3 id="3-4-CMS"><a href="#3-4-CMS" class="headerlink" title="3.4 CMS"></a>3.4 CMS</h3><p>Concurrent Mark Sweep，CMS，是一款老年代收集器，基于标记-清除算法，其关注点是 <strong>STW 的时间尽可能短</strong>。</p><p>CMS 的 GC 分为四个过程：</p><ul><li>初始标记：标记 GCRoots 直接引用的对象，需要 STW</li><li>并发标记：遍历引用链进行三色标记，CMS 避免误标的方式是使用增量更新</li><li>重新标记：使用增量更新重新标记，需要 STW</li><li>并发清除：清除所有的对象</li></ul><blockquote><p>在上文收集算法中提出，老年代常使用的标记-整理算法需要 STW。CMS 的关注点是暂停时间，这是 CMS 虽然是老年代收集器，但使用标记-清除算法的原因。</p></blockquote><p><img src="cms.png" alt="CMS GC流程"></p><p>虽然 CMS 带来了极低的暂停时间，但也存在以下问题：</p><ul><li>在 CPU 核心数较低时开销较大，CMS 的回收线程配置为 （处理器核心数量 +3）/4，在低配计算机上 GC 过程会影响用户体验；</li><li>无法处理浮动垃圾，即并发标记和并发删除期间，用户线程产生的垃圾无法在本次 GC 回收；</li><li>采用标记-清除算法带来的内存碎片。</li></ul><h3 id="3-5-G1"><a href="#3-5-G1" class="headerlink" title="3.5 G1"></a>3.5 G1</h3><p>Garbage Firtst，G1，其目标是 <strong>soft real time</strong>，在固定时间内，停顿的时间不超过预期，例如在任意 1s 内，停顿的时间不超过 10ms。</p><p>为了实现可预测的停顿时间，G1 将堆内存化整为零，将堆内存划分为多个大小相同的区域 Region，每个 Region 根据需要可以成为新生代和老年代，并采用不同的策略进行处理。Region 是回收的最小单位，每个 Region 都会根据可回收的空间和回收所需时间维护优先级，优先回收高优先级的 Region。</p><p>由于将堆分为多个 Region，G1 对以下问题进行了额外的处理：</p><ul><li>跨 Region 引用：维护双向卡表，记录每个 Region 的指向和被指向关系；</li></ul><blockquote><p>双向卡表在此处主要是为了便于理解，在 G1 的论文中使用的都是记忆集 Remembered Set 。</p></blockquote><ul><li>三色标记的误删问题：采用原始快照算法实现，并且在标记前设置了 TAMS（Top at Mark Start） 指针，并发标记期间用户线程只能在指针之间的区域创建对象。</li></ul><p>类似 CMS，G1 的 GC 也分为四个过程：</p><ul><li>初始标记：标记 GCRoots 直接引用的对象，设置 TAMS，需要 STW</li><li>并发标记：遍历引用链进行标记，并记录原始快照</li><li>最终标记：根据原始快照重新标记防止误删，需要 STW</li><li>筛选回收：更新 Region 的优先级，将待回收 Region 的存活对象复制到空 Region中，回收整个 Region，需要 STW</li></ul><p><img src="g1.png" alt="G1 GC流程"></p><p>G1 有以下两种模式，并视情况切换：</p><ul><li>Young GC：回收区域为新生代的 Region，初始标记在这个过程执行</li><li>Mixed GC：回收区域为新生代的 Region 和部分高优先级老年代 Region</li></ul><blockquote><p>这不代表 G1 就不进行 Full GC，当 Mixed GC 无法更上内存分配的速度时将触发 Full GC。使用了 G1 的 System.gc() 默认是 Full GC。</p><p>此处强烈推荐关注 RednaxelaFX 的博客，博主对 JVM 的理解非常深入，在博客中介绍了大量实现细节，链接放在参考资料。</p></blockquote><p>限于篇幅，G1 的调优相关可以阅读 <a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html">G1 Tuning</a>。</p><h3 id="3-6-ZGC"><a href="#3-6-ZGC" class="headerlink" title="3.6 ZGC"></a>3.6 ZGC</h3><h4 id="3-6-1-介绍"><a href="#3-6-1-介绍" class="headerlink" title="3.6.1 介绍"></a>3.6.1 介绍</h4><p>Z Garbage Collector，ZGC 是最新的垃圾收集器，采用标记-整理算法，其目标是在对吞吐量影响不大的前提，对于任意堆大小实现停顿时间在 10 ms 以内。官方的定义为可伸缩的低延迟收集器。</p><p><img src="zgc的目标.png" alt="ZGC的目标"></p><blockquote><p>ZGC 刚发布时仅支持在 64 bit Linux 下使用，java 14 提供了对 Windows 和 macOS 的支持。下文将以 Linux 上的 ZGC 进行介绍。</p></blockquote><p>与 G1 类似，ZGC 将堆分为小型 Region（4MB）、中型 Region（32MB）、大型 Region。</p><h4 id="3-6-2-染色指针和读屏障"><a href="#3-6-2-染色指针和读屏障" class="headerlink" title="3.6.2 染色指针和读屏障"></a>3.6.2 染色指针和读屏障</h4><p>ZGC 的关键在于虽然使用了标记-复制算法，但是移动对象的过程不需要 STW，即并发转移。</p><p>ZGC 通过着色指针和读屏障技术实现并发转移。并发转移过程中 GC 线程在转移对象的时候，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。在 ZGC 中，应用线程访问对象将触发读屏障，如果对象被移动了，读屏障将会把读出来的指针更新到对象的新地址上。应用线程始终访问的都是对象的新地址，而不需要 STW 来让 GC 和应用之间同步。</p><h5 id="染色指针"><a href="#染色指针" class="headerlink" title="染色指针"></a>染色指针</h5><p>ZGC 的一大特点是使用了染色指针，相比于 G1 使用额外的空间记录三色标记，ZGC 直接将其记录在堆中对象的指针上。Linux 中 64 bit 的指针只使用了低 46 位，而 ZGC 将 46 位中的高 4 位用于标记，可见 ZGC 只能够管理 4 TB 堆空间，其中高 4 位的使用如下图所示。</p><p><img src="染色指针.png" alt="ZGC的染色指针技术"></p><p>由上面分布可知，虚拟地址 [0，4TB）、[4，8TB）、[8，12TB）、[16，20TB）分别对应 Java 程序的虚拟地址、Marked0、Marked1、Remapped 视图。当程序对象时，在堆中申请一个虚拟地址，该地址不会映射到物理地址，而是为该对象在 Marked0、Marked1、Remapped 分别申请一个虚拟地址，并且映射到同一块内存，效果如下图所示。三个视图的切换在下文介绍。</p><p><img src="内存映射.png" alt="ZGC的内存映射技术"></p><h5 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h5><p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。</p><p>读屏障用于在对象标记和移动对象过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。</p><p><img src="读屏障.png" alt="读屏障"></p><h4 id="3-6-3-地址视图切换"><a href="#3-6-3-地址视图切换" class="headerlink" title="3.6.3 地址视图切换"></a>3.6.3 地址视图切换</h4><p>ZGC 的回收周期如下图所示，其中只有 初始阶段、再标记、初始转移是 STW 的。</p><p><img src="zgc周期.png" alt="ZGC GC周期"></p><p>在一个周期中的地址视图切换（更新指针）过程如下：</p><ul><li>初始化：整个地址空间被设置为 Remapped，满足 GC 条件后进入标记阶段；</li><li>并发标记：如果对象被标记线程或者用户线程访问过（即被引用），则从 Remapped 改为 Marked0。标记结束后，如果对象地址是 Marked0 视图，则该对象存活，为 Remapped 则该对象是不活跃的，内存可以被回收；</li><li>并发转移：标记结束后就进入转移阶段，此阶段如果对象被转移，则从 Marked0 改为Remapped。</li></ul><p>上述过程仿佛只用到了 Marked0，那么 Marked1 在何处使用呢？Marked0 和 Marked1 主要用于区分前一次标记和当前标记，第二次进入并发标记阶段后，地址视图将改为 Marked1。对象 0 所在的页面要被回收，需要转移，对象 2 所在的页面不用被回收，不需要转移。对象 0 转移过后它的视图改为 Remapped，对象 2 仍为 Marked0。那么下一次垃圾回收标记阶段开始的时候，存在两种地址视图，Remapped 和 Marked0，如果本次标记仍然使用 Marked0 这个地址视图，那么就不能区分出对象是活跃的，还是上一次标记过的。所以新标记阶段使用了另外一个地址视图 Marked1，标记结束后所有活跃对象的地址视图都为 Marked1。</p><blockquote><p>具体算法实现可见 《新一代垃圾回收器ZGC设计与实现》第 4 章。</p></blockquote><p><img src="视图转变.png" alt="ZGC GC过程的视图转变"></p><p>此时三个视图代表的含义为：</p><ul><li>Marked1：本次 GC 识别的活跃对象。</li><li>Marked0：前一次垃圾回收的标记阶段被标记过的活跃对象，对象在转移阶段未被转移，但是在本次垃圾回收中被识别为不活跃对象。</li><li>Remapped：前一次垃圾回收的转移阶段发生转移的对象或者是被应用程序线程访问的对象，但是在本次垃圾回收中被识别为不活跃对象。</li></ul><h2 id="4-总结图"><a href="#4-总结图" class="headerlink" title="4. 总结图"></a>4. 总结图</h2><p><img src="总结.png" alt="总结导图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/26821357/">垃圾回收的算法与实现</a></li><li><a href="https://www.zhihu.com/question/41922036">Major GC和Full GC的区别是什么？ RednaxelaFX的回答</a></li><li><a href="https://www.iteye.com/blog/rednaxelafx-362738">RednaxelaFX的博客</a></li><li><a href="https://hllvm-group.iteye.com/group/topic/44381#post-272188">G1 GC的讨论</a></li><li><a href="https://openjdk.java.net/jeps/365">JEP 365</a></li><li><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">美团团队 新一代垃圾回收器ZGC的探索与实践</a></li><li><a href="https://book.douban.com/subject/34812818/">新一代垃圾回收器ZGC设计与实现</a></li><li><a href="https://www.youtube.com/watch?v=88E86quLmQA&amp;t=1663s">ZGC: The Next Generation Low-Latency Garbage Collector</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(2) 类加载</title>
      <link href="/2022/02/09/JVM%E7%B3%BB%E5%88%97(2)%20%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2022/02/09/JVM%E7%B3%BB%E5%88%97(2)%20%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1. 类加载过程"></a>1. 类加载过程</h2><p>在程序运行期间，JVM 把描述类的数据从 class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的类型，这个过程被称为虚拟机的类加载机制。</p><p>一个类型从被加载开始，到被卸载出内存为止，其生命周期会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析三个过程合称为连接，如下图所示。</p><p><img src="生命周期.png" alt="类的生命周期"></p><p>类加载包含上述加载、连接和初始化三个阶段，下面将逐个进行介绍。</p><h3 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h3><p>加载是使用类的全限定名<strong>读取该类的二进制流</strong>，将其转换为<strong>某种特定的数据结构</strong>存储在<strong>方法区</strong>，并在<strong>堆</strong>中生成一个供用户调用的 <strong>java.lang.Class</strong> 类型的对象的过程。</p><p>上面加粗的部分为加载的关键点：</p><ul><li>类的二进制流不限定本地的 class 文件，可以来源于网络；</li><li>在方法区的数据结构即为 klass 对象；</li><li>堆中的 java.lang.Class 类型的对象是方法区的访问入口。</li></ul><h3 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h3><p>验证是连接阶段的第一步，目的是保证字节流中的信息符合虚拟机规范的约束，大致上会分为以下阶段，并 <strong>分散在各个阶段</strong> ：</p><ul><li>文件格式验证：验证字节流是否符合 class 文件的格式，例如魔数、版本号等，文件格式验证发生在加载阶段获取字节流之后，验证通过才能完成加载；</li><li>元数据验证、字节码验证：验证字节流来确定程序语意正确性，并且不会危害虚拟机；</li><li>符号引用验证：检验该类是否缺少或者禁止访问它依赖的某些外部类、方法和字段等资源，主要目的是确保解析的正常执行，发生在解析阶段内。</li></ul><h3 id="1-3-准备"><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h3><p>准备为类中的 <strong>静态变量</strong> 分配内存并设置初值，例如下面的静态变量，在准备阶段后 value 的值为 0，flag 的值为 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> bool flag = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>但如果虚拟机判断为常量，则会给赋予常量值，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>; <span class="comment">// 准备阶段后值为123</span></span><br></pre></td></tr></table></figure><h3 id="1-4-解析"><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h3><p>解析将 class 文件中与内存分布无关的符号引用（常量池的索引）转化为直接引用（内存地址）。解析在类加载中的顺序规范中没有明确规定，可以由虚拟机自行实现。</p><p>例如类 A 引用了类 B，在编译时，A 是无法得知 B 的地址的，故只能采用符号引用存储。当程序运行时触发 A 的类加载时，在解析阶段会发现 B 未被加载，将触发 B 的类加载，将类 B 加载到虚拟机中，此时就可以利用类 B 的实际地址来替换符号引用了。</p><p>但事情并没有这么简单，当 B 是个具体实现类时，会按照上述的过程执行，称为静态解析。如果 B 是个抽象类或者接口，当 B 有多个实现类例如 C、D、E，此时 A 无法明确具体实现类，将等到发生调用时，根据栈中的具体类型信息将符号引用替换为具体实现类的地址，这被称为动态解析。</p><p><img src="静态解析和动态解析.png" alt="静态解析和动态解析"></p><h3 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h3><p>执行类中的主动资源初始化动作，例如成员变量的赋值、静态变量的赋值、静态代码块等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class Test &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图为类加载的流程，实线代表类加载的实际流程，虚线表示属于关系。</p><p><img src="类加载流程.png" alt="类加载流程"></p><h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h2><h3 id="2-1-类与类加载器"><a href="#2-1-类与类加载器" class="headerlink" title="2.1 类与类加载器"></a>2.1 类与类加载器</h3><p>加载过程中根据类限定名获得字节流的动作放到虚拟机外，由应用程序自行决定如何获取类，实现这个动作的代码被称为类加载器。</p><p>一个类由加载它的类加载器和类自身确定在虚拟机中的唯一性，每个类加载器都有自己的命名空间。换句话说，两个类相同的条件是，其 class 文件相同，并且被同一个类加载器加载。</p><h4 id="2-2-双亲委派模型"><a href="#2-2-双亲委派模型" class="headerlink" title="2.2 双亲委派模型"></a>2.2 双亲委派模型</h4><p>对于 jdk 1.8 及以前的版本，绝大多数 Java 程序会使用下列 3 个系统提供的类加载器：</p><ul><li>Bootstrap Class Loader：启动类加载器，使用 C++ 实现，是虚拟机的一部分。负责加载 rt.jar 等 jdk 库；</li><li>Extension Class Loader：拓展类加载器，负责加载 <JAVA_HOME>\lib\ext 目录下的类；</li><li>Application Class Loader：应用程序/系统类加载器，负责加载用户实现的类。</li></ul><blockquote><p>说明：虚拟机规范对类加载器只分为启动类加载器和非启动类加载器，上述分类是 hotspot 的实现。</p></blockquote><p>除了上面 3 个类加载器，用户可以加入自定义的类加载器进行拓展。</p><p><img src="双亲委派模型.png" alt="双亲委派模型"></p><p>上图各种类加载器的层次关系被称为 双亲委派模型（Parents Delegation Model），在 jdk 1.2 引入。其工作流程分为向上委托和向下委派，类加载器收到加载请求时，向上委托给父加载器加载，当父加载器无法完成加载，向下委派给子加载器尝试加载。</p><p>双亲委派模型的优点是例如 java.lang.Object 等核心类，无论被哪个类加载器加载，最终都会委派给启动类加载器，用于保证保证 Java 程序的正确运行。用户即使自定义了一个 java.lang.Object 类，对程序也无法造成影响。同时，类加载器都会向上委托加载，也避免了类的重复加载问题。</p><p>双亲委派的逻辑位于 java.lang.ClassLoader 的 loadClass 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 检查类是否被加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// parent = null 即为启动类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 抛出异常则上层加载器无法完成加载，c = null</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用自身的类加载机器</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类加载器之间所谓的父子关系不是通过继承获得，更像是通过优先级决定，上层的类加载拥有更高的优先级，优先进行加载。双亲委派的双亲是翻译问题，从实际体现上来看，称为 父辈委派模型 更为直观贴切。</p></blockquote><h3 id="2-3-破坏双亲委派模型"><a href="#2-3-破坏双亲委派模型" class="headerlink" title="2.3 破坏双亲委派模型"></a>2.3 破坏双亲委派模型</h3><p>在 Java 历史上，主要有 3 次对双亲委派模型的破坏。</p><p>第一次是为了兼容性，由于双亲委派模型在 jdk 1.2 后才引入，之前版本已经存在大量自定义类加载器。这些类加载器通过重写 loadClass 方法实现自己的加载逻辑，双亲委派的逻辑都在 loadClass 方法中，所以不会遵守后来版本才出现的 “规范”。对于 Java 团队做出了一定妥协，在 java.lang.ClassLoader 中添加 findClass 方法，并推荐用户重写该方法来实现类加载逻辑。</p><p><img src="第一次破坏双亲委派.png" alt="为了兼容性破坏双亲委派模型"></p><p>第二次是由于双亲委派的缺陷，一个典型例子是数据库的 Driver 接口，该接口定义在 jdk 源码中（rt.jar）由启动类加载器加载，但接口由数据库厂商实现， 实现类存放在 classpath 目录下，由系统类加载器加载，启动类加载器无法加载这些类，无法加载驱动。为此引入了线程上下文加载器，一般情况下就是系统类加载器，Driver 服务通过线程类加载器去加载类，这是一种父类加载器委托子类加载器的行为，违背了双亲委派模型。</p><p><img src="第二次破坏双亲委派.png" alt="SPi破坏双亲委派模型"></p><p>第三次是用户对热替换、热部署的追求，限于篇幅在此处不进行介绍。</p><p>从上文，我们也知道了在 jdk 1.8 中破坏双亲委派的手段：</p><ul><li>自定义类加载器，重写 loadClass 方法，不进行双亲委派机制</li><li>使用线程上下文加载器</li></ul><blockquote><p>除非有特殊的业务需求，否则不推荐破坏双亲委派模型。</p></blockquote><h2 id="3-总结图"><a href="#3-总结图" class="headerlink" title="3. 总结图"></a>3. 总结图</h2><p><img src="总结.png" alt="总结导图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></p></li><li><p><a href="https://book.douban.com/subject/26418340/">Java虚拟机规范(JavaSE 8版)</a></p></li><li><p><a href="https://www.bilibili.com/video/BV14U4y1L75q?spm_id_from=333.999.0.0">Java类加载机制这块算是玩明白了</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1X5411K7cw?spm_id_from=333.999.0.0">Java双亲委派、类加载器这块算是玩明白了</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1RP4y1E7pA?spm_id_from=333.999.0.0">JVM第一弹</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(1) Java内存区域</title>
      <link href="/2022/02/09/JVM%E7%B3%BB%E5%88%97(1)%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2022/02/09/JVM%E7%B3%BB%E5%88%97(1)%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JVM简介"><a href="#1-JVM简介" class="headerlink" title="1. JVM简介"></a>1. JVM简介</h2><p>Java Virutal Machine，JVM，Java 虚拟机，是用于执行字节码的虚拟计算机。</p><p>JVM 是 Java 平台的基石，是实现硬件无关和平台无关的关键部分，是字节码的运行平台。它与 Java 语言没有必然联系，只与特定的 class 文件格式所关联，并且遵守自己的虚拟机规范。</p><p>目前最主流的虚拟机是 Oracle 的 hotspot。</p><h2 id="2-Java内存区域"><a href="#2-Java内存区域" class="headerlink" title="2. Java内存区域"></a>2. Java内存区域</h2><h3 id="2-1-运行时数据区"><a href="#2-1-运行时数据区" class="headerlink" title="2.1 运行时数据区"></a>2.1 运行时数据区</h3><p>JVM 规范定义了若干程序运行期间会使用到的运行数据区，如下图所示。</p><p><img src="运行时数据区.png" alt="运行时数据区"></p><p>运行时数据区：</p><ul><li>程序计数器：线程私有，记录线程执行上下文。程序的分支、异常处理、线程切换等工作依赖这个计数器完成；</li><li>Java 虚拟机栈：线程私有，生命周期和线程相同。每个方法执行时，都会栈中创建一个栈帧，用于存储局部变量、方法调用等，方法调用结束则回收栈帧。如果栈深度溢出抛出 StackOverflowError，无法申请到足够内存则抛出 OutOfMemoryError；</li><li>本地方法栈：线程私有，与虚拟机栈类似，但用于本地方法调用，同样也会抛出 StackOverflowError 和 OutOfMemoryError；</li><li>堆：线程共享，对象分配内存的区域，溢出抛出 OutOfMemoryError；</li><li>方法区：线程共享，存储类元信息、常量、静态变量等，溢出抛出 OutOfMemoryError。</li></ul><p>除了运行时数据区外，JVM 还管理直接内存。直接内存不属于运行时数据区，它是 jvm 所属进程的内存，即操作系统给该进程分配的堆空间，溢出抛出 OutOfMemoryError。</p><h3 id="2-2-永久代和元空间"><a href="#2-2-永久代和元空间" class="headerlink" title="2.2 永久代和元空间"></a>2.2 永久代和元空间</h3><p>方法区是虚拟机规范中所定义的内存区域，在具体的虚拟机上实现可能不同。</p><p>永久代是早期 hotspot 对方法区的实现，包含类元数据、字符串常量池、静态变量等，在 jdk 1.7 后字符串常量池和静态变量被移动到堆中。</p><p>永久代可以将垃圾收集自然拓展到方法区，减少了 hotspot 团队的工作量，但是存在以下问题：</p><ul><li>永久代的内存较少回收，并且和老年代关联垃圾回收，容易触发 Full GC;</li><li>永久代的概念只属于 hotspot，对合并 hotspot 和其他虚拟机造成阻碍。 </li></ul><p>对于永久代的问题，在 jdk 1.8 后，hotspot 团队放弃了永久代，而是采用元空间来代替永久代，元空间存放在直接内存中，更不易出现 OutOfMemoryError。</p><h2 id="3-对象存储"><a href="#3-对象存储" class="headerlink" title="3. 对象存储"></a>3. 对象存储</h2><h3 id="3-1-对象访问"><a href="#3-1-对象访问" class="headerlink" title="3.1 对象访问"></a>3.1 对象访问</h3><p>对于堆中的对象，虚拟机主要有两种访问方式：</p><ul><li><p>句柄访问：堆中划分出句柄池，引用存储对象的句柄，句柄包含对象实例数据指针和类型数据指针。优点是对象移动时只需要改变句柄的实例数据指针。</p><p><img src="句柄访问.png" alt="句柄访问"></p></li><li><p>直接指针访问：引用直接存储对象地址，在堆中的对象实例中存储了实例数据和指向类型的指针，优点是少一次指针定位。</p><p><img src="直接指针访问.png" alt="直接指针访问"></p></li></ul><p>hotspot 采用直接指针访问的方式。</p><h3 id="3-2-内存分布"><a href="#3-2-内存分布" class="headerlink" title="3.2 内存分布"></a>3.2 内存分布</h3><p>在 hotspot 虚拟机中，对象在堆内存中的内存分布可以划分为 3 个部分：</p><ul><li><p>对象头，主要包含：</p><ul><li><p>Mark Word：记录对象自身的运行时数据，64 位虚拟机的 Mark Word 内容如下图所示。</p><p><img src="markword.png" alt="Mark Word"></p></li><li><p>类型指针：指向类元数据的指针，JVM 通过指针定位方法区中的 klass 对象。</p></li></ul></li><li><p>实例数据：存储对象的属性内容，即各种类型字段的值；</p></li><li><p>对齐填充：hotspot 虚拟机要求对象大小是 8 字节的整数倍。</p></li></ul><p>hotspot 基于 oop-klass 模型来描述一个对象，oop 指普通对象指针 ordinary object pointer，指向类实例数据的内存地址；klass 是方法区中类元信息的运行时数据结构，记录了类的继承信息、成员方法、构造函数等，日常开发使用的 Class 对象可以理解为指向方法区 klass 对象的指针。</p><blockquote><p>对 oop-klass 的具体分析可见《揭秘Java虚拟机》第 5 章。</p></blockquote><p>以下代码的 oop-klass 模型如图所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Model</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    Model modelA = <span class="keyword">new</span> Model(<span class="number">2</span>);</span><br><span class="line">    Model modelB = <span class="keyword">new</span> Model(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="oop-klass.png" alt="oop-klass举例"></p><blockquote><p>此图存在一定问题，在 jdk 1.7 之后，静态变量被移动到堆中，故图中的 a 变量应该位于堆而不是方法区。</p></blockquote><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>上文主要介绍了虚拟机的内存是如何划分的，以及相应区域溢出时会产生的异常。除此之外，还介绍了对象在堆中的内存分布和访问手段。本文的思维导图如下：</p><p><img src="总结.png" alt="总结导图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/26418340/">Java虚拟机规范(JavaSE 8版)</a></li><li><a href="https://book.douban.com/subject/27086821/">揭秘Java虚拟机</a></li><li><a href="https://www.cnblogs.com/thiaoqueen/p/9314745.html">对象的创建和OOP-Klass模型</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈MySQL的索引</title>
      <link href="/2022/02/08/%E6%B5%85%E8%B0%88MySQL%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/02/08/%E6%B5%85%E8%B0%88MySQL%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1. B+树"></a>1. B+树</h2><p>关系型数据库的表类似 Excel，但与表格不同的时，它还提供了索引、事务等额外的机制，其中索引是数据库的一个关键点。</p><p>索引是为了提高查询速度而出现的，查询主要有等值查询和范围查询。一个直观的想法是使用哈希表实现索引，哈希表可以实现 O(1) 查找复杂度，但是对于范围查询，哈希表需要遍历所有数据。</p><p>另一个想法是使用有序数组，通过二分查找的方式，等值查询和范围查询都能在 O(logn) 复杂度下完成。但是一个问题也紧接而来，当在表中插入数据时，有序数组需要进行 O(n) 时间复杂度的元素移动，显然不适合实现索引。</p><p>于是我们想到另一个综合了查询和修改功能的数据结构，二叉搜索树，它可以在 O(logn) 复杂度下完成查询和修改操作，看起来已经十分完美。但这仍有一个问题，二叉搜索树在内存这表现优异，那在磁盘中呢？磁盘的 IO 次数直接由树的高度决定，而表中存有几万甚至几十万行的数据是一件常事，每次查询都需要经过多次 IO，依旧十分耗时。</p><p>说了这么多，终于引出我们的主角，B+ 树。B+ 树可以看成一个多叉搜索树，其中每个节点都是有序的，并且只有叶节点存储数据，非叶节点进行不存储，非叶节点能够存放大量索引，大幅度降低树的高度。除此之外，叶节点连接形成有序链表，可以实现范围查询。</p><blockquote><p>B+ 树还吻合操作系统按块读取磁盘和预读的特性。</p></blockquote><p><img src="b+树.png" alt="B+树"></p><h3 id="2-MySQL中的索引"><a href="#2-MySQL中的索引" class="headerlink" title="2. MySQL中的索引"></a>2. MySQL中的索引</h3><h3 id="2-1-索引类型"><a href="#2-1-索引类型" class="headerlink" title="2.1 索引类型"></a>2.1 索引类型</h3><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>根据底层数据结构实现，MySQL 提供了 4 种索引类型：</p><ul><li>BTREE 索引：最常见的索引类型，大部分引擎都支持该索引</li><li>HASH 索引：查找速度快，但只有 Memory 引擎支持，无法用于排序</li><li>Full-text 索引：全文索引，是 MyISAM 的一个特殊索引类型，主要用于大本文搜索，InnoDB 在 MySQL 5.6 后支持</li><li>R-tree 索引：又称空间索引，主要用于地理空间数据，使用较少</li></ul><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引根据值能否重复可以分为：</p><ul><li><p>非唯一索引：索引的值可以重复</p></li><li><p>唯一索引：索引的值必须唯一，但可以存在多个 null，可以通过以下方式创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX key_name ON table_name(col_name);</span><br></pre></td></tr></table></figure></li></ul><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>索引根据包含列的数量又可分为：</p><ul><li>单值索引：一个索引只包含一个列</li><li>联合索引：将多个列联合，并根据列出现的顺序进行排序。例如索引 (a，b，c)，会先根据 a 进行排序，a 相同的情况再根据 b 排序，最后根据 c 排序。</li></ul><h3 id="2-2-聚簇索引"><a href="#2-2-聚簇索引" class="headerlink" title="2.2 聚簇索引"></a>2.2 聚簇索引</h3><h4 id="2-2-1-介绍"><a href="#2-2-1-介绍" class="headerlink" title="2.2.1 介绍"></a>2.2.1 介绍</h4><p>聚簇索引是 InnoDB 的一个特点，聚簇索引会将数据存放在叶子节点，并且一个表只能有一个聚簇索引，通常为主键。其他的索引称为二级索引，二级索引会在叶节点存储自身和主键。</p><p>通过主键查询数据时，访问到索引叶节点即可获取数据；而通过二级索引查询数据，访问到索引叶节点只能拿到主键，需要利用主键和聚簇索引再进行查找，这一过程称为回表。</p><p>用户可以自定义一个聚簇索引，未指定的话 InnoDB 会将主键列为聚簇索引，不存在主键则会定义一个隐式自增主键 row_id。 </p><h4 id="2-2-2-聚簇索引的优缺点"><a href="#2-2-2-聚簇索引的优缺点" class="headerlink" title="2.2.2 聚簇索引的优缺点"></a>2.2.2 聚簇索引的优缺点</h4><p>优点：</p><ul><li>叶节点直接存储数据，磁盘 I/O 少</li></ul><p>缺点：</p><ul><li>更新和非顺序插入数据可能导致页分裂，效率低</li><li>降低了二级索引的查询效率</li></ul><h2 id="3-使用索引"><a href="#3-使用索引" class="headerlink" title="3. 使用索引"></a>3. 使用索引</h2><h3 id="3-1-索引失效"><a href="#3-1-索引失效" class="headerlink" title="3.1 索引失效"></a>3.1 索引失效</h3><p>下列场景将导致索引失效：</p><ul><li><p>最左匹配原则：使用联合索引查询，依次根据索引的列顺序查询，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 联合索引为 (name, email, address)</span><br><span class="line"></span><br><span class="line"># 索引生效</span><br><span class="line">select * from user where name = &#x27;bzzb&#x27; and email = &#x27;xx@qq.com&#x27;</span><br><span class="line"># 只用了name索引</span><br><span class="line">select * from user where name = &#x27;bzzb&#x27; and address = &#x27;xx&#x27;</span><br><span class="line"># 索引失效</span><br><span class="line">select * from user where email = &#x27;xx@qq.com&#x27; and address = &#x27;xx&#x27;</span><br></pre></td></tr></table></figure></li><li><p>OR 连接的所有字段没有都含有索引，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 索引为 (name, email, address)</span><br><span class="line"></span><br><span class="line"># nickname不含索引, 索引失效</span><br><span class="line">select * from user where name = &#x27;bzzb&#x27; or nickname = &#x27;zhibin&#x27;</span><br></pre></td></tr></table></figure></li><li><p>模糊匹配 LIKE 中的字符串以 % 开始，因为会匹配所有字符，将导致索引失效；</p></li><li><p>使用不等于（!= 和 &lt;&gt;）只能全表扫描，无法使用索引；</p></li><li><p>存在字符串隐式转换将导致索引失效，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 索引为 (name, email, address)</span><br><span class="line"># 需要将2000转换为字符串&quot;2000&quot;，索引失效</span><br><span class="line">select * from user where name = 2000</span><br></pre></td></tr></table></figure></li><li><p>在索引在的列上进行运算，将导致索引失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 索引为 (name, email, address)</span><br><span class="line"></span><br><span class="line"># 使用了字符串运算，索引失效</span><br><span class="line">select * from user where left(name, 2) = &quot;bz&quot; </span><br></pre></td></tr></table></figure></li></ul><blockquote><p>即使不符合上述的情况，MySQL 的优化器也会根据情况不使用索引，而是进行全表扫描。查询语句是否使用到索引可以使用 explain 查看。</p></blockquote><h3 id="3-2-索引使用建议"><a href="#3-2-索引使用建议" class="headerlink" title="3.2 索引使用建议"></a>3.2 索引使用建议</h3><p>除了避免索引失效，还有以下索引使用建议：</p><ul><li><p>主键设置为自增类型，提高数据插入的效率；</p></li><li><p>对于常用的查询，考虑使用覆盖查询减少回表；</p></li><li>索引列的类型尽量小，类型越小，占用的存储空间更小，单页能放下索引的数目更高；</li><li>只为用于搜索、排序或分组的列创建索引，引入索引虽然提高了查询性能，但也影响数据插入和删除的性能；</li><li>取值较少的列不建议单独建立索引，例如性别，虽然存在根据性别查询的场景，但 MySQL 优化器大概率会进行全表扫描。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/book/6844733769996304392/section/6844733770046636045">MySQL是怎样运行的</a></li><li><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的锁</title>
      <link href="/2022/02/08/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2022/02/08/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>上篇博客 <a href="https://strokebun.github.io/2022/02/08/MySQL的事务隔离级别和MVCC/">MySQL的事务隔离级别和MVCC</a> 介绍了 MySQL 如何使用 MVCC 解决读写冲突，实现事务并发读取数据。那么对于并发修改，MySQL 又采用了什么机制呢？</p><p>MySQL 使用锁来解决并发修改问题，锁结构包含很多信息，其中最主要的有：</p><ul><li>事务信息：记录这个锁由哪个事务生成</li><li>is_waiting：事务是否在等待，值为 false 则该事务获得了锁</li></ul><p>如下图所示，事务 T1 获取到锁，继续执行，而 T2 未得到锁，则进行等待。</p><p><img src="锁结构.png" alt="锁结构"></p><p>当事务 T1 提交之后，会将生成的锁释放，同时检查是否有其他在等待，此时发现事务 T2，将 T2 的锁结构中 is_waiting 属性设置为 false，T2 获得锁继续执行。</p><p>上一篇博客提到，利用 MVCC 读取数据称为一致性锁，相对应的，采用锁读取和更新称为锁定读或者当前读，可以通过以下方式开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT, UPDATE, DELETE # 修改操作</span><br><span class="line">SELECT ... LOCK IN SHARE MODE # 对读取的记录加S锁</span><br><span class="line">SELECT ... LOCK FOR UPDATE # 对读取的记录加X锁</span><br></pre></td></tr></table></figure><h2 id="2-锁分类"><a href="#2-锁分类" class="headerlink" title="2. 锁分类"></a>2. 锁分类</h2><h3 id="2-1-共享和排他锁"><a href="#2-1-共享和排他锁" class="headerlink" title="2.1 共享和排他锁"></a>2.1 共享和排他锁</h3><p>MySQL 中的锁按照性质可以分为：</p><ul><li>共享锁：Shared Locks，简称 S 锁，S 锁与 S 锁兼容，即一个事务获得 S 锁后不释放，其他事务也可获得 S 锁；</li><li>独占锁：Exclusive Locks，简称 X 锁，X 锁与 X 锁、S 锁都不兼容。也就是说，一个事务获得 X 锁之后，其他事务无法获得 S 锁获得 X锁；一个事务获得 S 锁后，其他事务也无法获得 X 锁。</li></ul><h3 id="2-2-多粒度锁"><a href="#2-2-多粒度锁" class="headerlink" title="2.2 多粒度锁"></a>2.2 多粒度锁</h3><p>MySQL 为了提高并发程度，提出了多粒度锁，分为全局锁、表锁和行锁。</p><h4 id="2-2-1-全局读锁"><a href="#2-2-1-全局读锁" class="headerlink" title="2.2.1 全局读锁"></a>2.2.1 全局读锁</h4><p>全局锁即对整个数据库加锁，MySQL 提供了一个加全局读锁的命令，即 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure><p>整个库将处于只读状态，典型使用场景是做全库备份。</p><h4 id="2-2-2-表级锁"><a href="#2-2-2-表级锁" class="headerlink" title="2.2.2 表级锁"></a>2.2.2 表级锁</h4><p>MySQL 表级锁以下类型：</p><ul><li><p>表锁：对整个表添加 S 锁或者 X 锁，开启方式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock tables ... read # 添加表级S锁</span><br><span class="line">lock tables ... write # 添加表级X锁</span><br></pre></td></tr></table></figure></li><li><p>元数据锁：metadata lock，MDL，用于保证读写的正确性，会默认添加。增删改查时会加 MDL 读锁，修改表结构（添加/删除列、添加索引等）时会加 MDL 写锁，保证在表结构修改时进行数据读写的正确性；</p></li><li><p>AUTO-INC 锁：在某列添加 AUTO_INCREMENT 属性之后，执行插入语句时会在表级别添加该锁</p></li></ul><blockquote><p>对于 MyISAM、MEMORY 等存储引擎而言，只支持表级锁。</p></blockquote><h2 id="3-行锁"><a href="#3-行锁" class="headerlink" title="3. 行锁"></a>3. 行锁</h2><p>本文最重点的部分是行锁。行锁也称记录锁，顾名思义加在某行记录上的锁，InnoDB 由于支持行锁和事务，成为最常被使用的存储引擎。</p><h3 id="3-1-两阶段协议"><a href="#3-1-两阶段协议" class="headerlink" title="3.1 两阶段协议"></a>3.1 两阶段协议</h3><p>MySQL 是怎么管理锁的呢？这就需要提到两阶段协议，例如下图的操作，事务 B 的 update 操作会阻塞，直到事务 A 提交之后才继续执行。</p><p><img src="两阶段协议.png" alt="两阶段锁协议"></p><p>两阶段锁协议指的是，InnoDB 事务中行锁是在需要的时候才加上，但不是立马释放，并且等到事务结束释放所有的锁。根据这个协议，当我们的事务需要锁多个行时，要尽量把会导致锁冲突的操作往后放。</p><h3 id="3-2-行锁类型"><a href="#3-2-行锁类型" class="headerlink" title="3.2 行锁类型"></a>3.2 行锁类型</h3><p>在解释各种行锁之前，先定义数据库含有以下数据。</p><p><img src="数据.png" alt="数据定义"></p><p>常见的行锁类型有：</p><ul><li><p>Record Locks：分为 S 锁和 X 锁，仅锁住一条记录，示意图如下：</p><p><img src="record_lock.png" alt="Record Lock"></p></li><li><p>Gap Locks：间隙锁，在 Repeatalbe Read 级别下生效，锁定该行记录与之前记录的间隙，用来解决幻读问题。</p><p><img src="gap_lock.png" alt="Gap Lock"></p><p>给 number 为 8 的行加了间隙锁后，则其它事务无法在 (3，8) 这个区间插入新记录。</p></li><li><p>Next-Key Locks：Record Locks + Gap Locks，既锁出该行，也锁住间隙，是前开后闭区间；</p></li><li><p>Insert Intetion Locks：插入意向锁，当一个事务想插入数据的位置被加了 Gap Locks 时，需要在内存中生成一个锁结构，表明想在某个间隙插入新记录，但是现在在等待。</p></li></ul><blockquote><p>间隙锁的引入，虽然解决了幻读问题，但同时也降低了并发度。为了提高并发度可以选择将隔离级别改为 Read Commited，同时将 binlog 格式设置为 row 解决数据和日志不一致的问题。</p></blockquote><h3 id="3-3-加锁规则"><a href="#3-3-加锁规则" class="headerlink" title="3.3 加锁规则"></a>3.3 加锁规则</h3><p>上文介绍了各种行锁，那么 MySQL 是根据什么规则加锁的呢？</p><p>其加锁规则如下：</p><ul><li>原则 1：加锁的基本规则是 Next-Key Lock；</li><li>原则 2：查找过程中访问到的数据才会加锁；</li><li>优化 1：索引上的等值查询，给唯一索引加锁时，改为行锁 Record Lock；</li><li>优化 2：索引上的等值查询，向右遍历且最后一个不满足等值条件时，改为 Gap Lock；</li><li>一个例外：唯一索引的范围查询会访问到第一个不满足条件的值；</li></ul><p>假设有以下数据：</p><div class="table-container"><table><thead><tr><th style="text-align:center">id(primar  key)</th><th style="text-align:center">c (key)</th><th style="text-align:center">d</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">10</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">15</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">20</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">25</td><td style="text-align:center">25</td></tr></tbody></table></div><h4 id="案例1：等值查询间隙锁"><a href="#案例1：等值查询间隙锁" class="headerlink" title="案例1：等值查询间隙锁"></a>案例1：等值查询间隙锁</h4><p><img src="案例1.png" alt="等值查询间隙锁"></p><p>根据加锁规则判断：</p><ul><li>根据原则 1，会给 (5，10] 加上 Next-Key Lock；</li><li>根据优化 2：表中不存在 id = 7 的数据，向右遍历到最后一个不满足等值条件的数据 id = 10，改为 Gap Lock，所以会给  (5，10）添加 Gap Lock。</li></ul><p>根据上述分析，由于间隙锁事务 B 会阻塞直到 A 释放，而事务 C 不影响执行。</p><h4 id="案例2：-非唯一索引等值锁"><a href="#案例2：-非唯一索引等值锁" class="headerlink" title="案例2： 非唯一索引等值锁"></a>案例2： 非唯一索引等值锁</h4><p><img src="案例2.png" alt="非唯一索引等值锁"></p><ul><li>根据原则 1， 给 (0，5] 添加 Next-Key Lock；</li><li>由于 c 是普通索引，故根据优化 2，需要向右遍历直到 c = 10，因此需要给 (5，10) 加 Gap Lock；</li><li>根据原则 2，访问到的数据才会加锁，这个查询不访问主键索引，故主键索引没有锁。</li></ul><p>根据上述分析，事务 A 的锁不影响事务 B 执行，事务 C 需要插入 (7，7，7)，将会被事务 A 的间隙锁 (5，10) 锁住。</p><p>其余分析可见 <a href="https://time.geekbang.org/column/article/75659">为什么我只改一行语句，锁这么多</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/book/6844733769996304392/section/6844733770071801864">MySQL是怎样运行的：锁</a></li><li><a href="https://time.geekbang.org/column/article/69862">MySQL实战45讲</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的事务隔离级别和MVCC</title>
      <link href="/2022/02/08/MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8CMVCC/"/>
      <url>/2022/02/08/MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8CMVCC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-事务隔离级别"><a href="#1-事务隔离级别" class="headerlink" title="1. 事务隔离级别"></a>1. 事务隔离级别</h2><p>在数据库事务中有隔离性的特性，在某个事务对数据库进行访问时，其他事务应该等待这个事务完成才能访问这个数据。但这样的处理使数据访问完全串行化，严重影响性能，故数据库提供了不同的隔离级别，用户可以结合业务需求选择。</p><h3 id="1-1-事务并发执行的问题"><a href="#1-1-事务并发执行的问题" class="headerlink" title="1.1 事务并发执行的问题"></a>1.1 事务并发执行的问题</h3><p>访问相同数据的事务在不保证串行执行的情况下可能遇到以下问题。</p><ul><li><p>脏写：一个事务修改了另一个未提交事务修改过的数据；</p></li><li><p>脏读：一个事务读到了另一个未提交事务修改过的数据；</p></li><li><p>不可重复读：一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值；</p><p><img src="不可重复读.png" alt="不可重复读举例"></p><p>如上图，在事务 B 中提交了几个事务（不可重复读针对的是已提交事务，读到未提交事务的数据是脏读），修改了 number 为 1 对应的 name 值，如果事务 A 都能查到最新的值，就称为不可重复读。</p></li><li><p>幻读：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录（要求是插入，如果是删除仍为不可重复读），原先的事务再次按照该条件查询时，能把插入的新记录也读出来。</p><p><img src="幻读.png" alt="幻读举例"></p><p>事务 A 首先根据 number &gt; 0 的条件查询，得到一条结果，之后事务 B 向表中插入新数据并提交，如果事务 A 使用相同的查询，得到不只一条数据，则称为幻读。</p></li></ul><h3 id="1-2-事务隔离级别"><a href="#1-2-事务隔离级别" class="headerlink" title="1.2 事务隔离级别"></a>1.2 事务隔离级别</h3><p>上文提到的问题根据严重性排序为 脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读，由于脏写问题过于严重，无法容忍，必须避免，而对于其他三种问题 SQL 标准设立了不同的隔离级别：</p><ul><li>Read Uncommited：读未提交。一个事务未提交时，做的变更能被其他事务看到；</li><li>Read Commited：读已提交。一个事务提交之后，做的变更才能被其他事务看到，可以解决脏读问题；</li><li>Repeatable Read：可重复读。一个事务执行过程中，看到的数据是一致的，可解决脏读、不可重复读问题；</li><li>Serializable：串行化。对于同一行记录会加锁，可解决脏读、不可重复读、幻读问题。</li></ul><blockquote><p> MySQL 支持上面 4 种隔离级别，但与标准不同的是，MySQL 使用了间隙锁，在 Repeatable Read 级别下，可以解决幻读问题。MySQL 默认使用的隔离级别是 Repeatable Read。</p></blockquote><h2 id="2-MVCC"><a href="#2-MVCC" class="headerlink" title="2. MVCC"></a>2. MVCC</h2><p>MVCC，Multi-Version Concurrency Control，多版本并发控制，在 InnoDB 存储引擎中用于提高数据库并发性能，针对于读写冲突，用非阻塞读的方式获取数据。</p><blockquote><p>MVCC 只针对普通 SELECT 生效，对于加锁的读取不生效。利用 MVCC 读取数据被称为一致性读。</p></blockquote><h3 id="2-1-版本链"><a href="#2-1-版本链" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><p>对于 InnoDB 引擎而言，其每行包含两个隐藏列：</p><ul><li><p>trx_id：每次一个事务对某行进行改动时，会将该事务 id 赋值给这个隐藏列</p></li><li><blockquote><p>事务 id 不是事务启动时生成的，而是在事务对行数据进行改动时生成。</p></blockquote></li><li><p>roll_pointer：回滚指针，每次对某行改动时，将旧版本写入 undo log 中，并将这个列指向之前按的数据</p><blockquote><p>undo log 会用来记录每次修改前的历史值，在 MySQL 中主要用于事务回滚和实现 MVCC。</p></blockquote></li></ul><p>每一行的更新记录会放到一条 undo log 中，包含更新记录和事务 id，并使用 roll_pointer 形成一个链表，称为版本链，下文将会介绍如何使用版本链实现 MVCC。</p><p><img src="版本链.png" alt="版本链"></p><h3 id="2-2-ReadView"><a href="#2-2-ReadView" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>对于 Read Uncommited 级别的事务而言，读取版本链中最新的数据即可；而对于 SERIALZABLE 级别的事务，读写时都需要进行加锁，那么对于 Read Commited 和 Repeatable Read，就需要读取版本链中特定的版本，那么 MySQL 是如何判断某个版本对于当前事务可不可见呢？</p><p>InnoDB 引入了 Consistent ReadView （下文称作 ReadView）的概念，事务执行某个阶段会生成 ReadView，ReadView 主要包括 4 个内容：</p><ul><li><p>m_ids：生成 ReadView 时当前系统未提交的事务 id 集合；</p></li><li><p>min_trx_id：m_ids 中的最小值，即未提交的事务 id 最小值；</p></li><li><p>max_trx_id：生成 ReadView 时系统应该分配给下一个事务的 id，当前系统已经创建过的事务id+1；</p><p>注：max_trx_id 不是 m_ids 的最大值</p></li><li><p>creator_trx_id：生成该 ReadView 的事务的 id。</p></li></ul><p>再结合上述版本链中每个版本的 trx_id，某个版本对于当前事务是否可见便有以下判断依据：</p><ul><li>trx_id = creator_trx_id，即当前事务在访问自己修改的数据，那么当前事务对该版本可见；</li><li>trx_id &lt; min_trx_id，即生成该版本的事务在当前 ReadView 生成前已经提交，该版本对当前事务可见；</li><li>trx_id &gt;= max_trx_id，即生成该版本的事务在当前 ReadView 生成之后才开启，该版本对当前事务不可见；</li><li>min_trx_id &lt; trx_id &lt; max_trx_id，则需要判断 trx_id 在不在 m_ids 中，在则说明创建 ReadView 时生成该版本的事务还未提交，不可以被当前事务访问，不在则可以访问。</li></ul><p>事务会顺着版本链判断可见性，找到可见的数据为止，如果最后一个版本也不可见，意味该行对该事务不可见，查询结果不含该行记录。</p><h3 id="2-3-生成ReadView的时机"><a href="#2-3-生成ReadView的时机" class="headerlink" title="2.3 生成ReadView的时机"></a>2.3 生成ReadView的时机</h3><p>根据 ReadView，我们可以判断某个版本对事务是否可见，那么 Read Commited 和 Repeatale Read 如何区分呢？关键在于生成 ReadView 的时机。</p><ul><li>Read Commited 级别下每次读取都生成 ReadView；</li><li>Repeatable Read 只在第一次读取时生成 ReadView，之后使用同一个 ReadView，对之后的修改不可见，所以能够实现可重复读。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/book/6844733769996304392/section/6844733770071801870">MySQL是怎样运行的：MVCC篇</a></li><li><a href="http://mysql.taobao.org/monthly/2021/10/01/">Undo log介绍</a></li><li><a href="https://time.geekbang.org/column/article/70562">SQL实战45讲-事务隔离</a></li><li><a href="https://www.cnblogs.com/xuwc/p/13873611.html">MVCC详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计(1): 短域名系统</title>
      <link href="/2022/02/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1(1)%20%E7%9F%AD%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/02/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1(1)%20%E7%9F%AD%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>短域名 TinyURL 是一个在线服务，可以将长的 URL 转化为一个短的 URL 完成重定向。</p><p>微博/Twitter 要求推文限制在 100 多个字符，如果直接使用原始链接，将大幅度限制用户的发表字数；日常使用的二维码是根据字符生成的，长 URL 生成的二维码更加不好识别。</p><p>以上场景导致短域名系统的出现。</p><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><h3 id="2-1-系统输入"><a href="#2-1-系统输入" class="headerlink" title="2.1 系统输入"></a>2.1 系统输入</h3><ul><li>一个冗长的域名</li><li>一个自定义的别名</li><li>一个过期时间</li></ul><h3 id="2-2-系统输出"><a href="#2-2-系统输出" class="headerlink" title="2.2 系统输出"></a>2.2 系统输出</h3><p>自定义别名或者随机生成的短域名，在过期时间到来前访问都可以被重定向到原始的冗长域名上</p><h3 id="2-3-系统要求"><a href="#2-3-系统要求" class="headerlink" title="2.3 系统要求"></a>2.3 系统要求</h3><h4 id="2-3-1-需求"><a href="#2-3-1-需求" class="headerlink" title="2.3.1 需求"></a>2.3.1 需求</h4><ul><li>过期后短域名将失效</li><li>短域名是唯一的</li><li>支持自定义短域名，并且限制规则</li></ul><h4 id="2-3-2-系统指标"><a href="#2-3-2-系统指标" class="headerlink" title="2.3.2 系统指标"></a>2.3.2 系统指标</h4><ul><li>读多写少系统，估算 1 亿用户使用<ul><li>写 QPS = 100 M * 0.1 / 86400 = 1k -&gt; 峰值 2k -&gt; 预估值 = 4k</li><li>读 QPS = 100 M * 10 / 86400 = 115k -&gt; 峰值 230k -&gt; 预估值 = 460k</li></ul></li></ul><blockquote><p>系统设计时需要考虑峰值和预估值，峰值为用户访问的上限值，预估值为经过几年用户增长后，用户访问的上限值。</p></blockquote><ul><li>延迟、可靠性（几个 9）、安全性</li></ul><h2 id="3-方案设计"><a href="#3-方案设计" class="headerlink" title="3. 方案设计"></a>3. 方案设计</h2><h3 id="3-1-可行解"><a href="#3-1-可行解" class="headerlink" title="3.1 可行解"></a>3.1 可行解</h3><p>先从业务需要简单实现一个可用的系统，需要完成以下接口。</p><p>写接口：</p><ul><li>输入长域名，判断是否存储</li><li>生成一个从未使用过的短域名</li><li>将长域名和短域名的关联持久化到数据库中</li></ul><p>读接口：</p><ul><li>获取短域名，判断是否有效</li><li>根据短域名查询长域名</li><li>使用长域名通知客户端重定向</li></ul><h4 id="处理过期时间"><a href="#处理过期时间" class="headerlink" title="处理过期时间"></a>处理过期时间</h4><p>增加过期时间有以下方案：</p><ul><li>延迟删除：获取短域名时判断是否过期，过期则进行删除。优点是性能损失小，修改方便；缺点是造成空间浪费</li><li>定时删除：设置定时任务，为每个短域名设置删除回调，过期则立即删除。优点是空间利用率最高；缺点是维护定时任务占用大量内存，性能差</li><li>轮询删除：设置后台逻辑，定时清理过期元素。空间和性能的折中考虑。</li></ul><p>由于系统要求低延迟，性能要求高，故选择延迟删除方案。</p><h4 id="保证域名唯一"><a href="#保证域名唯一" class="headerlink" title="保证域名唯一"></a>保证域名唯一</h4><p>一个全局唯一的分布式 id 便能保证域名的唯一性，实现分布式 id 有以下方案：</p><ul><li>哈希，需要处理哈希冲突</li><li>UUID，性能损耗大</li><li>数据库自增 id，可以通过号端模式降低性能开销，但安全性较低</li><li>雪花算法</li></ul><p>综上，一个可行的系统如下图所示：</p><p><img src="可行解.png" alt="一个可行系统"></p><h3 id="3-2-系统优化"><a href="#3-2-系统优化" class="headerlink" title="3.2 系统优化"></a>3.2 系统优化</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul><li>水平拓展系统，使用 NGINX 进行负载均衡</li><li>进行分片、数据副本</li></ul><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>数据库层面：</p><ul><li>数据表的业务逻辑很简单，考虑将关系型数据库改为持久化 kv 引擎，例如 LevelDB</li><li>构建索引：写入时需要判断长域名是否存在，对长域名建立索引</li></ul><p>缓存层面：</p><ul><li>判断长域名是否存储和短域名是否分配，可以构建布隆过滤器</li><li>考虑在客户端建立缓存，存储长短域名映射，进一步降低延迟</li></ul><p>业务层面：</p><ul><li>利用号端模式获取批量 id，降低全局 id 的性能开销</li></ul><h4 id="可靠和安全性"><a href="#可靠和安全性" class="headerlink" title="可靠和安全性"></a>可靠和安全性</h4><ul><li>数据库采用主从模式</li><li>使用 kafka 与 binlog 的方式进行全量与增量的跨机房数据冗余备份</li><li>根据监控指标，进行系统熔点、限流、扩缩容 </li><li>直接使用自增 id 作为短域名，避免被遍历爬取</li><li>进行 IP 限流和黑名单防止 DOS 攻击</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/TinyURL">TinyURL wikipedia</a></li><li><a href="https://www.bilibili.com/video/BV1Jb4y197ks">系统设计 短地址系统</a></li><li><a href="https://hardcore.feishu.cn/docs/doccnAfY0f35ZgnrFg7jSTQmOOf">实现一个短域名系统</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis核心原理与实战(4) 实战</title>
      <link href="/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(4)%20%E5%AE%9E%E6%88%98/"/>
      <url>/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(4)%20%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>Redis 最常用的场景是在系统中作缓存使用，部署在数据库的前端，在访问数据时，先访问 Redis，无法访问到数据再访问数据库。</p><p>缓存可分为：</p><ul><li>只写缓存：所有写操作直接发往数据库，读操作先访问缓存</li><li>读写缓存：读写操作都会经过缓存</li></ul><p>读写缓存的写入分为两种策略：</p><ul><li>同步直写：写请求同时发给缓存和数据库，两者都写完后才返回客户端。优点是保持了数据一致性，缺点是增加了响应延迟</li><li>异步写回：写请求先在缓存处理，等到数据将被缓存淘汰时，才同步给数据库</li></ul><p><img src="写入策略.png" alt="缓存写入策略"></p><h3 id="1-2-数据一致性"><a href="#1-2-数据一致性" class="headerlink" title="1.2 数据一致性"></a>1.2 数据一致性</h3><p>对于读写缓存而言，要保证数据一致性只能采用同步直写策略，并且数据库和缓存的写入必须是原子的。而对于只读缓存，保证数据一致性策略更为复杂，一般有以下策略。</p><h4 id="1-2-1-设置过期时间"><a href="#1-2-1-设置过期时间" class="headerlink" title="1.2.1 设置过期时间"></a>1.2.1 设置过期时间</h4><p>给缓存设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可；数据库写成功，缓存更新失败，可以保证最终一致性。</p><h4 id="1-2-2-先更新数据库，再更新缓存"><a href="#1-2-2-先更新数据库，再更新缓存" class="headerlink" title="1.2.2 先更新数据库，再更新缓存"></a>1.2.2 先更新数据库，再更新缓存</h4><p>该方案由于并发情况下会导致脏数据，一般不使用，例如 A，B 先后进行数据更新，但由于网络问题，A 在 B 之后更新了缓存，导致了脏数据。</p><h4 id="1-2-3-先删缓存，再更新数据库"><a href="#1-2-3-先删缓存，再更新数据库" class="headerlink" title="1.2.3 先删缓存，再更新数据库"></a>1.2.3 先删缓存，再更新数据库</h4><p>该方案也可能导致数据不一致，例如：</p><ul><li>请求 A 进行写操作，删除缓存 </li><li>请求 B 查询发现缓存不存在 ，B 去数据库查询得到旧值，B 将旧值写入缓存</li><li>A 将新值写入数据库</li></ul><p>上述场景请求 B 最终将旧值写入缓存，其他请求访问缓存得到的仍然是旧值。</p><p>解决方案是使用延迟双删，在 A 更新完数据库之后，睡眠一段时间，额外进行一次删除缓存的操作。</p><h4 id="1-2-4-先更新数据库值，再删除缓存"><a href="#1-2-4-先更新数据库值，再删除缓存" class="headerlink" title="1.2.4 先更新数据库值，再删除缓存"></a>1.2.4 先更新数据库值，再删除缓存</h4><p>如果 A 更新了数据库的值，B 在 A 还没更新缓存前仍会读到旧值，如果并发读缓存的请求不多，那只有少量错误，对业务影响比较小。</p><h3 id="1-3-缓存击穿、穿透和雪崩"><a href="#1-3-缓存击穿、穿透和雪崩" class="headerlink" title="1.3 缓存击穿、穿透和雪崩"></a>1.3 缓存击穿、穿透和雪崩</h3><h4 id="1-3-1-缓存击穿"><a href="#1-3-1-缓存击穿" class="headerlink" title="1.3.1 缓存击穿"></a>1.3.1 缓存击穿</h4><p>缓存击穿指对于某个热点数据，无法在缓存中处理，访问该数据的大量请求直接发送到数据库。</p><p>解决方案：</p><ul><li>热点数据永不过期</li><li>限制只有少量请求访问数据库并重新构建缓存</li></ul><h4 id="1-3-2-缓存穿透"><a href="#1-3-2-缓存穿透" class="headerlink" title="1.3.2 缓存穿透"></a>1.3.2 缓存穿透</h4><p>缓存穿透指要访问的数据既不在 Redis 中，也不在数据库中，导致请求访问缓存之后都得再次访问数据库，缓存失去了作用。</p><p>解决方案：</p><ul><li>缓存空值或缺省值</li><li>在业务层使用布隆过滤器判断数据是否存在</li></ul><h4 id="1-3-3-缓存雪崩"><a href="#1-3-3-缓存雪崩" class="headerlink" title="1.3.3 缓存雪崩"></a>1.3.3 缓存雪崩</h4><p>缓存雪崩指大量请求无法在 Redis 中处理，直接发送到数据库，导致数据库的压力激增。</p><p>缓存雪崩一般有两个原因，一个原因是缓存中大量数据同时过期，导致大量请求无法处理，解决方案有：</p><ul><li>微调过期时间，添加一定随机值防止同时过期</li><li>服务降级：当发生缓存雪崩时，如果访问非核心数据，直接返回空值或者错误信息，如果访问核心数据，允许通过数据库读取。</li></ul><p>另一个原因是 Redis 宕机，无法处理请求，解决方案是：</p><ul><li>在业务中实现服务熔断或者请求限流，降低数据库的压力</li><li>建立 Redis 高可用集群</li></ul><h2 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h2><p>在分布式系统中，某些数据也需要进行并发访问，需要加锁。分布式锁需要一个共享存储系统来维护，可以创建一个锁变量，相应的加锁、解锁操作就变成读取、判断和设置变量值。</p><p>Redis 可用于实现分布式锁，但需要考虑单机和集群两种场景。</p><h3 id="2-1-单机实现分布式锁"><a href="#2-1-单机实现分布式锁" class="headerlink" title="2.1 单机实现分布式锁"></a>2.1 单机实现分布式锁</h3><p>一个直观想法是使用 SETNX 和 DEL 创建和释放锁，但这个方案存在两个问题。</p><p>一个问题是如果获取到锁的客户端发生异常，没有执行 DEL 命令释放锁，将导致死锁。针对这个问题，一个有效方案是给锁设置过期时间，注意过期时间的合理性，保证不会在业务在运行完之前释放锁。</p><p>另一个问题是无法区分客户端，A 使用 SETNX 创建了锁，但 B 使用 DEL 则直接释放了锁。解决方案是让客户端给锁变量设置唯一值，释放锁时使用 lua 脚本先判断 Redis 中锁变量的值与客户端的值，一致才能释放锁。</p><h3 id="2-2-集群实现分布式锁"><a href="#2-2-集群实现分布式锁" class="headerlink" title="2.2 集群实现分布式锁"></a>2.2 集群实现分布式锁</h3><p>单机 Redis 节点宕机之后便无法提供服务，需要引入集群实现高可用的分布式锁。</p><p>上述单机分布式锁的解决方案可以作用在集群上，但如果主节点申请的锁还未同步到从节点，此时主节点宕机，重新选取的主节点未持有该锁，会导致两个客户端同时获得锁，一般业务场景可以容忍这个问题，追求更强的一致性可以使用 Redlock 算法。</p><p>Redlock 算法是 Redis 开发人员提出的分布式锁算法，其基本思路是，让客户端和多个 Redis 实例依次</p><p>加锁，如果和半数以上的实例完成加锁操作并且未超过锁的有效时间，则成功获得分布式锁，释放锁时向所有节点解锁。</p><h2 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3.消息队列"></a>3.消息队列</h2><p>现在的互联网应用基本是分布式架构，而其中一个基础组件就是消息队列，那么 Redis 能够实现消息队列吗？</p><h3 id="3-1-消息队列的需求"><a href="#3-1-消息队列的需求" class="headerlink" title="3.1 消息队列的需求"></a>3.1 消息队列的需求</h3><p>消息队列在存取消息时，需要满足三个需求：</p><ul><li>消息保序：消费者能够按照生产者发送消息的顺序来处理，防止业务错误</li><li>重复消息处理</li><li>可靠性保证：由于网络或者机器故障，消息可能未处理完，需要能提供消息可靠性的保证</li></ul><h3 id="3-2-基于List实现"><a href="#3-2-基于List实现" class="headerlink" title="3.2 基于List实现"></a>3.2 基于List实现</h3><p>一个直观想法是使用 List 实现，List 是按照 FIFO 的顺序存储的，符合消息保序的需求。</p><p>生产者使用 LPUSH 命令写入消息，消费者使用 RPOP 从另一端拉取数据并处理。由于 List 不会主动通知有新消息，在消费侧需要死循环调用 RPOP 指令，带来性能损失，对此 Redis 提供 BRPOP 命令，BRPOP 为阻塞式读取，没有读到队列数据时会自动阻塞直到有新数据入队，节省 CPU 开销。</p><p>对于重复消息，List 没有提供保证，生产者在生产时需要提供全局唯一 id，消费者程序需要实现幂等消费。</p><p>对于可靠性，Redis 提供了 BRPOPLPUSH 命令，该命令需要维护两个 List，从列表中取出最后一个元素，并插入备份列表的头部，如果消费者未能正常处理，重启后从备份列表重新拉取处理。</p><h3 id="3-3-Streams"><a href="#3-3-Streams" class="headerlink" title="3.3 Streams"></a>3.3 Streams</h3><p>Streams 是 Redis 5.0 专门为消息队列设计的数据类型，提供以下命令：</p><ul><li>XADD：插入消息，保证有序，并生成全局唯一 ID</li><li>XREAD：读取消息，可以按 ID 读取</li><li>XREADGROUP：按消费组形式读取消息</li><li>XPENDING：查询每个消费组内消费组已读取但未确认的消息</li><li>XACK：确认消息处理完成</li></ul><blockquote><p>对于 Redis 做消息队列，业界一直有所争议，认为应该使用 Kafka、RocketMQ 等专业的消息队列。笔者认为 Redis 基于 List 实现的消息队列较为繁琐，一般不推荐使用， Streams 使用较为简单，可用在消息通信量较小的场合。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis核心原理与实战(3) 底层实现</title>
      <link href="/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(3)%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(3)%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h2><p>Redis 中的字符串采用简单动态字符串（Simple Dynamic String，SDS），实现如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// buf数组已使用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// buf数组未使用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 保存数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDS 相比 C 字符串的优势：</p><ul><li>计数方式不同，C 字符串获取长度时间复杂度 O(n)，sdshdr 为 O(1)</li><li>杜绝了缓冲区溢出，进行自动扩容</li><li>空间预分配和惰性空间释放<ul><li>空间预分配：对 sdshdr 拓展时，会分配多余的 free空间 + 1 byte，其余 1 byte 用于存空字符</li><li>惰性空间释放：sdshdr 缩减后，不会立即回收多余空间</li></ul></li><li>二进制安全，对于二进制文件中存在 ‘\0’ , C 字符串会截断，sdshdr 则不存在这个问题。</li><li>sdshdr 兼容 string.h 的某些操作，并且支持二进制格式</li></ul><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><p>Redis 采用双向链表实现 List。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 采用void* 可以保存任意类型</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode * head;</span><br><span class="line">    listNode * tail;</span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h2><p>Redis 会保存一个全局字典记录 key-value 映射，采用哈希表实现。</p><p><img src="全局哈希表.png" alt="全局哈希表"></p><h3 id="3-1-字典实现"><a href="#3-1-字典实现" class="headerlink" title="3.1 字典实现"></a>3.1 字典实现</h3><p>字典底层采用哈希表实现，使用拉链法解决哈希冲突。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数，保存了操作该类型的函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 保存了传给该类型的可选参数</span></span><br><span class="line">    <span class="keyword">void</span> *pridata;</span><br><span class="line">    <span class="comment">// ht[0]存储数据，ht[1]用于rehash复制</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 是否在rehash, 如果不在rehash，则值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制key的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制value的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比key的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2);</span><br><span class="line">    <span class="comment">// 销毁key的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁value的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>字典中保存了两个哈希表和一个下标 rehashidx 用以实现 rehash，结构如下图所示。</p><p><img src="字典示意.jpg" alt="字典示意图"></p><h3 id="3-2-rehash"><a href="#3-2-rehash" class="headerlink" title="3.2 rehash"></a>3.2 rehash</h3><p>rehash 的流程：</p><ul><li>为 ht[1] 分配空间，ht[1] 的长度为 2 的幂</li><li>渐进 rehash：当用户执行增删改查时，定位其索引 rehashidx，将 ht[0] 对应的节点复制到 ht[1]，故 resash 操作被平摊到各个操作上。故在 rehash 过程中，用户的操作需要在 ht[0] 和 ht[1] 两个表进行（增加操作只在 ht[1] 进行，保证 ht[0] 只减不增），rehash 结束，rehashidx变为 -1</li><li>释放 ht[1]，将 ht[1] 设置为 ht[0]，ht[1] 创建一个空表，为下次 rehash 做准备</li></ul><p>rehash 时机：</p><ul><li>拓展<ul><li>目前没有执行 BGSAVE 或 BGREWRITEAOF，且负载因子大于等于 1</li><li>目前正在执行 BGSAVE 或 BGREWRITEAOF，且负载因子大于等于 5 (BGSAVE/BGREWRITEAOF 采用 copy-on-write 机制，redis 提高了负载因子的上限，避免子进程运行期间哈希表进行扩容，减少不必要的内存写入）</li></ul></li><li>收缩：负载因子小于 0.1</li></ul><h2 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4. 跳跃表"></a>4. 跳跃表</h2><p>跳跃表是 Redis 有序集合的基础，是多层有序链表。</p><p>传统的有序链表插入和查找的复杂度都为 O(n)，如果我们将有序链表的节点分层，每一层都是有序链表，在查找时从最高层开始查找，如果 next 节点大于要寻找的值或 next 为空，则到下一层查找，即可完成 O(logn) 的查找复杂度。跳表的具体实现不在此介绍，感兴趣的读者可以翻阅数据结构教材查看。</p><p><img src="跳表.png" alt="跳表"></p><h2 id="5-压缩列表"><a href="#5-压缩列表" class="headerlink" title="5. 压缩列表"></a>5. 压缩列表</h2><p>压缩列表 ziplist 本质上是个字节数组，是 Redis 为了节约内存而设计的一种线性数据结构，Redis 的游戏集合、哈希和列表都使用了压缩列表。</p><p>ziplist 的结构如下图所示。</p><p><img src="压缩列表示意.png" alt="压缩列表"></p><ul><li>zlbytes：压缩列表的字节长度</li><li>zltail：压缩列表尾元素相对于压缩列表起始地址的偏移量</li><li>zllen：压缩列表的元素个数</li><li>entryX：压缩列表存储的元素，可以是字节数组或者整数，长度不限</li><li>zlend：压缩列表的结尾标志符，恒为0xFF</li></ul><p>根据上面的结构，我们很容易就可以得到压缩列表的字节长度、元素个数等，那么对于任意一个元素，如何判断其类型，以其元素的长度呢？</p><p>回答这些问题前，首先需要了解元素的结构，如下图所示。</p><p><img src="压缩列表元素结构.png" alt="压缩列表元素"></p><ul><li>previous_entry_length：前一个元素的字节长度</li><li>encoding：编码，当前元素的数据类型，整数或者字节数组</li><li>content：数据内容</li></ul><p>ziplist 遍历时从尾部开始遍历（通过 ztail 定位），根据 previous_entry_length 即可不断向前遍历，直到表头节点。</p><h2 id="6-quicklist"><a href="#6-quicklist" class="headerlink" title="6. quicklist"></a>6. quicklist</h2><p>低版本 Redis 的 List 使用 ziplist 和双向链表作为底层实现，在 3.2 版本引入 quicklist 综合考虑时间和空间效率。</p><p>quicklist 是一个双向链表， 链表中的每个节点都是一个 ziplist，结构如下图所示。</p><p><img src="quicklist.png" alt="quicklist"></p><h2 id="7-整数集合"><a href="#7-整数集合" class="headerlink" title="7. 整数集合"></a>7. 整数集合</h2><p>整数集合 intset 用于保存整数值的集合，可以保存 int16_t、int32_t、int64_t 的整数值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 包含元素个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>intset 的插入可能会触发升级</p><ul><li>触发条件：添加的新元素超过当前类型能表示的范围（过大或者过小），则会触发升级</li><li>过程：根据新元素类型拓展数组，并转换原有元素，之后添加新元素（只会放在最后或者 0 号位置）</li><li>自动升级的优点：灵活，节省内存</li></ul><h2 id="8-对象"><a href="#8-对象" class="headerlink" title="8. 对象"></a>8. 对象</h2><p>上文陆续介绍了 Redis 使用到的主要数据结构和底层实现，但 Redis 并没有直接使用这些数据结构来实现，而是创建了一个对象系统，包含字符串、列表、哈希、集合和有序集合五种对象，主要有以下两个优点：</p><ul><li>Redis会根据场景为对象选择特定的数据结构，来优化效率</li><li>使用引用计数来实现统一的内存回收</li></ul><p>Redis 的每个对象都由一个 redisObject 结构体组成，其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码格式</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现的数据结构</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li><p>type：类型，string、list、hash、set、zset 中的一个</p></li><li><p>encoding：编码，即对象使用的数据结构</p></li><li>ptr：对象的底层实现</li><li>refcount：引用计数，为 0 时被回收</li></ul><p>每种类型的对象都至少使用了两种不同的数据结构。</p><p><img src="基本类型底层实现.png" alt="基本类型底层实现"></p>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis核心原理与实战(2) 高可用</title>
      <link href="/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(2)%20%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(2)%20%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-复制"><a href="#1-复制" class="headerlink" title="1. 复制"></a>1. 复制</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>对于单机的 Redis，有 RDB 和 AOF 持久化机制，在宕机过后可以恢复数据，但在恢复过程中仍然存在不可用的问题。对于这个问题，Redis 提供了主从库模式，主从库采用读写分离的方式，写操作都作用在主库，并同步给从库。</p><p>可以通过 relicaof 指令形成主从库，例如现有实例 1（ip: 172.16.19.3）和实例 2，在实例 2 上执行以下命令，实例 2 就变成了实例 1 从库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicafof   172.16.19.3   6379</span><br></pre></td></tr></table></figure><p>Redis 的复制功能分为同步和命令传播两个操作：</p><ul><li>同步：将从库的状态更新到主库的状态</li><li>命令传播：主库数据修改，将数据同步给从库</li></ul><p>其中命令传播较为简单，下面主要介绍同步。</p><h3 id="1-2-同步"><a href="#1-2-同步" class="headerlink" title="1.2 同步"></a>1.2 同步</h3><p>主库和从库的同步需要经历三个阶段：</p><ul><li>从库发送 psync 命令，表示要进行数据同步，该命令包含主库的标识 runID 和复制进度 offset，主库对此响应 FULLRESYNC 命令并携带两个参数</li><li>主库执行 bgsave 命令，生成 RDB 文件发送给从库，从库接收文件后清空数据库并进行加载</li><li>主库将第二阶段新收到的写命令发送给从库，从库执行后完成同步</li></ul><p><img src="主从库同步.png" alt="主从同步"></p><p>上述过程对于主库而言，生成和传输 RDB 文件较为耗时，如果从库数量很多，将会导致主库忙于 fork 进程生成 RDB 文件，而 fork 操作会阻塞主线程处理正常请求，导致响应变慢。为了分担主库的压力，可以采用 主 - 从- 从 模式。</p><p>主 - 从 - 从 模式在部署从库时，可以手动选择一个从库，其他部分 Redis 实例作为这个从库的从库。这些 Redis 实例在进行同步时，只需要从级联的从库同步写操作即可。</p><p><img src="级联从库.png" alt="级联从库"></p><h3 id="1-3-增量复制"><a href="#1-3-增量复制" class="headerlink" title="1.3 增量复制"></a>1.3 增量复制</h3><p>主从库如果出现了网络中断，重连之后进行全量复制的开销非常大，对此 Redis 2.8 引入增量复制。</p><p>增量复制的奥妙在于 repl_backlog_buffer 缓冲区，这是一个环形缓冲区，主库记录自己写到的位置，从库记录已读的位置。</p><p>在主从库断连后，主库会把这期间收到的写操作，同时写入 replication buffer 和 repl_backlog_buffer。在从库恢复链接后，发送 psync 命令和自己的已读偏移给主库，主库响应从库缺失的指令，从库运行之后即可完成同步。</p><p><img src="增量复制.png" alt="增量复制"></p><h2 id="2-Sentinel"><a href="#2-Sentinel" class="headerlink" title="2. Sentinel"></a>2. Sentinel</h2><p>在主从库模式中，如果主库宕机，写请求将无法处理，此时需要将一个从库切换为主库，这就要提到哨兵机制，这是实现主从库自动切换的关键机制。</p><p>哨兵 Sentinel 是 Redis 的高可用方案，本质是一个运行在特殊模式下的 Redis 实例，主要负责三个任务：监控、选主和通知。</p><h3 id="2-1-监控"><a href="#2-1-监控" class="headerlink" title="2.1 监控"></a>2.1 监控</h3><p>监控即判断主库是否为下线状态，Sentinel 会按一定频率向所有跟它连接的实例发送 PING 命令，判断实例是否在线。</p><p>哨兵对主库的判断有 主观下线 和 客观下线 两种，当哨兵发现实例对 PING 的响应超时了，就会把它标记为主观下线。此时并不会开启主从切换，因为可能主库并没有故障，但由于网络拥塞导致超时，导致误判。</p><p>在日常开发中，会采用多实例组成的哨兵集群，当超过半数的哨兵判断为主观下线时，才会将主库判定为客观下线，进行主从库切换。</p><h3 id="2-2-选主"><a href="#2-2-选主" class="headerlink" title="2.2 选主"></a>2.2 选主</h3><p>哨兵集群首先使用 Raft 算法选出领头 Sentinel，再选择新主库。哨兵选择新主库的过程分为 筛选 + 打分，首先会根据一定条件去掉不符合条件的从库，再根据一定规则给从库打分，选择得分最高的从库作为主库。</p><p>筛选条件：从库首先得是正常在线状态，最近 5 秒内有回复过领头 Sentinel，并且与主库的断连次数少于一定阈值。</p><p>打分规则分为三轮，只要在某一轮中有从库得分最高，则会被选为主库。</p><ul><li>从库优先级：用户可以通过 slave-priority 给从库设置优先级</li><li>从库复制进度：选择和旧主库同步最接近的从库，即增量复制下标最解决主库的从库</li><li>ID ：选择从 ID 最小的从库</li></ul><h3 id="2-3-通知"><a href="#2-3-通知" class="headerlink" title="2.3 通知"></a>2.3 通知</h3><p>在选出新主库后，Sentinel 发送 SLAVEOF 命令通知从库去复制新主库，并将旧主库变为从库。</p><h2 id="3-切片"><a href="#3-切片" class="headerlink" title="3. 切片"></a>3. 切片</h2><p>当 Redis 中存放大量键值对时，将会占据大量内存，并且影响 RDB 持久化的性能，对此引入切片集群。</p><p>切片集群，也称分片集群，指启动多个 Redis 实例组成集群，并按照一定规则，将数据划分多份，交由不同实例保存。</p><h3 id="3-1-数据和实例的映射"><a href="#3-1-数据和实例的映射" class="headerlink" title="3.1 数据和实例的映射"></a>3.1 数据和实例的映射</h3><p>在切片集群中，数据需要分布在不同实例上，那么数据和实例之间如何对应呢？</p><p>Redis 3.0 引入 Redis Cluster 提供针对切片集群的方案，采用哈希槽 Hash Slot 来处理数据和实例的映射。一个切片集群共有 16384 个槽，根据 key 计算 16 bit 的值并对 16384 取模，可以得到 key 对应的槽，那么槽如何与实例对应呢？</p><p>默认情况下 Redis 会把这些槽平均分配各个实例，用户也可以自定义槽与实例的映射。</p><h3 id="3-2-客户端定位数据"><a href="#3-2-客户端定位数据" class="headerlink" title="3.2 客户端定位数据"></a>3.2 客户端定位数据</h3><p>在集群创建过程中，每个实例会把自己的哈希槽发给预期连接的实例，最终得到所有哈希槽的分布，客户端与集群实例建立连接后，便能得到所有分布信息缓存在本地。</p><p>当实例和哈希槽的对应关系改变之后，例如新增/删除实例，此时客户端是无法获知这个槽变化的，Redis Cluster 提供了一种重定向机制，给客户端发送新实例的地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 槽变为12321，IP地址为192.168.1.1</span></span><br><span class="line">(error) MOVED   12321   192.168.1.1</span><br></pre></td></tr></table></figure><p>但可能192.168.1.1 的数据迁移仍未结束，此时会回传 ASK 报错信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) ASK 12321 192.168.1.1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis核心原理与实战(1) 介绍</title>
      <link href="/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(1)%20%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(1)%20%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1. Redis"></a>1. Redis</h2><p>Redis，Remote Dictonary Server，远程字典服务，是一个高性能键值数据库，在后端开发中广泛使用。</p><p>Redis 的数据存储在内存中，其网络 IO 处理和数据处理采用一个线程实现，也称 Redis 是单线程的。</p><blockquote><p>严格上来说 Redis 不是单线程的，持久化、异步删除等操作是由额外的线程执行的。由于单个主线程处理网络请求跟不上底层硬件的速度，在 Redis 6.0 后，网络 IO 处理改为多线程，数据访问仍为单线程。</p></blockquote><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><h3 id="2-1-基本类型"><a href="#2-1-基本类型" class="headerlink" title="2.1 基本类型"></a>2.1 基本类型</h3><p>Redis 的五大基本数据类型包括：String、List、Set、Hash、Zset。</p><h4 id="2-1-1-String"><a href="#2-1-1-String" class="headerlink" title="2.1.1 String"></a>2.1.1 String</h4><p>String 即字符串，常见用途是存储序列化后的用户信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> APPEND key str ---&gt; 追加字符串，如果key不存在，则新建</span><br><span class="line"><span class="bullet">2.</span> STRLEN key ---&gt; 获取字符串长度</span><br><span class="line"><span class="bullet">3.</span> incr/decr key ---&gt; key对应的值自增/自减</span><br><span class="line"><span class="bullet">4.</span> INCRBY/DECRBY key step ---&gt; key对应的值增加/减少step</span><br><span class="line"><span class="bullet">5.</span> GETRANGE key start end ---&gt; 类似substr，截取字符串</span><br><span class="line"><span class="bullet">6.</span> SETRANGE key start end ---&gt; 替换部分字符串</span><br><span class="line"><span class="bullet">7.</span> setex key timeout value ---&gt; 设置k/v以及过期时间</span><br><span class="line"><span class="bullet">8.</span> setnx key value ---&gt; 设置k/v，如果key存在则失败</span><br><span class="line"><span class="bullet">9.</span> mset/msetnx k1 v1 k2 v2 ---&gt; 设置多个k/v，msetnx是原子操作，只能一起成功或者一起失败</span><br></pre></td></tr></table></figure><h4 id="2-1-2-List"><a href="#2-1-2-List" class="headerlink" title="2.1.2 List"></a>2.1.2 List</h4><p>List 即链表，常用于消息队列</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> LPUSH/RPUSH key value ---&gt; 往列表key头/尾插入数值</span><br><span class="line"><span class="bullet">2.</span> LPOP/RPOP key ----&gt; 移除列表的头/尾元素</span><br><span class="line"><span class="bullet">3.</span> LRANGE key start end ---&gt; 获取列表key一部分数据</span><br><span class="line"><span class="bullet">4.</span> LINDEX key index ---&gt; 获取第index个元素</span><br><span class="line"><span class="bullet">5.</span> LREM key count value ---&gt; 移除指定个数的value</span><br><span class="line"><span class="bullet">6.</span> LLEN key ---&gt; 获取列表的长度</span><br><span class="line"><span class="bullet">7.</span> LTRIM key start stop ---&gt; 通过下标截取指定范围的数据</span><br><span class="line"><span class="bullet">8.</span> LSET list index value ---&gt; 更新第index元素的value</span><br></pre></td></tr></table></figure><h4 id="2-1-3-Set"><a href="#2-1-3-Set" class="headerlink" title="2.1.3 Set"></a>2.1.3 Set</h4><p>Set 即集合，实现集合交并操作</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> sadd myset value ---&gt; 添加元素</span><br><span class="line"><span class="bullet">2.</span> SMEMBERS myset  ---&gt; 查看指定set的所有值</span><br><span class="line"><span class="bullet">3.</span> SISMEMBER myset value  ---&gt; 查看value是否在myset中</span><br><span class="line"><span class="bullet">4.</span> scard myset ---&gt; 查看元素个数</span><br><span class="line"><span class="bullet">5.</span> srem myset value ---&gt; 删除set中的value元素</span><br><span class="line"><span class="bullet">6.</span> 集合操作</span><br><span class="line"><span class="bullet">-</span> 差集: SDIFF set1 set2 </span><br><span class="line"><span class="bullet">-</span> 交集: SINTER set1 set2</span><br><span class="line"><span class="bullet">-</span> 并集: SUNION set1 set2</span><br></pre></td></tr></table></figure><h4 id="2-1-4-Hash"><a href="#2-1-4-Hash" class="headerlink" title="2.1.4 Hash"></a>2.1.4 Hash</h4><p>Hash 即字典，类似 java 中的 HashMap</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> hset myhash key1 value1   ---&gt; 设置元素</span><br><span class="line"><span class="bullet">2.</span> hmset myhash k1 v1 k2 v2  ---&gt; 批量设置</span><br><span class="line"><span class="bullet">3.</span> hgetall myhash ---&gt; 获得key对应的map</span><br><span class="line"><span class="bullet">4.</span> hdel myhash ---&gt;删除key对象的map</span><br><span class="line"><span class="bullet">5.</span> hlen myhash ---&gt; 获取字段数量</span><br></pre></td></tr></table></figure><h4 id="2-1-5-Zset"><a href="#2-1-5-Zset" class="headerlink" title="2.1.5 Zset"></a>2.1.5 Zset</h4><p>Zset 为排序的集合</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> zadd myset score value  ---&gt; 添加元素，优先级为score</span><br><span class="line"><span class="bullet">2.</span> ZRANGEBYSOCRE myset min max [WITHSOCRES] ---&gt; 获取score范围在min - max 之间的元素，可选带优先级</span><br><span class="line"><span class="bullet">3.</span> zcount myset min max ---&gt; 获取指定区间的成员数量</span><br></pre></td></tr></table></figure><h3 id="2-2-特殊数据类型"><a href="#2-2-特殊数据类型" class="headerlink" title="2.2 特殊数据类型"></a>2.2 特殊数据类型</h3><h4 id="2-2-1-geospatial-地理位置"><a href="#2-2-1-geospatial-地理位置" class="headerlink" title="2.2.1 geospatial 地理位置"></a>2.2.1 geospatial 地理位置</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用命令</span><br><span class="line"><span class="bullet">1.</span> geoadd table 经度 纬度 placename ---&gt; 添加地理位置</span><br><span class="line"><span class="bullet">2.</span> getpos table placename ---&gt; 获取指定位置的经度和纬度</span><br><span class="line"><span class="bullet">3.</span> geodist table placename1 placename2 单位 ---&gt; 获取两地的直线距离</span><br><span class="line"><span class="bullet">4.</span> georadius table 经度 纬度 半径 单位 ---&gt; 以所给经度、纬度为圆心，获得在半径范围内的位置</span><br><span class="line"><span class="bullet">5.</span> georadiusbymember table place 半径 单位 ---&gt; 以所给位置为圆心，获得在半径范围内的位置</span><br></pre></td></tr></table></figure><h4 id="2-2-Hyperloglog"><a href="#2-2-Hyperloglog" class="headerlink" title="2.2 Hyperloglog"></a>2.2 Hyperloglog</h4><p>Redis 2.8.9 加入了 hyperloglog，用来进行基数统计，基数为一个数据集中不重复元素的个数。其优点是占用内存固定，但计算存在一定误差。适用场景为允许误差的统计，例如一个网站每天的用户访问量。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用命令</span><br><span class="line"><span class="bullet">1.</span> PFadd mykey v1 v2 v3 v4.... ---&gt; 添加元素</span><br><span class="line"><span class="bullet">2.</span> PFCOUNT mykey ---&gt; 计算mykey的基数</span><br><span class="line"><span class="bullet">3.</span> PFMERGE dist mykey1 mykey2... ---&gt; 合并多个hyperloglog</span><br></pre></td></tr></table></figure><h4 id="2-3-Bitmaps"><a href="#2-3-Bitmaps" class="headerlink" title="2.3 Bitmaps"></a>2.3 Bitmaps</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用命令</span><br><span class="line"><span class="bullet">1.</span> setbit mapname index value ---&gt; 将第index位设置为value，value为0/1</span><br><span class="line"><span class="bullet">2.</span> getbit mapname index ---&gt; 取得第index位</span><br><span class="line"><span class="bullet">3.</span> bitcount mapname ---&gt; 计算位图中1的个数</span><br></pre></td></tr></table></figure><p>各数据类型的特点和对比如下图所示。</p><p><img src="数据类型.png" alt="数据类型对比"></p><h2 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3. 持久化"></a>3. 持久化</h2><p>Redis 的数据都是保存在内存的，如果宕机会丢失所有数据，Redis 为了数据恢复，引入了 RDB 和 AOF  两种机制。</p><h3 id="3-1-RDB"><a href="#3-1-RDB" class="headerlink" title="3.1 RDB"></a>3.1 RDB</h3><h4 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h4><p>RDB 是 Redis 的内存快照，只保存当前时刻的数据，在创建 RDB 文件过程中的数据修改不会记录，不具备数据完整性。</p><p>优缺点：</p><ul><li>优点：适合大规模的数据恢复，对数据的完整性要求不高</li><li>缺点：需要一定时间进程才能操作，Redis 挂了的话，最后一次修改数据的操作丢失；fork 进程的时候占用较大内存</li></ul><h4 id="3-1-2-触发时机"><a href="#3-1-2-触发时机" class="headerlink" title="3.1.2 触发时机"></a>3.1.2 触发时机</h4><ul><li>用户执行 SAVE、BGSAVE</li><li>配置的 save 规则满足</li><li>执行 flushall 命令</li><li>退出 redis</li></ul><h4 id="3-1-3-创建指令"><a href="#3-1-3-创建指令" class="headerlink" title="3.1.3 创建指令"></a>3.1.3 创建指令</h4><ul><li>SAVE：阻塞服务器进程，直到文件创建完毕</li><li>BGSAVE：默认使用，利用 copy on write 创建一个子进程进行持久化，父进程继续处理客户端请求，在此过程中拒绝 SAVE、BGSAVE 操作防止竞争</li></ul><p><img src="bgsave.png" alt="alt"></p><h3 id="3-2-AOF"><a href="#3-2-AOF" class="headerlink" title="3.2 AOF"></a>3.2 AOF</h3><h4 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h4><p>AOF 以写后日志的形式记录每个写操作，利用 AOF 恢复数据会重新执行这些操作。</p><blockquote><p>写后日志即先执行命令后写数据，为了降低开销，Redis 向 AOF 记录日志并不会进行语法检查，所以先执行命令成功再写入日志。写后日志会丢失最新一次的修改。</p></blockquote><h4 id="3-2-2-写回策略"><a href="#3-2-2-写回策略" class="headerlink" title="3.2.2 写回策略"></a>3.2.2 写回策略</h4><p>写回策略决定了 AOF 持久化的时机，包括：</p><ul><li>Always：同步写回，每个写命令执行完立即同步日志到磁盘。基本不丢数据，但影响主线程性能。</li><li>Everysec：每秒写回，将日志写到 AOF 文件的内存缓冲区，每隔一秒同步到磁盘。宕机时丢失 1 秒内的数据，对性能影响折中。</li><li>No：操作系统控制写回，将日志写到缓冲区，由操作习题决定同步磁盘的时机。丢失数据最多，但对性能影响最小。</li></ul><h4 id="3-2-3-AOF重写"><a href="#3-2-3-AOF重写" class="headerlink" title="3.2.3 AOF重写"></a>3.2.3 AOF重写</h4><p>由于 AOF 文件只能追加，经过长时间运行，AOF 文件过大，继续追加日志以及数据恢复的耗时都会变长，故引入 AOF 重写机制。</p><p>重写的思想为将旧日志中的对同一个 key 的多条命令变为一条命令。</p><p>AOF 重写流程：</p><ul><li>创建子进程进行重写操作</li><li>在重写过程如果服务器收到指令，则将追加到 AOF 缓冲区和 AOF 重写缓冲区</li><li>子进程完成重写向父进程发送信号，父进程原子替换 AOF 文件</li></ul><h2 id="4-淘汰策略"><a href="#4-淘汰策略" class="headerlink" title="4. 淘汰策略"></a>4. 淘汰策略</h2><p>随着服务的运行，缓存被写满是不可避免的，此时需要对缓存中的数据进行淘汰，Redis 的淘汰策略包含：</p><ul><li>noeviction：默认淘汰策略，可进行删读，不可增改</li><li>volatile-lru：使用 LRU 淘汰设置了过期时间的 key</li><li>volatile-lfu：使用 LFU 淘汰设置了过期时间的 key</li><li>volatile-ttl：淘汰最先要过期的 key</li><li>volatile-random：随机淘汰会过期的 key</li><li>allkeys-lru：使用 LRU 淘汰 key</li><li>allkeys-lfu：使用 LFU 淘汰 key</li><li>allkets-random：随机淘汰key</li></ul><blockquote><p>LRU，Least Recently Used，最近最少使用算法，淘汰最近未被使用过的数据；</p><p>LFU，Least Frequently Used，最不经常使用算法，淘汰使用次数最少的数据。</p></blockquote><p><img src="淘汰策略.png" alt="淘汰策略"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://time.geekbang.org/column/intro/100056701">Redis核心技术与实战</a></li><li><a href="https://book.douban.com/subject/25900156/">Redis设计与实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(5) 线程池</title>
      <link href="/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(5)%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(5)%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><h3 id="1-1-使用线程池的原因"><a href="#1-1-使用线程池的原因" class="headerlink" title="1.1 使用线程池的原因"></a>1.1 使用线程池的原因</h3><p>使用线程池主要有以下原因：</p><ul><li><p>控制并发的数量。每一个线程操作系统都需要为其分配资源，并发数量过多会导致资源消耗大</p></li><li><p>创建/销毁线程开销大，线程池通过复用已创建的线程降低开销</p></li><li>统一管理</li></ul><h3 id="1-2-ThreadPoolExecutor简介"><a href="#1-2-ThreadPoolExecutor简介" class="headerlink" title="1.2 ThreadPoolExecutor简介"></a>1.2 ThreadPoolExecutor简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code> 包含 7 个参数，其中 <code>threadFactory</code> 和<code>handler</code> 为可选项，其他为必选项，各参数含义如下：</p><ul><li><p><code>corePoolSize</code>：核心线程最大值。线程池的线程分为核心线程和非核心线程，核心线程闲置也不会被销毁，非核心线程闲置一定时间后会被回收</p></li><li><p><code>maximumPoolSize</code>：线程总数最大值，等于核心线程数+非核心线程数</p></li><li><p><code>keepAliveTime</code>：非核心线程闲置超时时长，超过将被销毁</p></li><li><p><code>unit：keepAliveTime</code> 的单位，是个枚举类型，包括天、小时、分、秒、毫秒、微秒、纳秒</p></li><li><p><code>workQueue</code>：工作队列，维护等待执行的任务对象</p><p>常用的几个阻塞队列：</p><ul><li><code>LinkedBlockingQueue</code>：链表实现的阻塞队列，默认大小是 <code>Integer.MAX_VALUE</code>，也可用户指定大小</li><li><code>ArrayBlockingQueue</code>：数组实现的阻塞队列，需要指定大小</li><li><code>SynchronousQueue</code>：同步队列，内部容量为 0，<code>put</code> 操作必须等待一个 <code>take</code> 操作，反之亦然</li><li><code>DelayQueue</code>：延时队列，当队列的元素到达延时时间，才能够被获取</li></ul></li><li><p><code>threadFactory</code>：线程工厂，用于批量创建线程，不指定则使用默认工厂</p></li><li><p><code>handler</code>：拒绝处理策略，当任务无法入队且达到线程数量限制时采用处理策略，有 4 种实现：</p><ul><li><code>AbortPolicy</code>：默认使用，丢弃任务并抛出 <code>RejectedExecutionException</code></li><li><code>DiscardPolicy</code>：忽略任务，不抛出异常</li><li><code>DiscardOldestPolicy</code>：丢弃最旧的任务，尝试执行新任务，失败则重复该过程</li><li><code>CallerRunsPolicy</code>：由调用线程（将该任务添加到线程池的线程）处理该任务</li></ul></li></ul><h3 id="1-3-线程池状态"><a href="#1-3-线程池状态" class="headerlink" title="1.3 线程池状态"></a>1.3 线程池状态</h3><p>类似线程，线程池也有自己的状态，在代码中通过一些常量来表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// COUNT_BITS = 29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><ul><li><code>RUNNING</code>：接受新任务，也能处理阻塞队列中的任务</li><li><code>SHUTDOWN</code>：不接受新任务，但能处理队列中的任务</li><li><code>STOP</code>：不接受新任务，不处理队列中的任务，并且中断正在处理的任务</li><li><code>TIDYING</code>：已经没有工作线程和任务，并且马上要调用 <code>terminated</code> 方法</li><li><code>TERMINATED</code>：调用 <code>terminated</code> 方法结束，线程池停止</li></ul><p><img src="线程池状态转移.png" alt="线程池状态转移图"></p><p>线程池内部用一个 int 类型变量 ctl 同时表示线程池状态和线程数量，高 3 位用于表示线程池状态，而低 29 位表示线程的数量。</p><blockquote><p>此处使用一个变量的好处是如果对两个状态都进行同步修改，只需要通过位操作即可，免去了加锁操作，从这里也能感受到 Doug Lea 的精心设计。</p></blockquote><h3 id="1-4-线程池配置"><a href="#1-4-线程池配置" class="headerlink" title="1.4 线程池配置"></a>1.4 线程池配置</h3><p>给出如下定义：</p><ul><li>CPU 的数量 = N</li><li>预期 CPU 使用率 = U</li><li>等待时间与计算时间的比率 = W/C</li></ul><p>则推荐的线程池大小为：</p><ul><li>CPU 密集型：N + 1</li><li>IO 密集型：N x U x (1 + W/C)</li></ul><h2 id="2-线程池工作流程"><a href="#2-线程池工作流程" class="headerlink" title="2. 线程池工作流程"></a>2. 线程池工作流程</h2><h3 id="2-1-execute"><a href="#2-1-execute" class="headerlink" title="2.1 execute"></a>2.1 execute</h3><p><code>execute</code> 是线程池处理任务的核心方法，其 JDK 1.8 版本的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于corePoolSize,调用addWorker创建核心线程加载任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心线程数已达上限，则将任务添加到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池已经不再运行，则移除该任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 线程池仍在工作，但还未创建线程，则创建新线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加队列失败，则创建非核心线程，创建失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其流程如下：</p><p><img src="主流程.png" alt="线程池主流程"></p><p><img src="线程池处理流程.png" alt="线程池处理流程"></p><h3 id="2-2-线程复用"><a href="#2-2-线程复用" class="headerlink" title="2.2 线程复用"></a>2.2 线程复用</h3><p>上述 <code>execute</code> 方法是线程池处理任务、创建线程和执行拒绝策略的主流程。那么如何进行线程复用呢？这需要提及上面的 <code>addWorker</code> 方法，创建线程时，会将线程封装为 worker，将其添加到工作组，这个 worker 则会不断从阻塞队列拿任务执行。<code>addWorker</code> 的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略判断线程数量的代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 线程池全局加锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWorker</code> 方法先对线程数量进行判断，如果达到上限则返回 false（execute 中即可执行拒绝策略），否则获得全局锁后创建线程封装为 worker，将其添加到工作组中，并启动线程。</p><p>接下来我们看看 Worker 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其余代码略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker 的构造函数创建了一个线程，并且任务就是自身，当 <code>addWorker</code> 方法中调用 <code>t.start</code> 方法时，将会调用 Worker 的 <code>run</code> 方法，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 1.线程启动之后，通过unlock方法释放锁</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 2.2检查线程池状态，倘若线程池处于中断状态，当前线程将中断。 </span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 2.3执行beforeExecute，默认无实现，由用户提供</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 2.4执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 2.5执行afterExecute方法，默认无实现，由用户提供</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 2.6解锁操作</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runWorker</code> 方法会进入一个死循环，优先执行 firstTask，然后再通过 <code>getTask</code> 方法从阻塞队列中获取任务执行。除此之外线程池还提供了 <code>beforeExecute</code> 和 <code>afterExecute</code> 两个 hook 方法交由用户自定义实现任务执行前和执行后的操作。</p><p>到此我们知道了，只要 <code>getTask</code> 方法不返回 null，那么这个线程就不会被回收。那么 <code>getTask</code> 方法是如何实现闲置一定时间后返回 null 呢，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// getTask源码，省略部分判断代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">           <span class="comment">// ... </span></span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">           <span class="comment">// 是否有非核心线程</span></span><br><span class="line">           <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">           <span class="comment">// 非核心线程闲置一定时间，则任何null</span></span><br><span class="line">           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 核心线程和非核心线程的调用方法不同</span></span><br><span class="line">               Runnable r = timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> r;</span><br><span class="line">               timedOut = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">               timedOut = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>核心线程调用的 <code>workQueue.take</code> 方法，如果队列为空将阻塞在当前调用，直到有新任务入队；而非核心线程调用 <code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> 方法，一段时间未获取任务将会返回 null，在下一轮循环则会退出循环返回 null 给 <code>runWorker</code> 方法，<code>runWorker</code> 方法退出循环回收线程，至此线程池的运行逻辑便梳理清楚了。</p><h2 id="3-常见线程池"><a href="#3-常见线程池" class="headerlink" title="3. 常见线程池"></a>3. 常见线程池</h2><p><code>Executors</code> 类提供了几个静态方法创建特定类型的线程池。</p><h3 id="3-1-newCachedThreadPool"><a href="#3-1-newCachedThreadPool" class="headerlink" title="3.1 newCachedThreadPool"></a>3.1 newCachedThreadPool</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code> 不会创建核心线程，并且采用 <code>SynchronousQueue</code> 存储，提交任务后如果有空闲线程则进行处理，没有则创建一个非核心线程，空闲线程在 60s 后将被回收。</p><p>根据 <code>CachedThreadPool</code> 的上述特点，它适合使用在 大量短时间任务 的场景。</p><h3 id="3-2-FixedThreadPool"><a href="#3-2-FixedThreadPool" class="headerlink" title="3.2 FixedThreadPool"></a>3.2 FixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code> 只能创建核心线程，提交任务后核心线程空闲进行处理，不空闲则入列等待，等待的任务数量上限是 <code>Integer.MAX_VALUE</code>。</p><p>特点：</p><ul><li>只会创建核心线程</li><li>线程不会被回收，一直阻塞</li><li>几乎不会触发拒绝策略</li></ul><h4 id="3-3-SingleThreadExecutor"><a href="#3-3-SingleThreadExecutor" class="headerlink" title="3.3 SingleThreadExecutor"></a>3.3 SingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SingleThreadPool</code> 有且仅有一个核心线程工作，不会创建非核心线程，所有任务按 先来先服务的顺序执行。</p><h4 id="3-4-ScheduledThreadPool"><a href="#3-4-ScheduledThreadPool" class="headerlink" title="3.4 ScheduledThreadPool"></a>3.4 ScheduledThreadPool</h4><p><code>ScheduledThreadPool</code> 会创建一个定长线程池，支持定时和周期性任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>《阿里巴巴开发手册》中不推荐通过这些方法创建线程池，推荐通过调用 <code>ThreadPoolExecutor</code> 构造函数的方式创建，这样处理让创建线程池的同学需要明确业务场景，选择合适的参数。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://concurrent.redspider.group/article/03/12.html">深入浅出Java多线程</a></li><li><a href="https://book.douban.com/subject/2148132/">Java并发编程实践</a></li><li><a href="https://book.douban.com/subject/30333948/">码出高效</a></li><li><a href="https://www.bilibili.com/video/BV11A411V78m?spm_id_from=333.999.0.0">源码级解读ThreadPoolExecutor</a></li><li><a href="https://book.douban.com/subject/26591326/">Java并发编程的艺术</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(4) CAS</title>
      <link href="/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(4)%20CAS/"/>
      <url>/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(4)%20CAS/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a>1.  介绍</h2><p>锁可以分为：</p><ul><li>悲观锁：认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</li><li>乐观锁：总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。</li></ul><p>由于无锁操作中没有锁的存在，因此不会出现死锁，换句话说，乐观锁免疫死锁。</p><p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p><p>乐观锁底层依赖 CAS 实现，CAS，Compare and Swap，比较并交换，是一种乐观锁实现。CAS 有 3 个操作数，内存位置 V，期望值 A，新值 B，如果 V 中的值等于 A，则将 V 中的数据更新为 B；否则则不进行操作，最终返回 V 的数值。</p><h2 id="2-Java中的CAS"><a href="#2-Java中的CAS" class="headerlink" title="2. Java中的CAS"></a>2. Java中的CAS</h2><p><code>sun.misc.Unsafe</code> 包中提供了 CAS 支持。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* var1: 要操作的对象</span></span><br><span class="line"><span class="comment">* var2: 要操作的属性的地址偏移量</span></span><br><span class="line"><span class="comment">* var1 + var2 可以确定内存位置V的值</span></span><br><span class="line"><span class="comment">* var4: 期望值A</span></span><br><span class="line"><span class="comment">* var5: 新值B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>CAS 是 atomic 包的原子类的实现基础。例如 <code>AtmoicInteger</code> 的 <code>getAndSet</code> 方法，即通过 CAS 设置新值并返回旧值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-CAS底层实现"><a href="#3-CAS底层实现" class="headerlink" title="3. CAS底层实现"></a>3. CAS底层实现</h2><p>在 intel x86 平台下，CAS 通过 cmpxchg 指令实现：</p><ul><li>多处理器: 添加 lock 前缀</li><li>单处理器: 不添加 lock 前缀</li></ul><p>lock 前缀的指令具有以下特点：</p><ul><li>如果待访问的数据已经位于 cache 中，并且 Cache Line 的状态为已修改或独占，则直接更新，否则锁住总线进行更新</li><li>禁止该指令前后的读写指令重排序</li><li>将写缓冲区的数据刷新到内存</li></ul><h2 id="4-CAS-的不足"><a href="#4-CAS-的不足" class="headerlink" title="4. CAS 的不足"></a>4. CAS 的不足</h2><ul><li><p>循环时间长，高并发下开销大</p></li><li><p>只能保证一个变量的原子操作</p><p>解决方案：<code>AtomicReference</code> 类能够保证对象之间的原子性，可以把多个变量放到一个对象里面进行 CAS 操作。</p></li><li><p>ABA 问题：一个变量的数据由 A 改为 B 再改为 A，CAS 无法分辨</p><p>解决方案：增加了版本号 version</p><p>JDK 提供了 <code>AtomicStampedReference</code> 作为解决方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类Pair包括引用和版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * expectedReference: 期望引用</span></span><br><span class="line"><span class="comment">   * newReference: 新值引用</span></span><br><span class="line"><span class="comment">   * expectedStamp: 期望版本号</span></span><br><span class="line"><span class="comment">   * newStamp: 新版本号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 V   newReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp; <span class="comment">// 引用一致</span></span><br><span class="line">            expectedStamp == current.stamp &amp;&amp; <span class="comment">// 版本一致</span></span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp))); <span class="comment">// 设置新值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(3) synchronized</title>
      <link href="/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(3)%20synchronized/"/>
      <url>/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(3)%20synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p><code>synchronized</code> 是 Java 中的一个关键字，用于对代码块的互斥访问，是非公平可重入锁。</p><blockquote><p>公平锁指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，非公平锁则不保证该顺序性；可重入锁又称递归锁，指该获取到锁的线程，递归调用再次访问互斥代码块时，不会被阻塞。</p></blockquote><p><code>synchronized</code> 有三种加锁方式：</p><ul><li>普通方法，相当于给 实例对象加锁，进入同步代码之前要获得当前实例的锁</li><li>静态方法，相当于给类对象加锁</li><li>代码块，需要指定加锁对象</li></ul><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><p><code>synchronized</code> 经过编译之后，会在同步块前后形成 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，当执行 <code>monitorenter</code> 指令时，尝试获取锁，获取成功则计数 +1，执行 <code>monitorexit</code> 则计数 -1，当计数为 0 时，锁即被释放。</p><p><code>monitorenter</code> 和 <code>monitorexit</code> 两个指令，主要是基于 Mark Word 实现的。Java 的对象头由 Mark Word 和 Klass Point 组成。</p><ul><li><p>Mark Word：存储对象的运行数据，64 位 JVM 的 Mark Word 组成如下：</p><p><img src="markword.png" alt="Mark Word"></p><p>其中 monitor 字段即指向堆中相应的监视器对象。</p></li><li><p>Klass Point：指向类元数据（方法区中的 Klass 对象）的指针</p></li></ul><p>在 JVM 层面，监视器对象含有 owner 属性，当获取锁时，使用 CAS 尝试将该字段设置为当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 该线程获取锁的次数</span></span><br><span class="line">    _owner        = NULL; <span class="comment">// 持有ObjectMonitor对象的线程</span></span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 等待锁释放的线程队列</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-锁升级"><a href="#3-锁升级" class="headerlink" title="3. 锁升级"></a>3. 锁升级</h2><p>传统的锁（下文的重量级锁）依赖操作系统的同步函数，涉及用户态和内核态的切换，而程序实际运行时可能并不存在多线程竞争，此时使用这种机制是十分低效的。</p><p>针对上述问题，在 jdk 1.6 时引入偏向锁和轻量级锁，并搭配锁升级机制，解决没有多线程竞争和少量竞争的场景下重量级锁的性能开销问题。</p><h3 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h3><p>Hotspot 的开发人员发现很多情况下锁不存在多线程竞争，总由同一个线程多次获得，于是引入偏向锁。偏向锁会偏向第一个访问锁的线程，在接下来的运行过程中，如果该锁没有被其他线程访问，则持有偏向锁的线程将不会触发同步。偏向锁只在第一次获取锁时有一个 CAS 操作，后续操作只会执行几个简单的命令。</p><p>新创建对象的 Mark Word 是可偏向状态，其中的 thread id 为 0，称为匿名偏向。</p><h4 id="偏向锁的加锁"><a href="#偏向锁的加锁" class="headerlink" title="偏向锁的加锁"></a>偏向锁的加锁</h4><ul><li>该对象第一次被线程获取锁，为匿名偏向状态，会使用 CAS 尝试将 thread id 改为当前线程，成功则获得锁，否则撤销偏向锁，并升级为轻量级锁</li><li>被偏向的线程再次进入同步块，发现 thread id 为自身，则往当前线程栈中添加一条 Lock Record，并指向锁对象，执行同步代码块</li><li>当其他线程进入同步块，发生锁已偏向，进入撤销锁的逻辑</li></ul><p>锁升级的时机为：当锁已经发生偏向后，如果另一个线程尝试获得未释放的偏向锁，就会升级成轻量级锁。</p><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>偏向锁的撤销需要等待 safe point，暂停所有线程，并进行判断：</p><ul><li>偏向的线程仍存活并且在同步块中，则升级为轻量级锁，原偏向的线程继续拥有锁</li><li>偏向的线程已经死亡或者不在同步块，则将 Mark Word 改为无锁状态，升级为轻量级锁</li></ul><blockquote><p>hotspot 团队在多年验证之后发现，鉴于撤销锁的高成本，从整体而言偏向锁带来的性能提升没有太大收益，在 Java 15 中已经默认关闭偏向锁。</p></blockquote><h3 id="3-2-轻量级锁"><a href="#3-2-轻量级锁" class="headerlink" title="3.2 轻量级锁"></a>3.2 轻量级锁</h3><p>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁使用的操作系统互斥量带来的开销。</p><h4 id="轻量级锁的加锁"><a href="#轻量级锁的加锁" class="headerlink" title="轻量级锁的加锁"></a>轻量级锁的加锁</h4><p>JVM 会为每次线程在线程栈中创建空间存储锁记录 Lock Record，这个空间称为 Displaced Mark Word。如果一个线程获得锁时发现是轻量级锁，则将锁对象的 Mark Word 复制到自己的 Displaced Mark Word。</p><p>线程尝试用 CAS 自旋将锁的 Mark Word 替换为指向 Lock Record 的指针，成功则获取锁，失败则说明有其他线程在竞争锁。</p><p>当自旋超过一定次数之后，则会升级为重量级锁。</p><h4 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h4><p>释放锁时，当前线程使用 CAS 将 Displaced Mark Word 的内容复制回锁的 Mark Word，没有发生竞争则会成功，如果已经升级为重量级锁，则复制失败，此时会释放锁并唤醒被阻塞的线程。</p><h3 id="3-3-重量级锁"><a href="#3-3-重量级锁" class="headerlink" title="3.3 重量级锁"></a>3.3 重量级锁</h3><p>重量级锁依赖于操作系统的互斥量实现的，效率很低，但被阻塞的线程不会消耗 CPU。</p><p>一个 monitor 对象包括两个同步队列 cxq 和 EntryList，以及一个等待队列 WaitSet，都为 ObjectWaiter 组成的链表。</p><p><img src="重量级锁.png" alt="重量级锁底层实现"></p><p>当一个线程尝试获得重量级锁失败时，将该线程封装为 ObjectWaiter 插入到 cxq 队列队首，并挂起当前线程，进入 BLOCKED 状态；当线程释放锁时，会根据唤醒策略，从 cxq 或 EntryList 中挑选一个线程唤醒。</p><p>如果调用的是 wait 方法，则将该线程加入 WaitSet，该线程进入 WAITING 或 TIMED_WAITING 状态。当被 notify 唤醒后，会将线程从 WaitSet 移动到 cxq 或 EntryList 中去，进入 BLOCKED 状态。</p><p>锁升级的全流程如下图：</p><p><img src="锁升级.png" alt="锁升级流程"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://github.com/farmerjohngit/myblog/issues/12">死磕synchronized底层实现</a></li><li><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a></li><li><a href="http://concurrent.redspider.group/article/02/9.html">深入浅出Java多线程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(2): JMM和volatile</title>
      <link href="/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(2)%20JMM%E5%92%8Cvolatile/"/>
      <url>/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(2)%20JMM%E5%92%8Cvolatile/</url>
      
        <content type="html"><![CDATA[<h2 id="1-并发编程模型"><a href="#1-并发编程模型" class="headerlink" title="1. 并发编程模型"></a>1. 并发编程模型</h2><p>在并发编程中，必须解决两个问题：</p><ul><li>线程通信：线程之间通过什么机制交换信息</li><li>线程同步：用什么机制控制不同线程操作的相对顺序</li></ul><p>为了解决上述问题，有两种主流的并发模型：</p><ul><li>消息传递模型：线程之间没有公共状态，线程间通过发送消息进行通信，并且发送消息总是在接收消息之前，因此线程同步是天然的</li><li>共享内存模型：线程之间共享程序的公共状态，通过读写内存进行通信，线程同步必须显示指定某段代码在线程之间互斥执行</li></ul><p>消息传递模型的典型代表是 Go 中的 channel，而在 Java 中使用的是共享内存模型。</p><h2 id="2-共享内存模型的三个关键点"><a href="#2-共享内存模型的三个关键点" class="headerlink" title="2. 共享内存模型的三个关键点"></a>2. 共享内存模型的三个关键点</h2><p>当设计共享内存模型时，需要考虑三个关键点：</p><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h3><p>原子性指一个操作是不可中断的，即使在多线程环境中，一个操作一旦开始，也不会被另一个线程打断。</p><p>例如线程 A 和线程 B 同时对一个变量 i 赋值，A 给 i 赋值为 1， B 给 i 赋值为 2，原子性保证 i 的值要么是 1，要么是 2，不会出现其他的值。这样看来原子性保证仿佛是必然的，其实不然，例如对 64 位的 long 类型进行赋值，假设 long 类型的读写不是原子的，那么便可能存在预期之外的数字。</p><h3 id="2-2-可见性"><a href="#2-2-可见性" class="headerlink" title="2.2 可见性"></a>2.2 可见性</h3><p>可见性是指当一个线程修改某一个共享变量的值时，其他线程能够立即知道这个修改。</p><p>对于单线程程序而言，可见性问题是不存在的。在多线程程序中，可能由于缓存的存在，其他线程读取变量时读到的仍是旧值，怎么解决可见性问题也是并发编程的一个考虑点。</p><h3 id="2-3-有序性"><a href="#2-3-有序性" class="headerlink" title="2.3 有序性"></a>2.3 有序性</h3><p>有序性问题指程序在执行过程中，进行指令重排，导致与原指令的顺序未必一致，可能在多线程带代码中导致另一个线程读到脏值。</p><p>指令是否发生重排、如何重排是我们无法预测的，也就是说，线程 A 的执行顺序对于线程 B 而言是没有保证的，而日常开发中线程 B 的结果可能依赖线程  A 部分代码的运行顺序，所以便需要保持其有序性。</p><h2 id="3-JMM"><a href="#3-JMM" class="headerlink" title="3. JMM"></a>3. JMM</h2><h3 id="3-1-硬件的效率与一致性"><a href="#3-1-硬件的效率与一致性" class="headerlink" title="3.1 硬件的效率与一致性"></a>3.1 硬件的效率与一致性</h3><p>为了减少 CPU 和内存之间处理速度带来的限制，现代 CPU 引入了 cache 的概念，CPU 读取数据先从缓存中读取，读取失败后再从内存中读取。</p><p>由于每个 CPU 核心都包含 cache，这也引入了缓存一致性问题，CPU 层面通过 MESI 等缓存一致性协议解决了该问题。除了 cache 之外，为了提高 CPU 的运算效率，会对代码进行指令重排序和乱序执行，CPU 会保证最后的执行结果一致，但不保证代码顺序运行。 </p><blockquote><p>相关知识具体可见博客中的 程序员需要了解的计组知识(2) 和 (3) 。</p></blockquote><h3 id="3-2-JMM"><a href="#3-2-JMM" class="headerlink" title="3.2 JMM"></a>3.2 JMM</h3><p>JMM，Java Memory Model，Java 内存模型与硬件模型高度类似，并且在编译器层面也对指令进行重排序。</p><p>JMM 主要目的是定义程序中共享字段的访问规则。</p><ul><li>所有变量都存储在主内存中（虚拟机内存的一部分，不是计算机中的内存）</li><li>每条线程还要自己的工作内存，线程的工作内存保存了主内存的部分副本，线程对变量的所有操作必须在工作内存中进行</li><li>线程的工作内存是独立的，无法互相访问</li></ul><p><img src="jmm.png" alt="JMM"></p><p>所以当线程读取共享变量的值时，先在工作内存中寻找，如果变量已经被更新中，则从主内存中将数据拷贝到工作内存中。</p><h2 id="4-happens-before原则"><a href="#4-happens-before原则" class="headerlink" title="4. happens-before原则"></a>4. happens-before原则</h2><p>上文提到，java 在编译器层面会对指令进行重排序，保证单线程内的最终结果一致，那么对于多线程程序呢？</p><p>一方面，程序员需要 JMM 提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望 JMM 对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。</p><p>JMM 在其中找到了平衡点，对编译器和处理器来说，只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。也就是说，JMM 并不能保证未同步的多线程程序与其顺序执行的结果一致。</p><p>不过对程序员也提供了弥补错误，对于使用同步语意（<code>synchronized</code>、<code>volatile</code>、<code>Lock</code> 等），提供了 happens-before 原则，只要程序满足了该原则，便能保证运行结果与预期相同。happens-before定制了两个操作之间的执行顺序，其定义如下：</p><ul><li><p>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p></li><li><p>如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</p></li></ul><p>在 Java 程序中，有如下天然的 happens-before 关系：</p><ul><li>程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li><li>volatile 变量规则：对一个 <code>volatile</code> 域的写，happens-before 于任意后续对这个 <code>volatile</code> 域的读。</li><li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li><li>start 规则：如果线程 A 执行操作 <code>ThreadB.start()</code> 启动线程B，那么 A 线程的 <code>ThreadB.start()</code> 操作 happens-before 于线程 B 中的任意操作、</li><li>join 规则：如果线程 A 执行操作 <code>ThreadB.join()</code> 并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 <code>ThreadB.join()</code>   操作成功返回。</li></ul><h2 id="4-volatile"><a href="#4-volatile" class="headerlink" title="4. volatile"></a>4. volatile</h2><p>在 Java 中，<code>volatile</code> 关键字有两个作用：</p><ul><li>保证变量的内存可见性</li><li>禁止 <code>volatile</code> 变量和普通变量重排序</li></ul><h3 id="4-1-内存可见性"><a href="#4-1-内存可见性" class="headerlink" title="4.1 内存可见性"></a>4.1 内存可见性</h3><p>当一个线程对 <code>volatile</code> 修饰的变量进行写操作时， JMM 会立即把该线程对应的本地内存的值刷新到主内存；而对这个变量进行读操作时， JMM 会立即把该线程的本地内存置为无效，从主内存中读取共享变量的值。</p><p>内存可见性不代表线程安全，例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码允许之后 count 并不为 200000，这是由于自增操作并不保证原子性，所以仍不是线程安全的。</p><h3 id="4-2-禁止指令重排序"><a href="#4-2-禁止指令重排序" class="headerlink" title="4.2 禁止指令重排序"></a>4.2 禁止指令重排序</h3><p>如果允许 <code>volatile</code> 变量和普通变量重排序，可能会发生问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// step 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// step 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// step 3</span></span><br><span class="line">            System.out.println(a); <span class="comment">// step 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中线程 A 调用 writer，线程 B 调用 reader。可能出现以下场景：</p><ul><li>线程 A 设置 flag 为 true</li><li>线程 B 读取 flag 为 true</li><li>线程 B 读普通变量 a 的值为 0</li><li>线程 A 写普通变量 a 的值为 1</li></ul><p>虽然 <code>volatile</code> 保证了内存可见性，但是普通变量的值发生了读取错误。</p><p>因此 jdk 1.5 中增强了 <code>volatile</code> 的内存语义，禁止 <code>volatile</code> 变量和普通变量重排序。JVM 层面通过内存屏障来实现，内存屏障是硬件层面而言的，有两个作用：</p><ul><li>屏障两侧的指令进制重排序</li><li>强制把 cache 中的脏数据写入内存，或者使相应的 cache line 失效</li></ul><p>内存屏障有 LoadLoad、LoadStore、StoreStore、StoreLoad 四种。</p><blockquote><p>其规则是 Store 为写指令，Load 为读指令，并按顺序代表屏障前后的指令。例如 LoadLoad 即屏障前后都是读指令，LoadStore 即屏障前是读指令，屏障后是写指令。</p></blockquote><p>对于 <code>volatile</code> 而言，其策略是</p><ul><li>在每个 <code>volatile</code> 写操作前插入一个 StoreStore 屏障</li><li>在每个 <code>volatile</code> 写操作后插入一个 StoreLoad 屏障</li><li>在每个 <code>volatile</code> 读操作后插入一个 LoadLoad 屏障</li><li>在每个 <code>volatile</code> 读操作后再插入一个 LoadStore 屏障</li></ul><p><code>volatile</code> 禁止重排序的功能最经典的用法是双重检测的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：因为代码复杂，考虑点多，日常开发中不建议双重检测的单例模式，更加推荐使用静态内部类或者枚举的形式，具体可见作者的 小话设计模式(2)。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://concurrent.redspider.group/">深入浅出Java多线程</a></li><li><a href="https://book.douban.com/subject/26663605/">实战Java高并发程序设计</a></li><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/26591326/">Java并发编程的艺术</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(1): 多线程基础</title>
      <link href="/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(1)%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(1)%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><p>在谈论什么是线程之前需要先介绍一下进程。最初的计算机运行方式是串行的，当程序通过网络、IO 请求资源时，必须等待操作完成，在这段等待的时间中计算机的 CPU 资源便被浪费了。为了提高计算机的运行效率，计算机科学家们创建了操作系统，并提出了进程的概念。</p><blockquote><p>程序等待资源返回的过程称为 阻塞。</p></blockquote><p>进程即运行的程序，包括程序代码和资源两个部分，各个进程之间互不干扰，并且保存着各自的运行状态。当遇到网络、IO 等导致进程阻塞时，操作系统将其他可运行的进程调度到 CPU 上运行，提高了计算机的运行效率，给用户一种一段时间内多个程序同时运行的感觉，这被称之为并发。</p><blockquote><p>关于并发与并行，并发指多个任务交替运行，不限制 CPU 核心数；而并行指多个任务在多个 CPU 核心上同时执行，要求是多核 CPU。</p></blockquote><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h3><p>虽然进程的出现提高了计算机的运行效率，但进程对于开发者而言还是存在一些问题：</p><ul><li><p>多进程的通讯较为繁琐，虽然操作系统提供一系列的通信手段，但是对于开发者而言需要熟悉相应操作系统的 API 才能够实现进程通信</p></li><li><p>进程切换的代价太高了，进程的调度过程涉及进程大量资源替换，是一个耗时的工作</p></li></ul><p>于是，计算机科学家们提出了一个新的概念，线程。多个线程共享同一个进程的地址空间，并且更加轻量，相较进程切换成本有所降低。线程是对逻辑的抽象，而进程是对资源的抽象。</p><h3 id="1-3-上下文切换"><a href="#1-3-上下文切换" class="headerlink" title="1.3 上下文切换"></a>1.3 上下文切换</h3><p>当操作系统将一个进程（或线程）切换到另一个进程（或线程）时，需要涉及上下文切换。上下文是指某个时间点 CPU 寄存器和程序计数器的内容，在切换前需要保存当前的上下文，下次切换为这个任务时，可以再加载这个任务的状态，这个上下文保存再加载的过程就是上下文切换。</p><p>上下文操作会消耗大量的 CPU 时间，适合 IO 密集型应用，而对于计算密集型应用，使用太多线程会导致大量的上下文切换，反而会导致性能降低。</p><blockquote><p>计算密集型指操作主要是 CPU 进行计算，较少涉及 IO 操作。IO 密集型指应用经常需要请求 IO 资源，易进入阻塞状态。</p></blockquote><h3 id="1-4-线程实现方式"><a href="#1-4-线程实现方式" class="headerlink" title="1.4 线程实现方式"></a>1.4 线程实现方式</h3><p>(1) 内核线程实现</p><p><img src="内核线程实现.png" alt="内核线程实现"></p><p>由内核通过调度器来完成线程切换，优点是每个线程是独立的调度单元，线程之间互不影响，但缺点是线程创建和切换开销大。</p><p>(2) 用户线程实现</p><p><img src="用户线程实现.png" alt="用户线程实现"></p><p>完全建立在用户空间，内核无法感知线程的存在，内核只对线程所属的进程进行控制。优点是不依赖内核实现，但用户需要在用户态实现线程创建和调度功能，一般只在不支持多线程的操作系统上使用，实现并发。</p><p>(3) 混合实现</p><p><img src="混合实现.png" alt="混合实现"></p><p>即存在用户线程，也存在轻量级进程，支持大规模的用户线程并发，同时使用内核线程进行调度和处理映射。用户线程和内核线程的映射有 1:1，M:N 两种形式，Java 线程为 1:1 的形式，Go 的 goroutine 为 M:N 的形式。</p><h2 id="2-在Java中使用多线程"><a href="#2-在Java中使用多线程" class="headerlink" title="2. 在Java中使用多线程"></a>2. 在Java中使用多线程</h2><p>在 Java 中有三种线程创建方式，分别为继承 <code>Thread</code> 类，实现 <code>Runnable</code> 接口和实现 <code>Callable</code> 接口。</p><h3 id="2-1-继承-Thread"><a href="#2-1-继承-Thread" class="headerlink" title="2.1 继承 Thread"></a>2.1 继承 Thread</h3><p>继承 <code>Thread</code> 的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意需要调用 <code>start()</code> 方法后，才会创建线程。</p><p>由于 Java 只支持单继承，如果继承了 <code>Thread</code> 类，便无法继承其他类，故直接继承的方式在实际开发中很少使用。</p><h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h3><p>实现<code>Runnable</code> 接口的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 采用函数式编程实现</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java 8 匿名内部类&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-实现Callable接口"><a href="#2-3-实现Callable接口" class="headerlink" title="2.3 实现Callable接口"></a>2.3 实现Callable接口</h3><p>实现 <code>Runnable</code> 接口没有返回值，如果我们需要任务运行后的返回值，这时候应该实现 <code>Callable</code> 接口，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallerTask());</span><br><span class="line">        <span class="keyword">new</span> Thread(task).run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;call&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：继承 <code>Thread</code> 的方式较少使用，实现 <code>Runnable</code> 接口在不需要任务返回值的场景使用，需要返回值则采用实现 <code>Callable</code> 接口的方式。</p><h2 id="3-线程状态与切换"><a href="#3-线程状态与切换" class="headerlink" title="3. 线程状态与切换"></a>3. 线程状态与切换</h2><h3 id="3-1-线程状态"><a href="#3-1-线程状态" class="headerlink" title="3.1 线程状态"></a>3.1 线程状态</h3><p><code>Thread</code> 类中定义了线程的状态为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;  </span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="New"><a href="#New" class="headerlink" title="New"></a>New</h4><p>当创建 <code>Thread</code> 并且未调用 <code>start()</code> 方法时，操作系统还未为此创建线程，此时处于 <code>New</code> 状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br></pre></td></tr></table></figure><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>调用<code>start()</code> 方法之后，<code>Thread</code> 处于 <code>Runnable</code> 状态，该状态并不一定在 CPU 上运行。</p><blockquote><p><code>Runnable</code> 在操作系统的状态中还细分为 <code>READY</code> 和 <code>RUNNING</code>，<code>RUNNING</code> 才是在 CPU 上运行。Java 团队认为 <code>READY</code> 切换到 <code>RUNNING</code> 的时间较短，故在 java 中不进行区分。</p></blockquote><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>当线程执行完毕后，状态就变为 <code>TERMINATED</code>，该状态不可逆。</p><h4 id="BLOKCED"><a href="#BLOKCED" class="headerlink" title="BLOKCED"></a>BLOKCED</h4><p>当线程竞争锁失败之后，状态变为 <code>BLOCKED</code> 状态，阻塞等待锁的释放。</p><blockquote><p>BLOCKED 状态不关心内核线程的阻塞态，只针对 Java 层面的锁，例如 <code>synchronized</code>，<code>Lock</code> 等。操作系统的线程在遇到 IO 等也会进入阻塞状态，此时 <code>Thread</code> 的状态是 <code>Runnable</code>。</p></blockquote><h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h4><p>该状态下，线程等待并且无时间限制。</p><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>等待状态，但有时间限制，如果超时则转换为 <code>RUNNABLE</code> 状态。</p><h3 id="3-2-状态切换"><a href="#3-2-状态切换" class="headerlink" title="3.2 状态切换"></a>3.2 状态切换</h3><h4 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h4><p><code>wait</code> 和 <code>notify</code> 是 Java 多线程等待/通知机制的一种，以下是使用示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadA: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadB: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">ThreadA: <span class="number">0</span></span><br><span class="line">ThreadB: <span class="number">0</span></span><br><span class="line">ThreadA: <span class="number">1</span></span><br><span class="line">ThreadB: <span class="number">1</span></span><br><span class="line">ThreadA: <span class="number">2</span></span><br><span class="line">ThreadB: <span class="number">2</span></span><br><span class="line">ThreadA: <span class="number">3</span></span><br><span class="line">ThreadB: <span class="number">3</span></span><br><span class="line">ThreadA: <span class="number">4</span></span><br><span class="line">ThreadB: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>在上述代码中，线程 A 和线程 B 首先打印出自己的信息，然后使用 <code>notify()</code>方法叫醒另一个正在等待的线程，然后自己使用 <code>wait()</code> 方法陷入等待并释放 lock 锁。</p><blockquote><p><code>notify()</code> 会唤醒一个等待的线程，与其对应的还有一个 <code>notifyAll()</code>，会唤醒所有等待的线程。</p><p><code>wait</code>、<code>notify</code>、<code>notify</code> 需要和 <code>synchronized</code> 配合使用。 </p></blockquote><p>当一个线程调用 <code>wait()</code> 方法后，会进入 <code>WAITING</code> 状态，直到其他线程调用相应的 <code>notify()</code> 方法。</p><p>如果调用 <code>wait(long timeout)</code> ，则进入 <code>TIMED_WAITING</code> 状态。</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>线程调用 <code>sleep(long timeout)</code>，进入 <code>TIMED_WAITING</code> 状态，与 <code>wait(long timeout)</code> 的区别是 <code>sleep</code> 不释放锁。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>调用 <code>join()</code> 之后，当前线程必须等待另一个线程执行完毕，<code>join()</code> 的底层实现是 <code>wait()</code>，与 <code>wait()</code> 的状态转移一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(...);</span><br><span class="line">test.start();</span><br><span class="line"><span class="comment">// 当前线程必须等待test线程执行完毕</span></span><br><span class="line">test.join();</span><br></pre></td></tr></table></figure><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>当一个线程调用 <code>yield()</code> 之后，会主动让出 CPU，进入 <code>RUNNABLE</code> 状态等待调度。</p><h4 id="park和unpark"><a href="#park和unpark" class="headerlink" title="park和unpark"></a>park和unpark</h4><p>每个线程都与一个许可(permit)关联。<code>unpark</code> 函数为线程提供 permit，线程调用 <code>park</code> 则等待（进入 <code>WAITING</code> 状态）并消耗permit。<code>park</code> 和 <code>unpark</code> 方法具体实现比较复杂，这里不展开。</p><h4 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h4><p>综上，我们可以得到 <code>Thread</code> 的状态转移图。</p><p><img src="状态转移图.png" alt="Thread状态转移图"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://concurrent.redspider.group/">深入浅出Java多线程</a></li><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/30351286/">Java并发编程之美</a></li><li><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员需要了解的计组知识(3): 存储器</title>
      <link href="/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3)%20%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3)%20%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-存储金字塔"><a href="#1-存储金字塔" class="headerlink" title="1. 存储金字塔"></a>1. 存储金字塔</h2><p>计算机中使用的存储器可分为</p><ul><li><p>RAM ：静态存储器，读写速度快。举例 CPU Cache</p></li><li><p>DRAM ：动态存储器，读写速度慢，集成度高，掉电失去数据。举例 内存</p></li><li><p>硬盘</p></li></ul><p>计算机中使用的存储设备构成了存储器金字塔。</p><p><img src="存储金字塔.png" alt="存储金字塔"></p><p>各层存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降。上一层的存储器可以看出下一层存储器的缓存。</p><h2 id="2-局部性原理"><a href="#2-局部性原理" class="headerlink" title="2. 局部性原理"></a>2. 局部性原理</h2><p>上文说到，上层存储是下层存储的缓存，那么通过添加缓存能加快访问吗？</p><p>是的，计算机的前辈们概括出了局部性原理，包括：</p><ul><li>时间局部性：刚被访问的数据，短时间内容易被再次访问</li><li>空间局部性：刚被访问的数据，其附近的数据容易被访问</li></ul><p>其中时间局部性在 内存管理 中得到广泛应用，空间局部性在 cache、文件系统、磁盘缓存、数据库 中得到广泛应用。</p><h2 id="3-cache"><a href="#3-cache" class="headerlink" title="3. cache"></a>3. cache</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>在过去几十年的计算机发展中，CPU 的性能提升远超内存，内存的存取速度严重滞后于处理器的计算速度，内存瓶颈导致高性能处理器难以发挥出应有的功效，这对日益增长的高性能计算形成了极大的制约，这一问题称为 内存墙 Memory Wall。</p><p>为了弥补 CPU 和内存之间的性能差距，在 CPU 中引入高速缓存 cache，CPU 先从 cache 尝试访问数据和指令，访问失败再从内存中访问。</p><p>现在的 CPU 一般包含 L1、L2、L3 三级 cache，前一级可以当成后一级的缓存，L3 cache 作为内存的缓存。L1、L2 每个核心独有，而 L3 缓存所有核心共用。</p><p>根据空间局部性原理，cache 从内存中读入是按块进行的，这样一块数据，称之为 cache line，cache line 的大小通常是 64 字节。</p><h3 id="3-2-伪共享问题"><a href="#3-2-伪共享问题" class="headerlink" title="3.2 伪共享问题"></a>3.2 伪共享问题</h3><p>cache 每次都会读入一个 cache line 大小的数据，在多线程环境中，如果两个线程各自的变量（共两个）被放在同一个 cache line，每次写其中一个变量将导致整个 cache line 失效，相当于只有一个线程可以同时访问这个 cache line，降低了访问速度，这被称为伪共享问题。</p><p>伪共享问题的解决方案是进行字节填充。即增加没有实际意义的填充字段，保证一个 cache line 中只能存储一个对象，在 Java 中可以使用 <code>@Contended</code> 注解实现。</p><h3 id="3-3-缓存一致性"><a href="#3-3-缓存一致性" class="headerlink" title="3.3 缓存一致性"></a>3.3 缓存一致性</h3><p>在多核 CPU 中，每个核都会有 L1 和 L2 缓存，对于内存中的同一个数据，两个核心的 cache 都进行了缓存，当其中一个核心的程序对该变量进行修改后，另一个核心的 cache 还保留着改动前的数据，可能会业务逻辑错误，这被称为缓存一致性问题。</p><p>解决一致性问题最常见的方案是总线嗅探，即所有的读写请求都经过总线进行广播，其他核心根据这些广播更新自己的缓存。基于总线嗅探有很多实现协议，其中最常见的是 MESI 协议。</p><p>MESI 协议，是一种写失效协议。在写失效协议中，只有一个 CPU 核心负责写入数据，其他的核心只是同步读取到这个写入。在一个 CPU 核心写入 cache 之后，会广播一个“失效”请求告诉所有其他的 CPU 核心，其他的 CPU 核心判断是否需要将相应的 cache line 标记为脏。</p><p>MESI 对应着 Cache Line 的四个标记：</p><ul><li><p>M：已修改，Modified，脏数据</p></li><li><p>E：独占，Exclusive；当前数据为该 cache 独占，写入不需要广播，如果接收到读取请求，则转变为 S 标记</p></li><li><p>S：共享，Shared；写入前需要进行广播，要求其他核心的 cache line 失效，再更新数据</p></li><li><p>I：已失效，Invalidated，脏数据</p></li></ul><p>其状态图如下</p><p><img src="mesi.png" alt="MESI状态转移"></p><p>说明：C、C++、Java 中均有 <code>volatile</code> 关键字，被 <code>volatile</code> 修饰的变量，写入时直接写入内存，读取时直接从内存读取，底层便依赖 MESI 协议实现。</p><h2 id="4-NUMA"><a href="#4-NUMA" class="headerlink" title="4. NUMA"></a>4. NUMA</h2><p>numa 非统一内存访问是一种关于多个 CPU 核心如何访问内存的架构模型，现在的 CPU 基本都是 numa 架构。</p><p>numa 架构简单而言就是一个 CPU 核心和一组内存插槽构成一个 node，每个核心可以访问自己 node下的内存，也可以访问其他 node 的内存，但是访问自己 node 内存的速度快于其他 node。</p><p><img src="numa.jfif" alt="NUMA示意"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><p><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></p></li><li><p><a href="https://time.geekbang.org/column/intro/100026001">极客时间：深入浅出计算机组成原理</a></p></li><li><p><a href="https://book.douban.com/subject/1230413/">深入理解计算机系统</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Random-access_memory#Memory_wall">memory wall wikipedia</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员需要了解的计组知识(2): CPU</title>
      <link href="/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2)%20CPU/"/>
      <url>/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2)%20CPU/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>CPU 从功能上由控制器、运算器、寄存器和时钟四个部分组成，CPU 需要与内存、IO 设备配合工作。程序启动后，根据时钟信号，CPU 会从内存中不断读取指令和数据进行运算，控制器再根据运算结果进行控制。</p><p><img src="cpu组成.png" alt="CPU组成"></p><p>这些指令就是最底层的机器语言，由 0 和 1 组成，程序员无法直接阅读，故引入汇编语言。汇编语言是 “给程序员看的机器码”，汇编语言与机器码一一对应，通常将汇编语言转换为机器码的过程称为汇编，将机器码转换为汇编语言称为反汇编。</p><p>对于程序员而言，我们只需要关注其中的寄存器，CPU 是寄存器的集合。</p><h2 id="2-程序控制"><a href="#2-程序控制" class="headerlink" title="2. 程序控制"></a>2. 程序控制</h2><h3 id="2-1-逻辑跳转"><a href="#2-1-逻辑跳转" class="headerlink" title="2.1 逻辑跳转"></a>2.1 逻辑跳转</h3><p>CPU 执行指令，是一条条按顺序执行的，并且有一个 PC 寄存器用来存储下一条要执行指令的地址，上文说到的 CPU 从内存中读取指令，便是根据 PC 寄存器中存放的地址，从内存中加载指令执行。</p><p>汇编语言中包含 jmp、jne、goto 等指令，会直接或者间接改变 PC 寄存器的值，达到代码跳转的效果。平常代码中的 if else、for/while 循环等会被编译成这些指令，实现逻辑控制的效果。</p><h3 id="2-2-函数调用"><a href="#2-2-函数调用" class="headerlink" title="2.2 函数调用"></a>2.2 函数调用</h3><p>函数调用也是通过设置 PC 寄存器为函数的地址实现的，与逻辑跳转不一样的地方在于，函数调用不是使用 jmp 等指令，而是采用 call 和 return 两个指令。</p><p>call 指令会将函数执行后的下一条指令地址存放在栈中，而 return 指令会将栈顶的指令地址给 PC 寄存器赋值。</p><p><img src="函数调用1.png" alt="函数调用1"></p><p><img src="函数调用2.png" alt="函数调用2"></p><h2 id="3-堆和栈"><a href="#3-堆和栈" class="headerlink" title="3. 堆和栈"></a>3. 堆和栈</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行时，OS 会预先分配一段内存，用于存储数据。</p><p>对于动态的内存占用（例如 C 语言中的 malloc），会从预先分配的内存中划分出一部分，这种用户主动请求而划分的内存，称之为堆，堆的一个特点是不会自动释放，依赖用户或者垃圾收集器进行回收。</p><p>函数调用需要在内存中创建一个帧，用于存储函数的内部变量，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 test 函数前，需要将 x 先存放在内存之中，而函数执行过程中变量 a 和 b 也需要存储在帧中。在函数调用结束之后，帧的内存会被自动回收，而这块内存称之为栈。</p><p>说明：</p><ul><li>数据结构中的堆是用数组实现的二叉树，其父节点的值比所有子节点的大/小。本节讨论的堆主要针对内存而言，两者没有实质联系</li><li>在日常交流或者其他技术文章中会存在 堆栈 这个概念，而 堆栈 = 栈</li></ul><h2 id="4-一些科普"><a href="#4-一些科普" class="headerlink" title="4. 一些科普"></a>4. 一些科普</h2><ul><li>乱序执行：为了提高运行效率，CPU 不严格按照指令出现的顺序执行，例如下面的计算，d 依赖 a 的结果，必须在  a = b + c 允许之后计算，但 x 与 a、d 没有关系，x 的计算可能在 a、d 计算之前，也可能在 a、d 计算之后。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b + c</span><br><span class="line">d = a * c</span><br><span class="line">x = y * z</span><br></pre></td></tr></table></figure><ul><li>指令集架构：分为复杂指令集 CISC 和精简指令集 RISC。RISC 指令固定长度，代表是 ARM；CISC 指令不固定长度，代表是 Intel。</li><li>x86 架构：狭义的 x86 架构指只支持 32 位的 Intel/AMD 的 CPU；x86_64 架构又称 x64 架构，支持 32 位和 64 位，指令集与 x86 兼容，目前绝大部分的 Intel/AMD CPU 属于这个体系；广义的 x86 架构，泛指 x86 + x64。程序员谈论的 x86 一般指广义上的，即 Intel/AMD 的 CPU。</li><li>超线程：Intel 的技术商标，更广泛的概念叫 同步多线程 Simultaneous Multithreading。不同于软件级别的多线程，超线程将一个物理 CPU 分成两个逻辑部分 ，例如在 CPU 有两份相同的寄存器，每份寄存器存储一个任务的运行环境，在一个任务无法进行时可以极快切换到另一个任务运行。我们平时看到的 8 核 16 线程便属于超线程的范畴。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></li><li><a href="https://time.geekbang.org/column/intro/100026001">极客时间：深入浅出计算机组成原理</a></li><li><a href="https://zh.wikipedia.org/wiki/X86-64">x86-64 wikipedia</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程 阮一峰</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员需要了解的计组知识(1): 二进制数</title>
      <link href="/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1)%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <url>/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1)%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>计算机内部由集成电路 IC 这种电子部件构成的，IC 的一个引脚有 0V 或 5V 两个状态，这个特性决定了计算机的信息采用二进制数来处理。</p><p>计算机处理信息的最小单位是位，位的英文 bit 是 binary digit 的缩写。由于 CPU 的位数一般是 8 的倍数，将 8 位二进制数称为一个字节 byte。</p><h2 id="2-补码"><a href="#2-补码" class="headerlink" title="2. 补码"></a>2. 补码</h2><p>正整数的二进制和十进制的转换不做具体介绍，这里主要介绍整数在计算机的表示：补码。</p><p>二进制数表示负数时，一般将最高位作为符号使用。假设整数用 8 位来表示，一个直观想法是 1 的二进制为 <code>0000 0001</code>，那么 - 1 的二进制为  <code>1000 0001</code>，这种符合人脑运算的表示称为原码。</p><p>但是原码对于计算机运算存在一定问题，例如 1+ (-1) 的二进制结果为 <code>1000 0010</code>，按照原码表示为 -2，与实际运算不相符。 针对运算问题引入补码的概念，补码的思想是使用正数来表示负数。</p><p>要计算补码之前，先要介绍一下反码，正数的反码等于自身，负数的反码在其原码的基础上，符号位不变，其余各位取反，例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure><p>反码的应用是用于计算补码，正数的补码等于自身，负数的补码等于其反码 + 1，例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure><p>补码虽然直观不易理解，但逻辑十分严谨，例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + (-1) = 00000001 + 11111111 = 1 0000 0000 = 0(舍弃溢出位)</span><br></pre></td></tr></table></figure><p>x 位有符号二进制数能表示的范围为 <script type="math/tex">-2^{x}</script> 到 <script type="math/tex">2^{x} -1</script>，在日常开发中，需要注意溢出问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2147483647</span>;</span><br><span class="line">        a++;</span><br><span class="line">        System.out.println(a); <span class="comment">// -2147483648</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>计算机使用补码来表示整数</p></li><li><p>正数的原码、反码、补码都等于自身</p></li><li>负数的补码 = 其绝对值的反码 + 1</li></ul><h2 id="3-浮点数"><a href="#3-浮点数" class="headerlink" title="3. 浮点数"></a>3. 浮点数</h2><h3 id="3-1-定点数"><a href="#3-1-定点数" class="headerlink" title="3.1 定点数"></a>3.1 定点数</h3><p>日常生活中并不是所有数据都是整数，那么如何用二进制表示实数呢？</p><p>假如用 32 bit 表示实数，一个直观的想法是每 4 bit 表示 0 - 9 的数字，并且规定最右边的 2 个 0 - 9 的整数当成小数部分，例如 <code>0000 0000 0000 0000 0000 0011 0001 0100</code> 表示为 3.14，这种表示称为定点数。定点数表示实数简单易读，但是存在以下问题：</p><ul><li>浪费位数。4 bit 能够表示 0 - 15 的数字，只使用了其中 0 - 9 的部分</li><li>无法同时表示很大和小数部分很精确的数字。由于定点只有一个，小数部分越精确，整数部分的范围就小了，如果程序中的同时存在很大和小数部分很精确的数，便无法用定点数表示</li></ul><h3 id="3-2-浮点数"><a href="#3-2-浮点数" class="headerlink" title="3.2 浮点数"></a>3.2 浮点数</h3><p>针对上述定点数的问题，引入了浮点数的概念，IEEE 对浮点数定义了两个基本格式，分为单精度 32 bit 和双精度 64 bit，这里以单精度进行介绍。</p><p>单精度浮点数可以分为三部分：</p><ul><li>符号位，1 bit，1 表示正数，0 表示负数，称为 s</li><li>指数位，8 bit，称为 e。8 bit 能够表示的无符号整数范围为 0 - 255，将其中的 1 - 254 映射到 -126 -127（不包含 0），例如 -126 为区间内第 1 个整数，表示为 <code>0000 0001(1)</code>；-1 为第 126 个，表示为<code>0111 1110(126)</code></li><li>有效位，23 bit，称为 f。每一位依次表示  <script type="math/tex">2^{-1}</script>，<script type="math/tex">2^{-2}</script>、<script type="math/tex">2^{-3}</script>  … 例如 <script type="math/tex">0.5 = 2^{-1}</script>，表示为 1000……，<script type="math/tex">0.75 = 2^{-1} + 2^{-2}</script>​，表示为 11000….</li></ul><p><img src="单精度浮点数.png" alt="IEEE 单精度浮点数格式"></p><p>浮点数即可表示为</p><script type="math/tex; mode=display">(-1)^s \times (1 + f) \times 2^e</script><p>这里给出两种计算方法：</p><h5 id="计算方法1"><a href="#计算方法1" class="headerlink" title="计算方法1"></a>计算方法1</h5><p>0.5 可以表示为</p><script type="math/tex; mode=display">0.5 = (-1)^0 \times 1.0 \times 2^{-1}</script><p>即 s = 0，e = -1（需要用 126 表示），f = 0。0.5 的浮点数二进制表示即为 <code>0-01111110-0000000 00000000 00000000</code>。</p><p>1.5 可以表示为</p><script type="math/tex; mode=display">1.5 = (-1)^0 \times 1.5 \times 2^0</script><p>即 s = 0，e = 0（需要为 127 表示），f = 0.5（2 的 -1 次方，二进制表示第一位为 1，其余为 0），二进制表示为 <code>0-011111111-0000000000000000000000</code></p><p>细心的同学会发现上述公式无法表示数字 0，故 IEEE 规定当 e 和 f 的比特位都全为 0 时，表示数字 0。</p><h5 id="计算方法2"><a href="#计算方法2" class="headerlink" title="计算方法2"></a>计算方法2</h5><p>另一种对浮点数的计算方式是对于实数 x，确定指数 e 使  <script type="math/tex">2^{e} \le x < 2^{e+1}</script>，将该区间分为  <script type="math/tex">2^{23}</script> 份，f 的整数表示 x 在的小区间的位置（以 0 开始）。</p><p>对于实数 0.5，确定指数 e 为 -1，并且 0.5 位于第 0 个小区间，二进制表示为  <code>0-01111110-0000000 00000000 00000000</code>。</p><p>对于实数 1.5，确定指数 e 为 0, 将 <script type="math/tex">2^{0}</script> ~ <script type="math/tex">2^{1}</script> 分为 <script type="math/tex">2^{23}</script> 个小区间，1.5 位于第   <script type="math/tex">2^{22}</script> 个小区间，二进制表示为 <code>0-01111111-10000000000000000000000</code>。</p><h3 id="3-3-浮点数精度丢失"><a href="#3-3-浮点数精度丢失" class="headerlink" title="3.3 浮点数精度丢失"></a>3.3 浮点数精度丢失</h3><p>浮点数的精度损失主要来源两方面，一方面是实数本身无法精确表示，例如数字 1.1 ，确定指数 e 为 0，将 1 - 2 划分 $2^{23}$ 个小区间后，1.1 不在区间的两端，无法进行精确表示。</p><p>另一方面来自运算可能导致的损失，浮点数进行加法运算的规则很简单：先对齐，再计算。</p><ul><li>先将两个浮点数的指数位变成一样的，选择更大的指数位</li><li>进行加法计算</li></ul><p>例如数字 0.5，e = -1, f = 0；0.125，e = -3, f = 0，计算 0.5 + 0.125 时，首先将两个指数位统一为较大的 -1，其中 0.125 的有效数位 1.00 要右移两位，变为 0.01，两者的有效数位相加为 1.01，而指数位是 -1，这样便得到相加后的结果。</p><p>可以发现，指数位较小的数需要进行右移运算，会丢弃最右侧的有效位，32 位浮点数的有效长度为 23 位，如果两个浮点数大小差 <script type="math/tex">2^{24}</script> 倍，相加之后，结果不会变化，即所谓的大数吃小数问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a = <span class="number">20000000.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> b = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> c = a + b;</span><br><span class="line">        System.out.println(<span class="string">&quot;c is &quot;</span> + c); <span class="comment">// c is 2.0E7</span></span><br><span class="line">        <span class="keyword">float</span> d = c - a;</span><br><span class="line">        System.out.println(<span class="string">&quot;d is &quot;</span> + d); <span class="comment">// d is 0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题可以通过 <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan-Summation</a> 算法解决，此处不进行具体介绍，感兴趣的可以自行搜索。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></li><li><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示</a></li><li><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li><li><a href="https://time.geekbang.org/column/intro/100026001">极客时间：深入浅出计算机组成原理</a></li><li><a href="https://book.douban.com/subject/30333948/">码出高效: Java开发手册</a></li><li><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式相关理论</title>
      <link href="/2022/01/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
      <url>/2022/01/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-CAP"><a href="#1-CAP" class="headerlink" title="1. CAP"></a>1. CAP</h2><p>CAP 是分布式系统的三个指标：</p><ul><li>Consistency：一致性</li><li>Availability：可用性</li><li>Partition Tolerance：分区容错性</li></ul><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>一致性指在更新操作完成之后，所有节点在同一时间的数据完全一致，不存在中间状态。</p><p>数据一致性可分为：</p><ul><li>强一致性：任意时刻客户端获取到的各个节点数据都是一致的</li><li>最终一致性：允许存在中间状态，但要求经过一段时间之后，数据最终是一致的</li><li>弱一致性：允许部分数据不一致</li></ul><p>注：数据库事务也有一致性的概念，这个一致性指系统从一个正确的状态到另一个正确的状态；而分布式场景中的一致性指各副本数据之间的关系。两个一致性没有任何联系。</p><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>可用性要求系统提供的服务必须一致是可用的状态，对于用户的每一个请求能在有限的时间内返回正常的结果。</p><p>其两个指标：</p><ul><li>有限时间：系统的响应时间必须是一个用户可接受的值</li><li>正常结果：无论操作成功还是失败，系统能返回一个用户能够理解的响应。例如返回一个系统内存错误 OOM 便不是一个正常结果 </li></ul><h4 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h4><p>系统在遇到网络分区故障时，仍然能够保证对外提供服务。</p><p>网络分区是系统中存在多个子网络，子网络之间通信异常，但内部通信是正常的，从而使系统被分为若干个区域。</p><h3 id="1-2-CAP-的应用"><a href="#1-2-CAP-的应用" class="headerlink" title="1.2 CAP 的应用"></a>1.2 CAP 的应用</h3><p><img src="cap.png" alt="CAP"></p><p>在分布式系统中，P 是基本条件，因为分区是一种错误，它是必然会发生的，而不是一个可选项，如果不能保证 P，那么出现分区，系统便无法工作，这是无法接受的。所以，对于分布式系统，我们只能选择  C 或者 A。</p><h4 id="CP系统"><a href="#CP系统" class="headerlink" title="CP系统"></a>CP系统</h4><p>系统发生分区故障之后，客户端的任何请求都卡死或者超时，但是系统的每个节点都鞥你返回一致的数据。</p><h4 id="AP系统"><a href="#AP系统" class="headerlink" title="AP系统"></a>AP系统</h4><p> 系统发生分区故障之后，客户端能够访问系统，但是不能保证获取到的数据是最新的数据。</p><h3 id="1-3-CAP-的不足"><a href="#1-3-CAP-的不足" class="headerlink" title="1.3 CAP 的不足"></a>1.3 CAP 的不足</h3><ul><li>CAP 理论没有考虑网络延迟的问题，认为各节点的数据同步是瞬时的，与现实不符。这导致分布式大多选用 AP 方式</li><li>CAP 只是一种状态的描述，对于工程领域以及系统设计并没有帮助</li></ul><h2 id="2-BASE定理"><a href="#2-BASE定理" class="headerlink" title="2. BASE定理"></a>2. BASE定理</h2><p>由于 CAP 的种种不足，ebay 的架构师提出了 BASE 理论，是对 AP 的延伸。</p><p>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终⼀致性）三个短语的缩写，核心思想是即使无法做到强一致性，但可以采用适合的方式达到最终一致性。</p><h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>基本可用指系统出现故障之后，系统仍是可用的，但允许损失部分可用性，例如</p><ul><li>响应时间增加</li><li>服务降级：流量高峰时，屏蔽一些功能维持系统稳定</li></ul><h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>软状态允许系统中的数据存在中间状态，这些中间状态不会影响系统的可用性，即允许不同节点的数据同步存在延迟</p><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性要求数据副本在一定时间之后，能够达到一致的状态。</p><p>最终一致性可分为</p><ul><li>因果一致性：进程 A 更新数据后通知进程 B，进程 B 对包含该项数据的范围都是 A 更新后的值</li><li>单调读：如果之前读到新的数据，后续读取不会得到更旧的数据。单调读一致性保证强于最终一致性，弱于强一致性</li><li>单调写：系统需要保证来⾃同⼀个进程的写操作被顺序执行</li><li>读写一致性：用户获取到的自身修改是最新的，其他用户的更新可能稍后才会看到</li></ul><h2 id="3-PACELC理论"><a href="#3-PACELC理论" class="headerlink" title="3. PACELC理论"></a>3. PACELC理论</h2><p>分布式环境由于以下原因不存在绝对的强一致性：</p><ul><li>信息传播需要时间，有时间就有延迟，有延迟就会产生不一致</li><li>在网络中传递的信息可能是过时的</li><li>网络是不可靠的</li></ul><p>我们日常提到的强一致性，是从观察者的角度，即客户端获取的数据是一致的。PACELC 理论是 CAP 的拓展，其中 C、A、P 没有变化，而是引入了 Latency（延迟 L）和 E （Else）。</p><p><img src="pacelc.png" alt="PACELC"></p><p>也就是说，当分区 P 出现时，需要在可用性 A 和一致性 C 中权衡；而当 P 出现时，需要在延迟 L 和 C 中做权衡。换句话说，达成一致的节点越多，响应速度越慢。</p><p> PACELC 的作用是提供以下指导意义：</p><ul><li>半同步复制：例如 MySQL 主从架构，master节点只要收到一个 slave 节点写入磁盘成功的响应，即可将结果返回给客户端，减少响应时间。这样，即使 master 节点挂了，也有一个 slave 节点的数据是完整的；</li><li>主从分离：不要求主从之间的强一致性事务约束，从节点的数据可以存在一小段时间延迟。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/30329536/">数据密集型应用系统设计</a></li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a></li><li><a href="https://www.zhihu.com/question/31346392">如何理解数据库事务中的一致性的概念?</a></li><li><a href="https://www.zhihu.com/question/54105974/answer/1643846752">CAP中的P到底是个什么意思</a></li><li><a href="https://en.wikipedia.org/wiki/Eventual_consistency">Eventual consistency</a></li><li><a href="https://book.douban.com/subject/30443578/">软件架构设计 大型网站技术架构与业务架构融合之道</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试常见智力题</title>
      <link href="/2022/01/26/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/2022/01/26/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>互联网面试中，除了技术问题以外，还会出现一些智力题考验面试者的思维和应变能力，如果没提前看过在面试时并不容易做出来。本文主要介绍面试中常出现并且具有一定难度的智力题。</p><blockquote><p>倒水问题、用天平找重球、烧绳记录时间、脑筋急转弯等性质题目较为简单，不在本文介绍。</p></blockquote><h3 id="1-赛马问题"><a href="#1-赛马问题" class="headerlink" title="1. 赛马问题"></a>1. 赛马问题</h3><p>问题：25 匹马，5 个赛道，每次只能同时有 5 匹马跑，没有计时器，最少比赛几次选出前 3 名的马？</p><p>解答：</p><ul><li>将 25 匹马分为 1-5 组，进行 5 次赛马，得到每组的排名</li><li>根据排名将马重新划分，分为 A - E组，即原先 1-5 各组排名第一的马分到 A 组，排名第二的马分到 B 组，依次类推。A 组进行一次赛马，第一名即为 25 匹马的第一名</li><li>所有马的第二名和第三名只可能在 A 组的第二、三名，B 组的第一、二名，C 组的第一名，共 5 匹马。让这 5 匹马再进行一次赛马，即可得到二三名</li></ul><p>综上，共需要 5 + 1 + 1 = 7 次赛马。</p><p>如果是选出前 5 名的马，最少需要 8 次，详细可见 <a href="https://www.iteye.com/blog/hxraid-662643">25匹马的角逐</a></p><h3 id="2-病狗问题"><a href="#2-病狗问题" class="headerlink" title="2. 病狗问题"></a>2. 病狗问题</h3><p>问题：村里住着 100 户人家，每家都养了一条狗。已知这些狗中有病狗，疾病不会传染，每家都只能通过观察别人家的狗是否有病去判断自己家的狗，一旦判断出自家的狗有病，就必须打死自己家的狗（每家只能打自己的狗）。第一天过去没有枪声，第二天过去仍然没有枪声，第三天傍晚同时响起一片枪声，病狗全都死了，问村子里有几条病狗？</p><p>解答：</p><ul><li>假如有 1 只病狗。那么它的主人观察其他狗都没有病之后，便会知道自己的狗是病狗，第一天过后会出现枪声，与题意不符；</li><li>假如有 2 只病狗。第一天病狗的主人观察发现其它 49 只狗中有 1 只病狗，因为不知道确切病狗的数量，所以都认为自己的狗没病；第一天过后两个主人发现没有狗被杀，说明还存在其它病狗，那么只能是自家的狗，第二天过后应该出现枪声，与题意不符；</li><li>假如有 3 只病狗。根据假设2，到了第三天，病狗的主人发现其它两方的病狗还活着，说明存在 2 只以上的病狗，那么只能是自家的狗，故出现枪声杀死所有病狗，与题意符合，故共有 3 只病狗。</li></ul><p>推论：x 天出现枪声，则村里共有 x 只病狗。</p><h3 id="3-找毒药问题"><a href="#3-找毒药问题" class="headerlink" title="3. 找毒药问题"></a>3. 找毒药问题</h3><p>问题：x 瓶药，有⼀瓶有毒，用老鼠来喝药，喝到有毒的一天后死亡。⼀天内至少需要多少只老鼠才能检测到哪些有毒？</p><p>解答：</p><p>因为老鼠只有死亡和存活两种状态，设死亡 = 1, 存活 = 0，对老鼠和药进行编号后，根据药的二进制对老鼠喂药。一周后根据死亡和存活老鼠的二进制表达即可知道有毒的药水，故需要的老鼠数量为 ceil(log2(x))，ceil 表示向上取整。</p><p>例如有 8 瓶药水，编号为 0 - 7， 则一共需要 3 只老鼠，老鼠编号为 1- 3，将 4、5、6、7号药水混合到一起喂给老鼠1，将 2，3，6，7号药水混合喂给老鼠2，将1、3、5、7药水混合喂给老鼠3，观察老鼠是否中毒。假如 1 号老鼠和 3 号老鼠死亡，那么有毒的药水编号为 5 （二进制为 101）。</p><h3 id="4-找变质的药"><a href="#4-找变质的药" class="headerlink" title="4. 找变质的药"></a>4. 找变质的药</h3><p>问题：有 10 瓶药，每瓶有10粒药，其中有一瓶是变质的。好药每颗重 1 克，变质的药每颗比好药重 0.1 克。问怎样用天秤称一次找出变质的那瓶药？</p><p>解答：</p><ul><li>将 10 瓶药编号 1 - 10；</li><li>每瓶药取编号数量粒药，第 1 瓶取 1 粒，第 2 瓶取 2 粒，依次类推。如果药物没有变质，那么应该为 55 克，此时多出零点几克，哪瓶药就是变质的，例如现在为 55.5 克，那么 5 号药就是变质的。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.iteye.com/blog/hxraid-662643">25匹马的角逐</a></li><li><a href="https://zhuanlan.zhihu.com/p/395132338">路人张 字节面试常考智力题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智力题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(4)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍行为型的设计模式，主要解决的是类或对象的之间的交互问题，常见的有 观察者模式，模板方法模式、责任链模式。</p><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>观察者模式也称 发布-订阅 模式，在 GoF 的《设计模式》中对它的定义是，在对象之间定义一个一对多的依赖，当对象状态变化时，所有依赖都会收到通知。</p><p>一般而言，被依赖的对象称为被观察者（Observable），依赖的对象叫做观察者（Observer）。</p><p>现有一个气象台的例子，用户选择订阅气象台的数据，当天气参数发生变化时，需要通知给所有用户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> pressure, <span class="keyword">double</span> humidity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据变化，通知每个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nofityObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> pressure, <span class="keyword">double</span> humidity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            <span class="comment">// 调用观察者对应的接口</span></span><br><span class="line">            o.update(temperature, pressure, humidity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者的应用非常广泛，小到代码层面的解耦，大到系统层面的解耦（例如 MQ），都有这种模式的影子。</p><h2 id="2-模板方法模式"><a href="#2-模板方法模式" class="headerlink" title="2. 模板方法模式"></a>2. 模板方法模式</h2><p>模板方法模式在一个方法中定义一个骨架，并将某些步骤推迟到子类中实现。其实现模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        method1();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板方法模式的主要作用：</p><ul><li>复用，不可变的部分交由父类实现，将可变部分交由子类实现</li><li>拓展，通过一系列 hook 方法，交由用户实现自定义拓展</li></ul><p>jdk 中大量使用了模板方法模式，例如 concurrent 的包大量类继承了 AQS，重写 <code>tryAcquire</code> 等方法即可实现线程同步工具；<code>HashMap</code> 提供了 <code>afterNodeInsertion</code> 等方法，<code>LinkedHashMap</code> 继承 <code>HashMap</code> 并重写这些方法，在保留  <code>HashMap</code> 的功能基础上可实现 LRU 缓存。</p><h2 id="3-责任链模式"><a href="#3-责任链模式" class="headerlink" title="3. 责任链模式"></a>3. 责任链模式</h2><p>GoF 对责任链模式的定义是，将请求的发送和接收解耦，让接收对象都有机会处理这个请求，将接收对象形成一条链，并沿着链条传递请求，直到某个接收对象能够处理为止。</p><p>GoF 给出的定义中，如果某个处理器能够处理请求，将不会向下传递，日常使用也有变体，请求会被所有处理器处理一遍，不会中止。</p><p>下面是责任链模式的通常实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">implements</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> heandled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">implements</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> heandled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(IHandler handler)</span> </span>&#123;</span><br><span class="line">        handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (IHandler handler : handlers) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> handled = hander.handle();</span><br><span class="line">            <span class="comment">// 根据业务需要是否提前中止</span></span><br><span class="line">            <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>netty 中的编解码使用了责任链模式，用户可以在入和出的方法定义自己的编解码器，对数据进行加工。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在 GoF 的《设计模式》中，存在 23 种设计模式，系列文章没有全部介绍，这不代表这些模式不重要，一是由于迭代器模式等在日常开发中较少自己实现，二是作者能力有限，很多模式未能确定最好的使用场景，只能选择最常用的一些模式进行介绍。</p><p>设计模式并非银弹，遇到某个场景，不能机械使用模式，同时也要考虑选择模式带来的代价。有人说到设计模式学习的尽头是心中无模式，但使用处处是模式，如同《神雕侠侣》中的独孤求败，重剑无锋，大巧不工，四十岁前恃之横行天下，四十岁後，不滞於物，草木竹石均可为剑，自此精修，渐进於无剑胜有剑之境。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://book.douban.com/subject/1052241/">设计模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(3)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍结构型的设计模式，结构型模式总结了类或对象组合在一起的结构，常见的有代理模式、装饰器模式、适配模式、门面模式。</p><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><p>代理模式即在不改变原始类（被代理类）的情况下，引入代理类给原始类附加功能。主要分为静态代理和动态代理。</p><h3 id="1-1-静态代理"><a href="#1-1-静态代理" class="headerlink" title="1.1 静态代理"></a>1.1 静态代理</h3><p>静态代理要求代理类和被代理类实现同样的接口，在调用相同的接口时，在代理类中进行业务增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="function">UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 业务逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">  <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">(UserController userController)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userController = userController;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">    UserVo userVo = userController.login(telephone, password);</span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">IUserController userController = <span class="keyword">new</span> UserControllerProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>上述代码在原业务逻辑中引入性能监控，<code>UserControllerProxy</code> 也实现了 <code>IUserController</code> 接口，并在 <code>login</code> 业务中添加了性能监控。</p><p>静态代理实现简单，但缺点是需要为每一个原始类都需要创建一个代理类，造成代码膨胀。 </p><h3 id="1-2-动态代理"><a href="#1-2-动态代理" class="headerlink" title="1.2 动态代理"></a>1.2 动态代理</h3><p>为了解决静态代理类膨胀的问题，引入了动态代理。动态代理不事先编写代理类，而是在运行时动态创建代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsCollectorProxy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MetricsCollectorProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    DynamicProxyHandler handler = <span class="keyword">new</span> DynamicProxyHandler(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">      Object result = method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">      String apiName = proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MetricsCollectorProxy proxy = <span class="keyword">new</span> MetricsCollectorProxy();</span><br><span class="line">IUserController userController = (IUserController) proxy.createProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>通过动态代理，我们就得到了一个对于所有实现  <code>IUserController</code> 接口都能实现监控的效果。</p><p>动态代理在 RPC、监控、鉴权以及各种框架中被广泛使用，但也存在一定的性能损耗，在日常业务开发中选择静态代理还是动态代理，需要在性能和代码膨胀中进行权衡。</p><h2 id="2-装饰器模式"><a href="#2-装饰器模式" class="headerlink" title="2. 装饰器模式"></a>2. 装饰器模式</h2><p>装饰器模式允许向一个现有对象添加新的功能，同时不改变新的结构。</p><p>Java IO 中 <code>InputStream</code> 是一个接口，<code>FileInputStream</code> 用来读取文件，<code>BufferedInputStream</code> 支持缓存，可以提高速度。当我们带缓存读取文件时，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">InputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br></pre></td></tr></table></figure><p>可以看到，使用时需要先创建一个 <code>FileInputStream</code>，再将它传给 <code>BufferedInputStream</code> 才能使用，为什么不直接继承实现一个带缓存的文件流 <code>BufferedFileInputStream</code> 呢？如果 <code>InputStream</code> 实现类较少的话，那我们直接继承是可以接受的，但是 <code>InputStream</code> 存在大量实现类，如果我们想给每种实现都带缓存，那么需要对每个实现类进行继承，产生大量派生类，类继承结构变得特别复杂。</p><p>设计原则中有 ”组合优于继承“，我们可以使用组合替代继承，引入装饰器模式，下面是 Java IO 流的类似实现思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            fill(); <span class="comment">// fill是读入缓冲区的代码</span></span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.in = in; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...实现读取基本类型数据的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BufferedInputStream</code> 和  <code>DataInputStream</code> 继承了相同的 <code>InputStream</code> 父类，可以对原始类嵌套多个装饰器类，当我们需要某个功能时，只需要装饰（嵌套）对应功能的实现类即可。</p><p>通过装饰器模式，我们免除了复杂的继承机制，并且可以动态添加和撤销功能。</p><h2 id="3-适配模式"><a href="#3-适配模式" class="headerlink" title="3. 适配模式"></a>3. 适配模式</h2><p>适配模式目的是将不兼容的接口转换为可兼容的接口，让原先接口不兼容的类能够组合工作。生活中常见的例子是各种 USB 转接头，让原本无法直接连接的设备能够通讯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeCToUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleConnect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端typeC的充电线</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接TypeC充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// USB转接</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">TypeCToUSB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TypeC typeC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(TypeC typeC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeC = typeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        typeC.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adapter adapter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">power</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adapter.handleConnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们便实现使用双端 typeC 设备与电脑连接充电。</p><p>适配模式并不复杂，在日常开发中使用适配模式的场景如下：</p><ul><li>封装有缺陷的接口设计，抽象出更好的接口设计</li><li>兼容老版本接口</li><li>当依赖的外部系统被替换时，通过适配模式减少代码改动</li></ul><h2 id="4-门面模式"><a href="#4-门面模式" class="headerlink" title="4. 门面模式"></a>4. 门面模式</h2><p>GoF 中对门面模式的定义是，为子系统提供一组统一的接口，定义高层的接口让子系统更易使用。</p><p>假设有系统 A，提供 a、b、c、d 四个接口，另一个系统 B 想要使用 a、b、d 接口，利用门面模式，我们提供一个包含三个接口的 x 接口，供 B 使用。</p><p>那为什么需要 x 接口呢，直接调用 a、b、d 不可以吗？</p><p>如果 A 是我们平常的后端系统， 而 B 是前端，A 与 B 之间需要通过网络通信。那么如果直接调用 3 个接口，会产生三次网络通信，而调用 x 接口，只需要一次通信，为了加快响应速度，提高用户体验，我们应该尽可能减少网络通信的次数。</p><p>接下来举一个家庭影院的例子，家中有空调、影碟机和爆米花机，我们希望有一个上层系统进行控制，开启/关闭系统后自动打开/关闭所有设备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeFacade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DVDPlayer dvdPlayer;</span><br><span class="line">    <span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line">    <span class="comment">// 省略构造函数...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.on();</span><br><span class="line">        popcorn.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">        airCondition.down();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airCondition.off();</span><br><span class="line">        popcorn.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括而言，门面模式做接口整合，解决是多接口调用带来的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://www.bilibili.com/video/BV1G4411c7N4?from=search&amp;seid=17614039806864782413&amp;spm_id_from=333.337.0.0">尚硅谷：设计模式</a></li><li><a href="https://www.runoob.com/design-pattern/decorator-pattern.html">装饰器模式 菜鸟教程</a></li><li><a href="https://book.douban.com/subject/1052241/">设计模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(2)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍常见的创建型设计模式，主要有单例、工厂和建造者模式。</p><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><p>单例模式是一个很容易理解的概念，要求一个类只能创建一个对象，并提供全局访问点，常用场景是存储配置信息或者唯一高消耗资源。</p><p>实现单例模式的主要考虑点为：</p><ul><li>构造函数外部无法访问</li><li>对象创建时线程安全</li><li>是否需要延迟加载</li></ul><p>具体实现主要有两种方式，饿汉式和懒汉式，下文将会以一个 id 生成器进行举例。</p><h3 id="1-1-饿汉式"><a href="#1-1-饿汉式" class="headerlink" title="1.1 饿汉式"></a>1.1 饿汉式</h3><p>饿汉式实现即在类加载之后，该实例就已经创建完成，该实例创建的过程是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式的优点是实现简单，有人认为这种方式提前初始化会提前创建对象却不使用，导致资源浪费，个人不认同这种观点，在系统启动后去执行耗时的操作，可能会影响系统的性能，不如将这耗时的操作提前到系统初始化之时。</p><blockquote><p>大部分场景推荐使用这种写法。</p></blockquote><h3 id="1-2-懒汉式"><a href="#1-2-懒汉式" class="headerlink" title="1.2 懒汉式"></a>1.2 懒汉式</h3><p>与饿汉式对应的是懒汉式，将对象的初始化延迟。在 java 中有多种方式可以实现懒汉式，这里主要推荐静态内部类和枚举的方式。</p><ul><li>静态内部类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式依赖类加载机制，当调用 getInstance() 方法时，内部类才会进行加载，instance 才会被创建，其唯一性和线程安全性由 JVM 进行保证。</p><ul><li>枚举：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式依赖 java 枚举为单例的性质，实现最为简单，推荐使用。</p><p>说明：懒汉式中还有一种双重检测的实现方式，但这种方式实现复杂，注意点多，甚至在低版本 jdk 下都无法保证正确运行。个人不推荐使用这种方式，但在此还是提供实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> IdGenerator instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (IdGenerator.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><p>工厂模式主要用于创建对象，可分为简单工厂、工厂方法和抽象工厂。其中抽象工厂较为复杂，在日常开发中较少使用，下文以一个车辆工厂举例介绍简单工厂和工厂方法。</p><h3 id="2-1-简单工厂"><a href="#2-1-简单工厂" class="headerlink" title="2.1 简单工厂"></a>2.1 简单工厂</h3><p>简单工厂将创建对象的逻辑汇集到一个工厂类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;五菱&quot;</span>.equals(car)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;特斯拉&quot;</span>.equals(car)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getWuling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getTesla</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建车辆的代码被汇集到 CarFactory 中，并且提供按品牌创建车辆对象的方法。简单工厂并不是一个设计模式，它没有用到面向对象的任何特性，它更像是一种编程习惯，将类似功能的代码整合，并没有提升代码的拓展性。</p><h3 id="2-2-工厂方法"><a href="#2-2-工厂方法" class="headerlink" title="2.2 工厂方法"></a>2.2 工厂方法</h3><p>当需要拓展新类型时，简单工厂仍需要在一堆 if-else 中进行改动，要避免这种情况，需要利用多态的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;特斯拉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wuling</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;五菱宏光&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WulingFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeslaFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了一个工厂接口，并且实现了五菱和特斯拉的工厂类。当我们需要创建对象时，先创建对应的工厂，再调用 create 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ICarFactory teslaFactory = <span class="keyword">new</span> TeslaFactory();</span><br><span class="line">Car tesla = teslaFactory.create();</span><br><span class="line">ICarFactory wulingFactory = <span class="keyword">new</span> WulingFactory();</span><br><span class="line">Car wuling = wulingFactory.create();</span><br></pre></td></tr></table></figure><p>工厂方法即提供创建对象的统一接口，并将创建对象的具体实现交由子类实现。</p><h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3 应用场景"></a>2.3 应用场景</h3><p>那什么时候选择简单工厂，什么时候选择工厂方法呢？</p><ul><li>如果创建对象的代码块比较简单，只有两三种类型，推荐不进行拆分</li><li>当创建对象的类型较多，并且各个对象的创建逻辑较为简单时，例如只需要简单的 new 操作，选择简单工厂模式</li><li>当各个对象的创建逻辑较为复杂，需要复杂的初始化时，选择工厂方法模式，将复杂的逻辑分散到各个工厂子类中</li></ul><h2 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h2><h3 id="3-1-头疼的初始化"><a href="#3-1-头疼的初始化" class="headerlink" title="3.1 头疼的初始化"></a>3.1 头疼的初始化</h3><p>在日常开发中，创建一个对象的常用方式是直接调用该类的构造函数。但是当成员属性较多，并且有部分属性初始化是可选的时，我们需要重载大量的构造函数，代码的可读性和易用性都降低了。</p><p>有一种解决方案是提供一个简单的构造函数和 setter 方法，在创建一个对象之后，调用 setter 给需要的属性赋值。这种方案能够解决一定问题，但仍存在缺陷：</p><ul><li>必须初始化的属性依赖程序员而不是编译器确认，如果使用者忘记初始化，会影响后续的业务逻辑</li><li>建造过程中可能处于不一致的状态，没法通过检查构造参数实现一致性</li><li>该类要求是不可变对象，不应该提供 setter</li></ul><h3 id="3-2-建造者模式"><a href="#3-2-建造者模式" class="headerlink" title="3.2 建造者模式"></a>3.2 建造者模式</h3><p>为了解决这些问题，建造者模式由此产生。建造者模式在类中内置一个建造者 Builder 类，并且区分必选项和可选项，摆脱陷入大量重载构造函数的泥泽之中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化必选项</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">        <span class="comment">// 初始化可选项，提供默认值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有很多插件对建造者模式提供支持，例如 lombok 插件只需要一个 @Builder 注解即可为该类低入侵式实现建造者模式。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://www.bilibili.com/video/BV1G4411c7N4?from=search&amp;seid=17614039806864782413&amp;spm_id_from=333.337.0.0">尚硅谷：设计模式</a></li><li><a href="https://book.douban.com/subject/30412517/">effective java</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(1)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/</url>
      
        <content type="html"><![CDATA[<p>设计模式首次在 GoF 的《设计模式》书中提出，其副标题是可复用面向对象软件的基础，旨在实现可拓展、可维护的高质量代码。</p><p>学习设计模式往往有以下目的：</p><ul><li>面对面试中的设计模式相关问题</li><li>改善自己的代码质量</li><li>阅读源码、框架的基础</li></ul><p>在使用模式之前，我们需要先了解各种模式以及他们适用的场景，设计模式按类型可以分为：</p><ul><li>建造型</li><li>结构型</li><li>行为型</li></ul><p>在后续文章中会按类型对常用的设计模式进行介绍。</p><p>正如计算机领域的一句名言而言，“计算机领域的问题可以靠加一层抽象来解决”，良好的抽象会极大提升了代码的质量。但很多人也忽视了下一句，“而这往往会带来其他问题”，设计模式是面向对象大树上生长出的硕果，如果使用者还未踏入面向对象的殿堂，盲目使用设计模式往往会带来相反的效果。笔者刚学习设计模式之初，曾想方设法进行应用，大肆设计，后经时间验证，过度的设计不会带来任何优势，反而却增加了代码的复杂度，代码阅读者如果不了解该模式便会不知所云。</p><p>软件设计的能力并不是一朝一夕就能培养出来的，不要妄图通过阅读一本《设计模式》抓到面向对象设计的精髓。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/1052241/">GoF 设计模式</a></li><li><p><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></p></li><li><p><a href="https://draveness.me/holy-grail-design-pattern/">圣杯与银弹 没用的设计模式</a></p></li><li><a href="https://www.zhihu.com/question/23757237">知乎：设计模式有何不妥，所谓的荼毒体现在哪</a></li><li><a href="https://zhuanlan.zhihu.com/p/19835717">为什么我们需要学习（设计）模式</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈面向对象编程</title>
      <link href="/2022/01/24/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/24/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>面向过程是一种编程范式，以过程（函数）作为单元组织代码，数据与过程相分离，主要是对过程进行抽象，将其组合为函数，代表语言 C 语言。</p><p>而面向对象也是一种编程范式，以对象（类）作为组织代码的单元，主要是对数据进行抽象，将其组合为类，具有封装、继承、多态三个特性，代表语言有 C++、Java、C#。</p><p>面向对象相比于面向过程有以下优势：</p><ul><li>更适合于复杂大规模程序开发</li><li>OOP 风格的代码更容易复用、拓展和维护</li></ul><p>说明：面向过程也并一无是处，没有纯粹的 OOP，面向对象的编程语言在宏观上是面向对象，但在微观上仍是面向过程的。 面向过程的 C 语言也可以实现不完全的面向对象特性：</p><ul><li>封装：使用 static 关键字</li><li>继承：用组合代替</li><li>多态：利用函数指针实现，redis 和 linux 内核中的 VFS 就是使用这种方法实现多态</li></ul><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h2><h3 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h3><p>封装是将相关的数据和操作汇集到类模块，并暴露有限的接口供外部访问内部数据，用户不需要也无权访问其底层实现。</p><p>意义：</p><ul><li>降低修改的灵活性，提高代码的可控性</li><li>降低使用负担，使用者只需关注暴露的接口即可</li></ul><p>原则：</p><ul><li>当不确定内部属性的访问权限时，优先考虑最低的访问权限。当将一个属性的访问权限从 public 改为 private 可能导致大量的代码改动，反之只要小量或者没有代码改动。</li><li>有必要时才提供 setter 方法</li><li>当获取或者设置类的可变属性时，考虑采用防御性复制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(person.toString());</span><br><span class="line"><span class="comment">// Person&#123;birthday=Mon Jan 24 09:21:38 CST 2022&#125;</span></span><br><span class="line">Date birthday = person.getBirthday();</span><br><span class="line">birthday.setYear(<span class="number">98</span>);</span><br><span class="line">System.out.println(person.toString());</span><br><span class="line"><span class="comment">// Person&#123;birthday=Sat Jan 24 09:21:38 CST 1998&#125;</span></span><br></pre></td></tr></table></figure><p>上述测试代码中 <code>getBirthday</code> 方法返回的是可变的 <code>Date</code> 对象，在外部对该 <code>Date</code> 对象进行修改会导致 <code>Person</code> 业务逻辑错误。问题根源是 birthday 虽然是引用类型，但语意上应该是值类型，我们关心的是它的值，不希望不同引用对其进行同步修改。</p><p>修改方式是采用防御性复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> birthday == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Date(birthday.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>Date</code> 可变是一种设计错误，其一系列 getter/setter 已被弃用</li><li>是否采用防御性复制，需要根据其语意和实际类型是否统一判断</li></ul><h3 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h3><p>此处讨论的继承为广义的继承，不局限于继承具体类。</p><p>从可继承数量上分为：</p><ul><li>单继承：一个类只能继承一个父类，代表语言 Java、C#</li><li>多继承：一个类能继承多个父类，代表语言 C++。多继承会存在菱形问题，类 B 和 C 继承 A，都重写了某一个方法，现有类 D 继承 B 和 C，该方法继承 B 还是 C 会存在歧义 </li></ul><p>根据继承类型分为：</p><ul><li>接口继承：实现某一个接口，<strong>生成可复用的代码</strong>，Java 中采用 implements 关键字</li><li>实现继承：继承某个类，<strong>复用已有的代码</strong>，Java 中采用 extends 关键字</li></ul><p>原则：</p><ul><li>提倡接口继承，慎用实现继承</li><li>优先考虑组合而不是继承。一方面继承带来了更大的耦合，父类改动时需要谨慎考虑对子类的影响，降低了拓展性；另一方面子类可以通过重写破坏父类精心设计的封装</li><li><p>考虑使用继承的情况：1. 继承层次浅，继承关系不复杂；2.模板方法设计模式；</p><p>3.无法改变一个方法的参数类型，并且该参数不是接口，考虑使用继承进行拓展</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    client.encode(url);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedClient</span> <span class="keyword">extends</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写该方法实现自己的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">Client client = <span class="keyword">new</span> CustomizedClient();</span><br><span class="line">f(client);</span><br></pre></td></tr></table></figure><ul><li>继承应遵守里氏替换原则，能够向上转型，常规逻辑的 is-a 关系不是使用继承的充分条件，需要<strong>考虑父类/接口的契约，子类需要履行所有契约</strong>。一个直观的测试方法：子类能够通过父类的所有的单元测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List接口，供举例说明，与java.util.List定义不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个元素到列表的末尾</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体实现...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中 <code>SortedList</code> 实现了 <code>List</code> 接口，但 <code>SortedList</code> 在插入元素应该将其存放在合适的位置，并不一定是末尾，并不遵守 <code>List</code> 的契约。直觉上 <code>SortedList</code> 是<code>List</code>，但从设计角度不应该实现 <code>List</code> 接口，考虑使用更上级的 <code>Collection</code> 接口。</p><p>jdk 中的设计错误：</p><p>1.<code>Stack</code> 继承了 <code>Vector</code>，栈从定义上并不具备 <code>Vector</code> 中随机访问和删除等功能，不应该使用继承。正确方式是使用组合，在内部维护一个 <code>Vector</code>，对外提供入栈、出栈等方法。</p><p>2.<code>Properties</code> 继承了 <code>HashTable&lt;Object, Object&gt;</code>，<code>Properties</code> 相比 <code>HashTable</code> 而言多了 IO 读取和持久化等功能。但是其 key 和 value 都应该是 <code>String</code> 类型，如果 <code>Properties</code> 调用继承<code>HashTable</code> 的 <code>put</code> 方法插入非 <code>String</code> 类型的 k/v 时，在持久化时会导致强制转型失败。正确方式是继承 <code>HashTable&lt;String, String&gt;</code> 或者使用组合。</p><h3 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h3><p>广义的多态可分为：</p><ul><li>静态多态：也称参数多态，在编译期确定类型，让相同的代码应用在不同类型。例如 C++ 中的 template（采用异构翻译，即为每一个类型创建一份代码），Java 中的泛型（采用同构翻译，即类型擦除，所有类型都会被转为 Object）</li><li>动态多态：也称子类型多态，在运行期确定，让不同的实现代码应用在相同的场合。OOP 中讨论的多态通常指动态多态</li></ul><p>多态可以提高代码的拓展性和复用性，也是很多设计模式的继承。在 OOP 中多态依赖继承实现，继承是多态的基础，多态是继承的目的。</p><p>设计原则：</p><ul><li>设计接口和父类时，需要谨慎设计契约</li></ul><p>这里举一个常见的鸟类案例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;ostrich can&#x27;t fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了父类鸟类，并定义 <code>fly</code> 方法，子类鸵鸟继承了该类，但由于鸵鸟无法飞，<code>fly</code> 方法中抛出异常。一方面是上文所言鸵鸟无法实现父类的契约，不应该继承该类；另一方面，抽象出鸟类时应该考虑到不是所有鸟都会飞，不应该提供 <code>fly</code> 方法。更好的方式是将 <code>fly</code> 放到 <code>Flyable</code>接口中，而鸵鸟类不实现该接口。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="type">Flyable</span> &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AbstractBird</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eagle</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> <span class="title">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    void fly() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3.结语"></a>3.结语</h2><p>设计再良好的系统，在烂代码的侵蚀下最终会变得不可控。在考虑总体架构设计之后，也别忽略对模块、类、方法的设计，勿在浮沙筑高楼，好的架构师首先得是一个好的程序员。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/4031906/">冒号课堂 编程范式和OOP思想</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://book.douban.com/subject/2334288/">大话设计模式</a></li><li><a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">Google Tech Talk: How to design a good API</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思维 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
