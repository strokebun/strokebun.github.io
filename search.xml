<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java并发编程(6) 生产者消费者模型</title>
      <link href="/2022/02/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(6)%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/"/>
      <url>/2022/02/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(6)%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个角色——即所谓的“生产者”和“消费者”。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。</p><p><img src="生产者消费者问题.png" alt="alt"></p><p>生产者消费者问题经常出现 Java 面试之中，一般有以下写法。</p><h2 id="2-使用wait和notify"><a href="#2-使用wait和notify" class="headerlink" title="2. 使用wait和notify"></a>2. 使用wait和notify</h2><p>这是最简单的实现，缓冲区满和空都调用 <code>wait</code> 方法等待，当生产或者消费了一个产品，则使用 <code>notfityAll</code> 唤醒所有的生产者消费者。</p><p>注意：<code>wait</code> 和 <code>notify</code> 需要和 <code>synchronized</code> 配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟生产耗时</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() &gt;= CAPACITY) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟消费</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            queue.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者消费，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                    queue.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Producer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-使用可重入锁ReentrantLock"><a href="#3-使用可重入锁ReentrantLock" class="headerlink" title="3. 使用可重入锁ReentrantLock"></a>3. 使用可重入锁ReentrantLock</h2><p><code>java.util.ReentrantLock</code> 配合 <code>Condition</code> 可以实现跟 <code>synchronized</code> 和 <code>wait</code> 类似的效果。</p><p><code>await</code> 需要和 <code>signal</code>、<code>signalAll</code> 配合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition full = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> Condition empty = lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟生产耗时</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() &gt;= CAPACITY) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            full.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.add(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                    empty.signalAll();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟消费</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">200</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (queue.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            empty.await();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者消费，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                    full.signalAll();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Producer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-使用阻塞队列"><a href="#4-使用阻塞队列" class="headerlink" title="4. 使用阻塞队列"></a>4. 使用阻塞队列</h2><p>使用阻塞队列实现最为简单，选择 <code>java.util.concurrent.ArrayBlockingQueue</code>，初始化时指定容量，其 <code>put</code> 方法会向队列中添加一个元素，如果队列满则阻塞，直到有元素出队；<code>take</code> 方法会从队列中出队一个元素，如果队列中没有元素则阻塞，直到有元素入队。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Integer&gt; queue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟生产耗时</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.put(<span class="number">1</span>);</span><br><span class="line">                    <span class="comment">// 此处计数不准确，视情况删除或者进行额外同步</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">// sleep模拟消费</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.take();</span><br><span class="line">                    <span class="comment">// 此处计数不准确，视情况删除或者进行额外同步</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者消费，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Producer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上述代码中 <code>println</code> 中队列长度与 <code>put</code>、<code>take</code> 操作没有同步，如果需要准确输出队列长度需要额外加锁。 </p></blockquote><h2 id="5-信号量Semaphore"><a href="#5-信号量Semaphore" class="headerlink" title="5. 信号量Semaphore"></a>5. 信号量Semaphore</h2><p>信号量用来控制特定资源的线程数量，由 Dijkstra 提出。用于保持在0至指定最大值之间的一个计数值，当线程完成一次对信号量的等待时，该计数值减一；完成一次释放时，计数值加一。</p><p><code>java.util.concurrent.Semaphore</code> 实现了信号量，<code>acquire</code> 方法会使信号量 -1，<code>release</code> 方法会使信号量 +1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    Semaphore notFull = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line">    Semaphore notEmpty = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    Semaphore mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">100</span>);</span><br><span class="line">                    notFull.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    queue.add(<span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;生产者生产，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    notEmpty.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.currentThread().sleep(<span class="number">200</span>);</span><br><span class="line">                    notEmpty.acquire();</span><br><span class="line">                    mutex.acquire();</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;消费者者消费，目前数量: &quot;</span> + queue.size());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    mutex.release();</span><br><span class="line">                    notFull.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer pc = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Producer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="keyword">new</span> Thread(pc.<span class="function">new <span class="title">Consumer</span><span class="params">()</span>).<span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem">producer-consumer problem Wikipedia</a></li><li><p><a href="https://www.educative.io/edpresso/what-is-the-producer-consumer-problem">What is the producer consumer problem</a></p></li><li><p><a href="https://cloud.tencent.com/developer/article/1777705">生产者消费者的三种实现</a></p></li><li><a href="https://en.wikipedia.org/wiki/Semaphore_(programming">Semaphore Wikipedia</a>)</li><li><a href="https://blog.csdn.net/ldx19980108/article/details/81707751">Java多种方式解决生产者消费者问题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>netty介绍</title>
      <link href="/2022/02/16/netty%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/02/16/netty%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p> netty 是一款事件驱动的异步网络框架， 是对 Java NIO 的封装，用于快速开发高性能、高可靠的网络服务器和客户端，在大量中间件例如 Dubbo、RocketMQ 中得到广泛应用。</p><p>上文 <a href="https://strokebun.github.io/2022/02/15/Java-NIO/">Java NIO</a> 对 NIO 进行了介绍，NIO 存在以下问题：</p><ul><li>类库和 API 繁琐，上手难度高；</li><li>需要熟悉多线程编程；</li><li>存在 epoll 空轮询 bug。</li></ul><p>Netty 对 NIO 进行了封装，简单易用，并且内置了多种编解码器，支持多种协议，可用于快速开发。</p><h2 id="2-ByteBuf"><a href="#2-ByteBuf" class="headerlink" title="2. ByteBuf"></a>2. ByteBuf</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p><code>ByteBuffer</code> 是 NIO 中网络的数据容器，但这个类使用繁琐复杂，netty 中的替代品是 <code>ByteBuf</code>。<code>ByteBuf</code> 拥有以下优势：</p><ul><li>内置零拷贝</li><li>容量可以按需增长</li><li>同时具有读模式和写模式，不需要进行转换</li></ul><h3 id="2-2-分配"><a href="#2-2-分配" class="headerlink" title="2.2 分配"></a>2.2 分配</h3><p>与 <code>ByteBuffer</code> 类似，<code>ByteBuf</code> 可在堆中分配，也可在直接内存分配。</p><p>为了降低内存分配和释放的开销，netty 使用 <code>PooledByteBufAllocator</code> 实现了池化，并且基于引用计数实现内存回收，其主要 API 如下：</p><ul><li><code>buffer(int initialCapacity)</code>：返回一个基于堆或直接内存的 <code>ByteBuf</code></li><li><code>heapBuffer(int initialCapacity)</code>：返回一个基于堆内存的 <code>ByteBuf</code></li><li><code>directBuffer(int initialCapacity)</code>：返回一个直接内存的<code>ByteBuf</code></li></ul><h2 id="3-ChannelHandler"><a href="#3-ChannelHandler" class="headerlink" title="3. ChannelHandler"></a>3. ChannelHandler</h2><h3 id="3-1-ChannelHandler"><a href="#3-1-ChannelHandler" class="headerlink" title="3.1 ChannelHandler"></a>3.1 ChannelHandler</h3><p>对于开发人员而言， netty 最重要的组件的 <code>ChannelHandler</code>，它充当了入站和出战数据的处理器。</p><p>其中 <code>ChannelInboundHandler</code> 处理入站数据，<code>ChannelOutboundHandler</code> 处理出战数据。</p><h3 id="3-2-ChannelPipeline"><a href="#3-2-ChannelPipeline" class="headerlink" title="3.2 ChannelPipeline"></a>3.2 ChannelPipeline</h3><p><code>ChannelPipeline</code> 是一个 <code>ChannelHandler</code> 实例链，使用了责任链设计模式。。如果一个入站<br>事件被触发，它将被从 <code>ChannelPipeline</code> 的头部开始一直被传播到尾端。</p><p><img src="channelpipeline.png" alt="alt"></p><h3 id="3-3-ChannelHandlerContext"><a href="#3-3-ChannelHandlerContext" class="headerlink" title="3.3 ChannelHandlerContext"></a>3.3 ChannelHandlerContext</h3><p><code>ChannelHandlerContext</code> 代表了<code>ChannelHandler</code> 和 <code>ChannelPipeline</code> 之间的关<br>联，每当有 <code>ChannelHandler</code> 添加到 <code>ChannelPipeline</code> 中时，都会创建 <code>ChannelHandler-Context</code>。<code>ChannelHandlerContext</code> 的主要功能是管理它所关联的 <code>ChannelHandler</code> 和在<br>同一个 <code>ChannelPipeline</code> 中的其他 <code>ChannelHandler</code> 之间的交互。</p><p><img src="channelhandlercontext.png" alt="alt"></p><p>最主要使用的方法是 <code>writeAndFlush</code>，将数据写入刷新并经过 <code>ChannelPipeline</code>。</p><h2 id="4-EventLoop"><a href="#4-EventLoop" class="headerlink" title="4. EventLoop"></a>4. EventLoop</h2><p><code>EventLoop</code> 是 netty 中的事件机制，一个 <code>EventLoop</code> 由一个 <code>Thread</code> 驱动，同时 <code>Runnable</code> 或者 <code>Callable</code> 任务可以直接交给 <code>EventLoop</code> 是实现，立即执行或者调度执行。</p><h2 id="5-优化"><a href="#5-优化" class="headerlink" title="5. 优化"></a>5. 优化</h2><h3 id="5-1-粘包问题"><a href="#5-1-粘包问题" class="headerlink" title="5.1 粘包问题"></a>5.1 粘包问题</h3><p>由于 TCP 是面向流的，消息是无边界的，接收缓冲区可能得到多个包或者不完整的包，需要在应用层对包进行区分。</p><p>有三种实现方式：</p><ul><li>固定长度：即每个包都是固定长度的，每次读取固定长度解析，netty 中提供了 <code>FixedLengthFrameDecoder</code> 作为实现。优点是实现简单，缺点是造成空间浪费，不推荐使用。</li><li>分割符：利用分割符对包进行区分，netty 中提供了 <code>DelimiterBasedFrameDecoder</code> 作为实现。优点是实现比较简单， 也没有空间浪费，缺点是当内容出现分割符需要进行转义，推荐使用。</li><li>自定义格式：通常使用 长度 + 内容 的方式，netty 中提供了 <code>LengthFieldBasedFrameDecoder</code> 作为实现。优点是空间紧凑，但需要自定义协议，实现较为复杂。</li></ul><h3 id="5-2-keepalive"><a href="#5-2-keepalive" class="headerlink" title="5.2 keepalive"></a>5.2 keepalive</h3><p>在对方服务不可用或者网络连接故障时，如果未关闭连接，会浪费资源。 TCP 层有 keepalive 机制，但需要 2 小时以上才能判断连接失效，耗时过长，在服务器应用需要自行实现 keepalive 机制。</p><p>Idle 监测是一种检测机制，会固定时间发送询问机制，测试对端服务是否正常。当发生 Idle</p><p>之后，才发生 keepalive。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://book.douban.com/subject/27038538/">netty实战</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/181239748">超详细Netty入门，看这篇就够了</a></p></li><li><p><a href="https://time.geekbang.org/course/intro/100036701">Netty 源码剖析与实战</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> netty </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java NIO</title>
      <link href="/2022/02/15/Java-NIO/"/>
      <url>/2022/02/15/Java-NIO/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>传统的服务端同步阻塞 IO BIO（Blocking IO）调用 <code>read</code> 之后，如果接收缓冲区中没有数据，会一直阻塞直到接收数据。在 <a href="https://strokebun.github.io/2022/02/15/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/">IO多路复用</a> 中提到，传统的 BIO + 多线程的解决方案，大量连接将产生大量线程，难以解决 C10K 问题，需要使用 IO 多路复用解决。</p><p>NIO（Non-blocking IO，也称 New IO），是 Java 的一种同步非阻塞 IO 模型，底层使用了 IO 多路复用，可以有效解决 C10K 问题。</p><p>Java NIO 有三个核心组件，<code>Buffers</code>、<code>Selector</code> 和 <code>Channel</code>，将在下文中陆续介绍。</p><h2 id="2-Buffer"><a href="#2-Buffer" class="headerlink" title="2. Buffer"></a>2. Buffer</h2><h3 id="2-1-基本用法"><a href="#2-1-基本用法" class="headerlink" title="2.1 基本用法"></a>2.1 基本用法</h3><p><code>Buffer</code> 是存储数据的缓冲区，提供读写操作，底层使用数组实现。使用 <code>Buffer</code> 一般遵守 4 个步骤：</p><ol><li><p>写入数据到 <code>Buffer</code></p></li><li><p>调用 <code>flip()</code> 方法</p></li><li>从 <code>Buffer</code> 中读取数据</li><li>调用 <code>clear()</code> 或 <code>compact()</code> 方法清除缓存</li></ol><p>向 <code>Buffer</code> 写入数据后，内部会记录写入数据量，一旦需要读取数据，需要通过 <code>flip()</code> 方法将 <code>Buffer</code> 从写模式切换到读模式。在读模式下，可以读取之前写入到 <code>Buffer</code> 的所有数据。</p><p>当读完所有数据之后，需要清空缓冲区，有两者方式。<code>clear()</code> 清空整个缓冲区，<code>compact()</code> 清除已经读过的数据。 </p><p>下面是一个使用举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RandomAccessFile aFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">FileChannel inChannel = aFile.getChannel();</span><br><span class="line"><span class="comment">// 创建48 byte大小的Buffer</span></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf); <span class="comment">// 写入数据到Buffer</span></span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line">   buf.flip();  <span class="comment">// 切换为读模式</span></span><br><span class="line">   <span class="keyword">while</span>(buf.hasRemaining())&#123;</span><br><span class="line">      System.out.print((<span class="keyword">char</span>) buf.get()); <span class="comment">// 每次读取一个byte</span></span><br><span class="line">   &#125;</span><br><span class="line">   buf.clear(); <span class="comment">// 情况缓冲</span></span><br><span class="line">   bytesRead = inChannel.read(buf); <span class="comment">// 重新写入Buffer</span></span><br><span class="line">&#125;</span><br><span class="line">aFile.close();</span><br></pre></td></tr></table></figure><h3 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h3><p><code>Buffer</code> 在内部维护 4 个核心变量：</p><ul><li><code>capacity</code>：缓冲区的最大容量，设定后不可改变</li><li><code>limit</code>：缓冲区的数据个数，<code>flip()</code> 调用前等于 <code>capacipty</code>，调用后等于 <code>position</code></li><li><code>position</code>：下一个要读写的元素下标，由 <code>get()</code> 和 <code>put()</code> 自动更新</li><li><code>mark</code>：记录当前 <code>position</code> 的位置，可以通过 <code>reset()</code> 恢复到 <code>mark</code> 的位置</li></ul><p><img src="buffer.png" alt="alt"></p><h3 id="2-3-类型"><a href="#2-3-类型" class="headerlink" title="2.3 类型"></a>2.3 类型</h3><h4 id="2-3-1-Heap-Buffer"><a href="#2-3-1-Heap-Buffer" class="headerlink" title="2.3.1 Heap Buffer"></a>2.3.1 Heap Buffer</h4><p><code>Heap Buffer</code> 在堆中分配，在 Java NIO 中，<code>Buffer</code> 有以下类型：</p><ul><li><code>ByteBuffer</code>、<code>CharBuffer</code>、<code>DoubleBuffer</code>、<code>FloatBuffer</code>、<code>IntBuffer</code>、<code>LongBuffer</code>、<code>ShortBuffer</code></li><li><code>MappedByteBuffer</code></li></ul><p>其中第一类 <code>Buffer</code> 代表了不同的数据类型，通过以下方式创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>而 <code>MappedByteBuffer</code> 是 <code>FileChannel</code> 提供的内存映射操作，使用 <code>map</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mode:映射文件方式</span></span><br><span class="line"><span class="comment"> * position:起始位置</span></span><br><span class="line"><span class="comment"> * size:映射区大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">MappedByteBuffer <span class="title">map</span><span class="params">(<span class="keyword">int</span> mode,<span class="keyword">long</span> position,<span class="keyword">long</span> size)</span></span>; </span><br></pre></td></tr></table></figure><blockquote><p><code>MappedByteBuffer</code> 底层依赖 <code>mmap</code> 实现，将在下文介绍。</p></blockquote><p>其中 <code>mode</code> 可取值为：</p><ul><li><code>READ_ONLY</code></li><li><code>READ_WRITE</code></li><li><code>PRIVATE</code>：修改只对缓冲区有效，不会作用到文件</li></ul><p><code>MappedByteBuffer</code> 的使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">    RandomAccessFile f = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        f = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;hello.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        RandomAccessFile world = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;world.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        FileChannel fc = f.getChannel();</span><br><span class="line">        MappedByteBuffer buf = fc.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        FileChannel worldChannel = world.getChannel();</span><br><span class="line">        MappedByteBuffer worldBuf = worldChannel.map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">        worldBuf.put(buf);</span><br><span class="line"></span><br><span class="line">        fc.close();</span><br><span class="line">        f.close();</span><br><span class="line">        world.close();</span><br><span class="line">        worldChannel.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-2-Direct-Buffer"><a href="#2-3-2-Direct-Buffer" class="headerlink" title="2.3.2 Direct Buffer"></a>2.3.2 Direct Buffer</h4><p>除了 <code>Heap Buffer</code>，<code>Buffer</code> 还可分为  <code>Direct Buffer</code>，<code>Direct Buffer</code> 在直接内存分配，在 GC 时不会移动。使用 <code>DirectBuffer</code> 可以减少一次内存拷贝，<code>Heap Buffer</code> 写入前，会先创建一个 <code>Direct Buffer</code>，再去执行真正的写操作，这是因为在写入时，这个 <code>Buffer</code> 的地址不能够变化，而 <code>Heap Buffer</code> 可能在 GC 过程中被移动。所以在调用底层写入之前，数据要在堆外内存。但是 <code>Direct Buffer</code> 依赖 <code>malloc</code> 实现，效率相比堆内创建更低，并且更不宜维护，通常会使用内存池来提高性能。</p><h2 id="3-Channel"><a href="#3-Channel" class="headerlink" title="3. Channel"></a>3. Channel</h2><p><code>Channel</code> 与 <code>java.io</code> 中的流类似，但有以下不同：</p><ul><li><code>Channel</code> 是双向的，支持写入和读取；</li><li><code>Channel</code> 和 <code>Buffer</code> 强依赖，读写都需要通过 <code>Buffer</code>。</li></ul><p><img src="channel.png" alt="alt"></p><p>Java NIO 中的 <code>Channel</code> 可分为：</p><ul><li>文件：<code>FileChannel</code>，用于读写文件</li><li>socket<ul><li><code>ServerSocketChannel</code>：用于服务端，可以监听 TCP 连接</li><li><code>SocketChannel</code>：通过 TCP 读写网络数据</li><li><code>DatagramChannel</code>：通过 UDP 读写网络数据</li></ul></li></ul><h2 id="4-Selector"><a href="#4-Selector" class="headerlink" title="4. Selector"></a>4. Selector</h2><p><code>Selector</code> 绑定了多个 <code>Channel</code> 和事件，调用 <code>select</code> 将阻塞 到至少有一个 <code>Channel</code> 触发事件，<code>select()</code> 返回就绪的 <code>Channel</code> 个数。</p><p>事件类型包括：</p><ul><li><code>SelectionKey.OP_READ</code>：读就绪</li><li><code>SelectionKey.OP_WRITE</code>：写就绪</li><li><code>SelectionKey.OP_CONNECT</code>：客户端连接成功，用于 socket 通道</li><li><code>SelectionKey.OP_ACCEPT</code>： 服务器接收新连接，用于 socket 通道</li></ul><blockquote><p>jdk 1.7 之前的 select 可能有空轮询问题，这是由于部分 Linux 内核的底层存在假唤醒问题，此时 select() 返回 0，但是 jdk 官方将这个问题甩锅给操作系统，没有进行修改，后续造成大量问题。</p><p>对于这个问题，使用 NIO 封装的 netty 的处理方式是记录 select() = 0 的持续次数，到达阈值则重新构建 Selector。</p></blockquote><p>使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel server = ServerSocketChannel.open();</span><br><span class="line">        <span class="comment">// 切换成非阻塞模式</span></span><br><span class="line">        server.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        server.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">6666</span>));</span><br><span class="line"></span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        <span class="comment">// 将通道注册到选择器上，指定事件</span></span><br><span class="line">        server.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * select() &gt; 0则有IO就绪，需要遍历查看具体哪个IO就绪</span></span><br><span class="line"><span class="comment">         * 注: 调用时会阻塞</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (selector.select() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取当前选择器所有注册的事件</span></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator= selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey selectionKey = iterator.next();</span><br><span class="line">                <span class="comment">// 接收事件就绪，此处为有TCP连接</span></span><br><span class="line">                <span class="keyword">if</span> (selectionKey.isAcceptable()) &#123;</span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selectionKey.isReadable()) &#123; <span class="comment">// 读事件就绪</span></span><br><span class="line">                    <span class="comment">// ...</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 取消选择键(已经处理过的事件，就应该取消掉了)</span></span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="selector.png" alt="alt"></p><h2 id="5-零拷贝"><a href="#5-零拷贝" class="headerlink" title="5. 零拷贝"></a>5. 零拷贝</h2><p>Java NIO 底层除了使用 IO 多路复用外，还使用了零拷贝技术。</p><p>通过网络发送文件通常使用 <code>read</code> 和 <code>write</code> 函数，需要经历 4 次拷贝：</p><ul><li>第 1 次：将磁盘的数据拷贝到操作系统内核的的缓冲区，通过 DMA 实现；</li><li>第 2 次：将内核缓冲区的数据拷贝到用户进程缓冲区，通过 CPU 实现；</li><li>第 3 次：将用户进程缓冲区的数据拷贝到内核 socket 的缓冲区，通过 CPU 实现；</li><li>第 4 次：将 socket 缓冲区的数据拷贝到网卡中，通过 DMA 实现。</li></ul><p><img src="4次拷贝.png" alt="alt"></p><p>上述过程开销严重，要想提高文件的传输效率，必须减少 <strong>内存拷贝</strong> 的次数，通常有两种实现方式：</p><ul><li>mmap</li><li>sendfile</li></ul><h4 id="mmap"><a href="#mmap" class="headerlink" title="mmap"></a>mmap</h4><p><code>mmap</code> 可以将内核缓冲区的数据映射到用户空间，共享缓冲区，内核和用户空间之间就不需要进行拷贝操作，此时传输文件的拷贝次数如下：</p><ul><li>将磁盘数据拷贝到内核缓冲区，与用户程序共享；</li><li>用户程序调用 <code>write</code>，操作系统将内核缓冲区的拷贝到 socket 缓冲区，由 CPU 完成；</li><li>将 socket 缓冲区的数据拷贝到网卡中，通过 DMA 实现。</li></ul><p><img src="mmap.png" alt="alt"></p><p>这种方式减少了内核缓冲区到用户空间的 1 次拷贝。</p><h4 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h4><p><code>sendfile</code> 函数可以将内核缓冲区的数据直接拷贝到 socket 缓冲区，而不用经过用户空间，效果如下：</p><p><img src="sendfile.png" alt="alt"></p><p>数据拷贝都使用 DMA 实现，没有内存层面的拷贝，这被称为零拷贝。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://tech.meituan.com/2016/11/04/nio.html">Java NIO浅析</a></li><li><a href="http://tutorials.jenkov.com/java-nio/index.html">Java NIO Tutorial</a></li><li><a href="https://zhuanlan.zhihu.com/p/27625923">Direct Buffer</a></li><li><a href="https://zhuanlan.zhihu.com/p/26243285">Java NIO编程实例之三 Selector</a></li><li><a href="https://zhuanlan.zhihu.com/p/258513662">原来 8 张图，就可以搞懂零拷贝了</a></li><li><a href="https://www.jianshu.com/p/3ec120ca46b2">JDk Epoll空轮询Bug</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java IO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO多路复用</title>
      <link href="/2022/02/15/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
      <url>/2022/02/15/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Socket-基础"><a href="#1-Socket-基础" class="headerlink" title="1. Socket 基础"></a>1. Socket 基础</h2><p>网络通信依赖 Socket 实现，内核对应用层提供 socket 接口供用户进程访问。</p><p><img src="socket.png" alt="alt"></p><p>socket 维护了读写缓冲区，当使用操作系统提供的 write 写入数据时，需要先将数据从用户态拷贝到内核态的缓冲区，由操作系统发送。对端的网卡收到数据后，通过触发中断， 将网卡数据拷贝到内核的缓冲区，再拷贝到用户空间供进程读取。</p><p><img src="缓冲区.png" alt="alt"></p><p>对于传统的阻塞IO BIO（Blocking IO），一次阻塞读取的工作流程如下：</p><ul><li>阻塞式读取 Socket，缓冲区中没有数据；</li><li>进程进入阻塞状态，从 CPU 的运行队列中出队，进入 Socket 的等待队列；</li><li>客户端的数据到达网卡，通过 DMA 将数据拷贝到缓存区，完成后发起中断；</li><li>系统响应中断，将进程从 Socket 的等待队列移动到 CPU 的运行队列，进程有机会获得 CPU 时间片。</li></ul><h2 id="2-IO多路复用"><a href="#2-IO多路复用" class="headerlink" title="2. IO多路复用"></a>2. IO多路复用</h2><h3 id="2-1-C10K"><a href="#2-1-C10K" class="headerlink" title="2.1 C10K"></a>2.1 C10K</h3><p>一个 TCP 服务器如何处理多个请求呢？直观的想法对于多个请求按顺序处理，由于使用 BIO，后一个请求需要等待前一个请求完成，这样的处理方式完全没有并发能力，对于多核 CPU 服务器而言导致大量的计算资源浪费。</p><p>另一个更合适的做法是使用一个线程处理连接，为每一个连接创建一个新线程来处理业务，这样处理能够运用多核特性。</p><p><img src="c10k.png" alt="alt"></p><p>但存在大量不活跃的长连接时，上述方案仍会出现问题，这是因为线程是很贵的资源：</p><ul><li>线程的内存开销大。每一个线程内核需要为其分配 512K - 1M 的空间，如果系统中的线程数量过 10k，JVM 的内存也会被消耗殆尽，无法提供服务；</li><li>线程的切换成本高。操作系统的线程切换需要保存上下文，并执行系统调用，过高的线程数，可能导致线程切换的时间占比更高，使用多线程反而导致了性能的下降。</li></ul><p>上述单机服务器实现大量连接的问题被称为 C10K 问题。</p><h3 id="2-2-IO多路复用"><a href="#2-2-IO多路复用" class="headerlink" title="2.2 IO多路复用"></a>2.2 IO多路复用</h3><p>IO 多路复用由此产生，其思想就是用一个线程，同时监听若干个 socket 连接是否可以执行 IO 操作，在单线程的情况下可以同时处理多个客户端请求。</p><blockquote><p>IO 多路复用的核心优势在于处理更多的连接，在连接数不高的情景下，使用 IO 多路复用的性能可能比 BIO + 多线程的方式低。</p></blockquote><p>Linux 上的 IO 多路复用有 select、poll、epoll 三个实现。</p><h2 id="3-select"><a href="#3-select" class="headerlink" title="3. select"></a>3. select</h2><p><code>select</code> 方法定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> max_fd, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, </span></span></span><br><span class="line"><span class="params"><span class="function">           struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>其中 <code>max_fd</code> 是最大文件描述符的值，<code>readfds</code>、<code>writefds</code> 和<code>exceptfds</code>  分别对应读、写、异常条件的文件描述符，<code>timeout</code> 为超时时间。</p><blockquote><p>Linux 的思想是一切皆文件，网络 IO 也被看成文件处理，会分配文件描述符。</p></blockquote><p><code>fd_set</code> 数据结构使用位图实现，默认大小为 1024，传给内核之后，内核根据 IO 完成情况给 <code>fd_set</code> 置位，并返回 IO 就绪的文件描述符个数。例如传入的 <code>read_fds</code> 的第 1、2、3 位为1，那么传入内核之后，内核会监听文件描述符 1、2、3 对应的 socket 连接并将 <code>read_set</code> 清零，如果此时 1、3 完成读 IO，那么 <code>read_fds</code> 的第 1、3 位将被设置为 1，<code>select</code> 函数的返回值为 2。</p><p><code>select</code> 会阻塞直到有 IO 完成或者超时返回，在这期间，内核需要扫描整个 <code>fd_set</code> 才能判断是否有事件发生，效率低下。</p><p><img src="select示例.png" alt="alt"></p><p><code>fd_set</code> 的使用涉及以下几个 API：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ZERO</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;  <span class="comment">// 将 fd_set 所有位置 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>;   <span class="comment">// 将 fd_set 的第 fd 位置 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fd_set)</span></span>;  <span class="comment">// 将 fd_set 的第 fd 位置 1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *fdset)</span></span>; <span class="comment">// 检测 fd_set 的第 fd 位是否为 1</span></span><br></pre></td></tr></table></figure><p>例如完成一个 TCP 服务器，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ... 初始化socket</span></span><br><span class="line"><span class="keyword">int</span> maxfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> <span class="title">read_set</span>;</span></span><br><span class="line"><span class="keyword">int</span>[] accept_fds[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// 从已连接队列中取出5个连接，用于后续的select</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    accept_fds[i] = accpet(...);</span><br><span class="line">    <span class="comment">// 获得文件描述符的最大值</span></span><br><span class="line">    <span class="keyword">if</span> (accept_fds[i] &gt; maxfd) &#123;</span><br><span class="line">        maxfd = accept_fds[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 每次执行select之前，都需要重新设置read_set</span></span><br><span class="line">    FD_ZERO(&amp;read_set);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 置位，表示对这些连接感兴趣</span></span><br><span class="line">        FD_SET(accept_fds[i], &amp;read_set);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    select(maxfd + <span class="number">1</span>, &amp;rest, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (FD_ISSET(accept_fds[i], &amp;rest)) &#123;</span><br><span class="line">            <span class="comment">// 处理业务...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的说明也可以看出 <code>select</code> 有以下缺点：</p><ul><li><code>fd_set</code> 固定长度为 1024，最多监听 1024 个连接，增加连接需要改动内核源码重新编译；</li><li><code>fd_set</code> 需要从用户态传入内核态。并且传入内核中都会被改写，不可重用，每次调用 <code>select</code> 前需要重新初始化；</li><li>拿到结果后，需要遍历整个 <code>fd_set</code>，才能知道哪些连接可以处理。</li></ul><h2 id="4-poll"><a href="#4-poll" class="headerlink" title="4. poll"></a>4. poll</h2><p><code>poll</code> 的函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">               <span class="keyword">int</span>   fd;         <span class="comment">// 文件描述符</span></span><br><span class="line">               <span class="keyword">short</span> events;     <span class="comment">// 感兴趣的响应事件，通过掩码设置</span></span><br><span class="line">               <span class="keyword">short</span> revents;    <span class="comment">// 实际响应事件，通过掩码设置</span></span><br><span class="line">           &#125;;</span><br></pre></td></tr></table></figure><p>其中 <code>fds</code> 是 <code>pollfs</code> 类型的数组，<code>nfd</code> 是 <code>fds</code> 数组的长度。</p><p><code>poll</code>与 <code>select</code> 的功能基本相同，主要是解决了连接上限的问题，<code>select</code> 的其他缺点 <code>poll</code> 仍然具有。</p><blockquote><p>限于篇幅，<code>poll</code> 的编程使用不在此处介绍，感兴趣的话可以阅读 《UNIX网络编程卷1》 6.11 小节。</p></blockquote><h2 id="5-epoll"><a href="#5-epoll" class="headerlink" title="5. epoll"></a>5. epoll</h2><h3 id="5-1-epoll介绍"><a href="#5-1-epoll介绍" class="headerlink" title="5.1 epoll介绍"></a>5.1 epoll介绍</h3><p><code>epoll</code> 是对 <code>select</code> 和 <code>poll</code> 的改进，使用了三个函数，下面将依次介绍。</p><h4 id="epoll-create"><a href="#epoll-create" class="headerlink" title="epoll_create"></a>epoll_create</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><code>epoll_create</code> 会创建一个实例，并返回对应的文件描述符，参数 size 是 <code>epoll</code> 监听的文件描述符个数，并不是上限值，而是对内核初始化数据结构的一个建议。</p><p>内部的数据结构：</p><ul><li>监听列表：所有要监听的文件描述符，用红黑树存储</li><li>就绪列表：所有就绪的文件描述符，使用链表存储</li></ul><p><img src="epoll数据结构.png" alt="alt"></p><h4 id="epoll-ctl"><a href="#epoll-ctl" class="headerlink" title="epoll_ctl"></a>epoll_ctl</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br></pre></td></tr></table></figure><p><code>epoll_ctl</code> 是事件注册函数，<code>epfd</code> 即 <code>epoll_create</code> 返回的文件描述符，<code>fd</code> 即要监听的文件描述符，<code>event</code> 是要监听的事件。</p><p><code>epoll_ctl</code> 会将文件描述符 <code>fd</code> 添加到监听列表中，并监听事件 <code>event</code>，当 <code>fd</code> 上发生相应事件时，将 <code>fd</code> 添加到 <code>epoll</code> 实例的就绪队列上。</p><h4 id="epoll-wait"><a href="#epoll-wait" class="headerlink" title="epoll_wait"></a>epoll_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><code>epoll_wait</code> 会等待 <code>epfd</code> 上的 IO 事件，最多返回 <code>maxevents</code> 个事件，<code>events</code> 参数即从内核得到事件的集合。</p><h3 id="5-2-触发形式"><a href="#5-2-触发形式" class="headerlink" title="5.2 触发形式"></a>5.2 触发形式</h3><p>水平触发（LT，Level Trigger）：当文件描述符就绪时，会触发通知，如果用户程序没有一次性把数据读/写完，下次还会发出可读/可写信号进行通知。</p><p>边缘触发（ET，Edge Trigger）：仅当描述符从未就绪变为就绪时，通知一次，之后不会再通知。该模式效率更高，但必须使用非阻塞读写。</p><blockquote><p>epoll 默认使用水平触发。</p></blockquote><h3 id="5-3-改进点"><a href="#5-3-改进点" class="headerlink" title="5.3 改进点"></a>5.3 改进点</h3><p>相较于 <code>select</code> 和 <code>poll</code>，<code>epoll</code> 有两个改进点：</p><ul><li><code>epoll_wait</code> 在检测是否有事件发生时，只要检测链表是否为空即可，并将发生的事件复制到用户态；</li><li><code>epoll</code> 对于每个描述符，只需要在 <code>epoll_ctl</code> 传递一次，之后 <code>epoll_wait</code> 不需要再次传递，这也大大提高了效率。</li></ul><h2 id="6-对比"><a href="#6-对比" class="headerlink" title="6. 对比"></a>6. 对比</h2><p><code>select</code>、<code>poll</code>、<code>epoll</code> 的对比如下：</p><ul><li>最大连接数：<code>select</code> 最大连接数为 1024，增加连接数需要改动内核；<code>poll</code> 和 <code>epoll</code> 没有连接上限；</li><li>文件描述符剧增的 IO 效率：<code>select</code> 和 <code>poll</code> 需要对所有连接进行扫描，在多连接时效率低；<code>epoll</code> 只对活跃的连接进行扫描，性能不会大幅度下降，但面对大量活跃连接仍有性能问题；</li><li>数据拷贝：<code>select</code> 和 <code>poll</code> 每次都需要向内核拷贝，<code>epoll</code> 只需要拷贝一次。</li></ul><p>三者的适用场景：</p><ul><li><code>epoll</code>：大量不活跃连接场景，限制 Linux 平台。</li><li><code>select</code> ：少量活跃短连接场景，不同于 <code>epoll</code> 和 <code>poll</code>，<code>select</code> 有移植性。</li><li><code>poll</code> ：大量活跃短连接场景。 </li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://tech.meituan.com/2016/11/04/nio.html">Java NIO浅析</a></li><li><a href="https://zhuanlan.zhihu.com/p/353850099">深入理解高性能网络开发路上的绊脚石 - 同步阻塞网络 IO</a></li><li><a href="http://www.kegel.com/c10k.html">C10K Problem</a></li><li><a href="https://imageslr.com/2020/02/27/select-poll-epoll.html#fd_set-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E9%9B%86%E5%90%88">IO多路复用, select/poll/epoll详解</a></li><li><p><a href="https://book.douban.com/subject/1500149/">UNIX网络编程卷1</a></p></li><li><p><a href="https://my.oschina.net/lscherish/blog/4492873">详解IO多路复用和其三种模式—select/poll/epoll</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IO多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的redo log和binlog</title>
      <link href="/2022/02/11/MySQL%E4%B8%AD%E7%9A%84redo-log%E5%92%8Cbinlog/"/>
      <url>/2022/02/11/MySQL%E4%B8%AD%E7%9A%84redo-log%E5%92%8Cbinlog/</url>
      
        <content type="html"><![CDATA[<p>使用 MySQL 的过程中难免会与其日志系统打交道，主要有 redo log，binlog，undo log 和慢查询日志等，本文主要介绍 redo log 和 binlog。</p><h2 id="1-redolog"><a href="#1-redolog" class="headerlink" title="1. redolog"></a>1. redolog</h2><h3 id="1-1-buffer-pool"><a href="#1-1-buffer-pool" class="headerlink" title="1.1 buffer pool"></a>1.1 buffer pool</h3><p>数据库中的行数据、索引等，都是存储在磁盘上面的，当访问某个页时，需要从磁盘把整个页的数据加载到内存，读写完成之后释放内存。</p><p>磁盘访问是十分低效的，为此 InnoDB 引入缓冲池 buffer pool，在 MySQL 启动时申请一片连续的内存，作为磁盘页的缓存。对数据库进行读取页的操作，首先从磁盘读到的页存放在 buffer pool，从磁盘读入数据时，会将该页放入 buffer pool，下一次读取相同的页时，先判断在 buffer pool 中是否存在；对数据的修改也是先对 buffer pool 中的页进行修改，并由后台线程在系统空闲时进行刷盘。</p><p>buffer pool 的空间也是有上限的，其淘汰策略采用优化的 LRU 算法。</p><blockquote><p>具体实现可见 《MySQL技术内幕 InnoDB 存储引擎》2.3.2 小节。</p></blockquote><h3 id="1-2-redo-log"><a href="#1-2-redo-log" class="headerlink" title="1.2 redo log"></a>1.2 redo log</h3><p>磁盘中的数据会落后于 buffer pool，如果进程或者机器崩溃， buffer pool 中未能落盘的数据将会丢失。事务中的持久性要求提交之后，对数据的修改不能丢失，一个直观的思路是事务提交前保证修改的页全部刷盘，但这个思路有两个不足：</p><ul><li>刷新一个页过于浪费，有时候只改动了页中一点数据，却要将整个页的数据刷入磁盘</li><li>随机 IO，一个事务可能改动多个页面，传统的机械硬盘随机 IO 效率十分低下</li></ul><p>为此 InnoDB 维护了 redo log，redo log 的思路是用轻量的数据记录改动，并把随机 IO 转化为顺序 IO，极大提升了写入效率。事务在 redo log 全部落盘后才能提交，即使崩溃也可以通过重放 redo log 复原数据，保证了持久性。</p><blockquote><p>这种机制被称为 WAL，Write Ahead Log，被广大事务数据库采用。</p></blockquote><p>那么 redo log 的格式应该是什么样呢？首先，redo log 的数据量需要尽可能小，否则会影响性能。其次，系统崩溃后重放数据不知道哪些页已经刷盘，redo log 应该保证幂等。因此，redo log 的格式为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(PageId, Record Offset, (Field 1, Value 1), (Field 2, Value 2)...)</span><br></pre></td></tr></table></figure><p>PageId 确定了修改的页，Record Offset 为修改的数据在页中的偏移，后面的 Field-Value 对记录了修改的列以及数据。</p><blockquote><p>redo log 是 InnoDB 特有的机制。</p></blockquote><h3 id="1-3-redo-log刷盘"><a href="#1-3-redo-log刷盘" class="headerlink" title="1.3 redo log刷盘"></a>1.3 redo log刷盘</h3><p>InnoDB 为了解决磁盘速度过慢的问题引入 buffer pool，相应的，redo log 也不是直接写入磁盘，而是先写入 redo log buffer，默认在以下场景刷新到磁盘：</p><ul><li>redo log buffer 空间过半</li><li>事务提交前</li><li>buffer pool 的页刷盘前</li><li>正常关闭服务等</li><li>做 checkpoint </li></ul><blockquote><p>redo log 的刷盘时机可以通过 innodb_flush_log_at_trx_commit 控制，可以通过牺牲持久性来换取运行效率，一般不推荐修改。</p></blockquote><p>不幸的是，在磁盘上存储的 redo log 大小是有上限的，分为 4 块 1GB 大小的文件，总共 4 GB。从头开始写，写到末尾又从开头循环写，也就是说，后写的日志可能覆盖以前的位置。</p><p><img src="checkpoint.png" alt="alt"></p><p>write pos 是当前 redo log 记录的位置，而 checkpoint 是当前要擦除的位置， 中间是还可以记录的部分。当 buffer pool 中的页刷盘之后，其 redo log 便可以被覆盖了，checkpoint 则进行相应的改变。</p><h2 id="2-binlog"><a href="#2-binlog" class="headerlink" title="2. binlog"></a>2. binlog</h2><h3 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h3><p>上文说到 redo log 可以用于故障后恢复，但只限于 InnoDB，而 InnoDB 是在 MySQL 比较后面的版本才引入的。对于早期的 MySQL，使用的是 binlog。binlog 是 binary log 的缩写，即二进制日志，记录了对数据库执行的更改操作，主要用于全量数据备份。</p><p>binlog 可以通过启动选项 binlog-format 配置记录形式：</p><ul><li>statement： 记录 SQL 更新语句</li><li>row：记录行的内容，包括更新前和更新后的值</li><li>mixed：通常使用 statement，某些特殊情况转为 row，具体可见 <a href="https://dev.mysql.com/doc/refman/8.0/en/binary-log-mixed.html">binary log mixed</a></li></ul><blockquote><p>binlog 另一个用途是 MySQL 主从服务器之间的数据同步，在主从复制中 binlog-format 需要选择 row。</p></blockquote><h3 id="2-2-两阶段提交"><a href="#2-2-两阶段提交" class="headerlink" title="2.2 两阶段提交"></a>2.2 两阶段提交</h3><p>两阶段提交是将 redo log 的写入分为 prepare 和 commit 两个部分，其中 commit 需要在 binlog 写入之后完成。</p><blockquote><p>这里的两阶段提交与分布式事务中的两阶段提交不同，需要进行区分。</p></blockquote><p><img src="两阶段提交.png" alt="alt"></p><p>两阶段提交的目的是让 redo log 和 binlog 的逻辑一致。如果 binlog 写入成功但 commit 未提交，mysql 启动时会自动提交这个事务；如果 prepare 完成但 binlog 写入失败，mysql 启动时会自动回滚这个事务。</p><p>如果直接先写 redo log 后写 binlog，或者反过来，那么效果会如何，以下将 id = 2 的行中 c 从 0 更新到 1 进行分析：</p><ul><li>先写 redo log 后写 binlog：redo log 写完，binlog 还没写完产生了 crash，通过回放 redo log 可以恢复 c = 1，但是 binlog 未写完，丢失了这个更新，那么在进行数据库备份时将会丢失这条数据，以后用这个备份进行恢复会导致数据错误；</li><li>先写 binlog 后写 redo log：回放 redo log 事务无效，c = 0，但在 binlog 中已经记录了 “c 从 0 变为 1” 这个日志，那么以后用 binlog 备份恢复时将会多出来这个事务。</li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>redo log 用于恢复主机故障时未更新的数据，binlog 用于备份操作，两阶段提交就是保持故障恢复和备份恢复的结果一致性。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/book/6844733769996304392">MySQL是怎样运行的</a></li><li><a href="https://time.geekbang.org/column/intro/100020801?tab=catalog">MySQL实战45讲</a></li><li><a href="https://book.douban.com/subject/24708143/">MySQL技术内幕</a></li><li><a href="http://mysql.taobao.org/monthly/2020/02/01/">庖丁解InnoDB之REDO LOG</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIxNTQ3NDMzMw==&amp;mid=2247486774&amp;idx=1&amp;sn=bac4946a1ad1479837b58f6746475ab7&amp;chksm=979684c4a0e10dd2b393814bed9bbac28608f9df2eec89d1437eaac80bd976cc52f5dc87aaaf&amp;sessionid=0&amp;scene=126&amp;clicktime=1644559487&amp;enterid=1644559487&amp;ascene=3&amp;devicetype=android-30&amp;version=28000b5b&amp;nettype=WIFI&amp;abtest_cookie=AAACAA%3D%3D&amp;lang=zh_CN&amp;exportkey=A%2B93mW%2BVOVZnE31E5Ki5JiU%3D&amp;pass_ticket=DuSjQXj3xDf0Of3ww7KcjiFL1S359iz%2BhlLBi3gCKgQZOvbi2UpW0ruhmMlmcjgJ&amp;wx_header=3">我们都是小青蛙 公众号</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(3) 垃圾回收</title>
      <link href="/2022/02/09/JVM%E7%B3%BB%E5%88%97(3)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
      <url>/2022/02/09/JVM%E7%B3%BB%E5%88%97(3)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="1-垃圾识别"><a href="#1-垃圾识别" class="headerlink" title="1. 垃圾识别"></a>1. 垃圾识别</h2><h3 id="1-1-GC介绍"><a href="#1-1-GC介绍" class="headerlink" title="1.1 GC介绍"></a>1.1 GC介绍</h3><p>在 C 语言中，程序员需要手动管理内存，使用 malloc 分配内存，当对象不再使用时，需要使用 free 回收内存。如果忘记调用，这块内存将一直占用无法被使用，导致内存泄露，如果放任内存泄露的程序运行，在某一刻内存将占满，程序崩溃。另外，程序员可能会错误释放使用中的内存空间，下一次程序使用此空间时将会发生故障，往往会遇到令人头疼的段错误。以上问题出现的时间可能不一致，导致这类 BUG 难以定位。</p><p>为了摆脱手动管理内存的困境，Garbarge Collection，GC，垃圾回收机制应运而生。对象如果不再使用，其占用的内存将会自动被回收，后来出现的大部分语言，例如 Java、Go、C# 等都引入了垃圾回收机制。</p><h3 id="1-2-垃圾识别"><a href="#1-2-垃圾识别" class="headerlink" title="1.2 垃圾识别"></a>1.2 垃圾识别</h3><p>在回收对象内存之前，需要先判断该对象是否存活，有两种经典的算法：</p><ul><li>引用计数</li><li>可达性分析</li></ul><h4 id="1-2-1-引用计数"><a href="#1-2-1-引用计数" class="headerlink" title="1.2.1 引用计数"></a>1.2.1 引用计数</h4><p>引用计数的思路是，在对象中添加一个引用计数器，当被引用时，计数 +1，引用失效时，计数 -1。如果计数器的值为 0，则该对象不再被使用，可以进行回收。</p><p>引用计数的优点是思路简单，可以立即回收垃圾，暂停时间短。</p><p>引用计数无法解决循环依赖的问题，例如 A 引用了 B，B 又引用了 A，那么两个对象的计数永远不为 0，也不会被回收。</p><p>使用引用计数的语言有 Swift、C++ 11 中的 shared_ptr 等，为了解决循环依赖问题，这两种编程语言都提出了弱引用的概念，弱引用不会增加引用计数。</p><blockquote><p>虽然使用弱引用可以解决循环依赖问题，但是程序员需要判断该场景是否需要使用弱引用，在复杂的循环引用中这仍是一件痛苦的事情。</p></blockquote><h4 id="1-2-2-可达性分析"><a href="#1-2-2-可达性分析" class="headerlink" title="1.2.2 可达性分析"></a>1.2.2 可达性分析</h4><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>另一种更加主流的机制是使用可达性分析，其思路是通过存活的一些根节点对象，根据他们的引用关系向下搜索，所经过的路径称为引用链，如果对象在引用链上不可达，便可以被回收。大部分商用语言 Java、C#、Go 都使用了可达性分析。</p><p>在 Java 中，这些存活的根节点称为 GCRoots，固定包含：</p><ul><li>虚拟机栈中引用的对象，例如栈帧中的方法参数、局部变量等；</li><li>与虚拟机栈类似，本地方法栈引用的对象；</li><li>类静态属性引用的对象；</li><li>常量引用的对象，例如字符串对象；</li><li>虚拟机内部的引用，例如基本数据类型包装类的 Class 对象，常驻异常对象，系统类加载器；</li><li>被 synchronized 锁持有的对象。</li></ul><h5 id="三色标记"><a href="#三色标记" class="headerlink" title="三色标记"></a>三色标记</h5><p>直接利用可达性分析识别垃圾时需要暂停所有用户线程，即 STW（Stop The World）来保证引用关系的正确性。其中枚举 GCRoots 在优化下已经十分高效，但根据引用链遍历的过程与对象数量和结构相关，耗时严重。</p><p>为了解决上述问题，引入了三色标记算法。</p><p>顾名思义，这个算法将 GC 过程中的对象分为三种：</p><ul><li>白色：还未搜索过的对象</li><li>灰色：正在搜索的对象</li><li>黑色：搜索完成的对象</li></ul><p>GC 开始前所有对象都是白色，首先将 GCRoots 标记为灰色，利用广度优先搜索的思想，不断取出灰色对象 G，并将 G 引用的所有对象 S1、S2 都标记为灰色，最后将 G 标记为黑色。之后将不断重复上述过程，标记结束之后存活对象均为黑色，垃圾均为白色。</p><p>三色标记过程可以与用户线程并发执行，但在标记过程中用户线程可能改变引用关系，导致将存活的对象标记为白色，程序发生错误，如下图所示。</p><p><img src="漏标记.png" alt="alt"></p><p>(a) 中 A 为黑色，B 为灰色，此时将要遍历 B 引用的对象，(b) (c) 中用户线程去掉了 B 到 C 的引用，增加了 A 到 C 的引用，此时 C 理应存活，但 A 已经遍历结束，已经没有引用链可以到达 C，C 被标记为白色，GC 过程中将被回收。</p><p>科学家们证明了上述漏标出现需要同时满足两个条件：</p><ul><li>插入了黑色对象到白色对象的引用</li><li>删除了所有灰色对象到该白色对应的引用</li></ul><p>破坏条件 1 的方案为增量更新，黑色对象新增对白色对象的引用，将变为灰色。</p><p>破坏条件 2 的方案为原始快照，当灰色对象删除到白色对象的引用时，记录这些灰色对象，在并发扫描结束后，重新扫描这些灰色对象。</p><h2 id="2-垃圾收集算法"><a href="#2-垃圾收集算法" class="headerlink" title="2. 垃圾收集算法"></a>2. 垃圾收集算法</h2><h3 id="2-1-分代收集"><a href="#2-1-分代收集" class="headerlink" title="2.1 分代收集"></a>2.1 分代收集</h3><p>主流的垃圾收集器都遵守了分代收集的理论，即在不同的区域使用不同的垃圾收集算法，其建立在两个假设上：</p><ul><li>绝大多数对象创建后不久就会被回收；</li><li>多次未被垃圾回收的对象越难消亡。</li></ul><p>这两个假设给出了垃圾收集器的设计原则，将堆分为不同的区域，新生代和老年代。新生代中的对象大概率会被回收，而存活的对象将逐步晋升到老年代。</p><p>但如果新生代和老年代的对象互相引用，即跨代引用，将导致每次 GC 都需要使用可达性分析遍历新生代和老年代，性能开销大。为此在新生代建立一种数据结构卡表，卡表会标记老年代的某一块内存存在跨代引用，当新生代发生 Minor GC 时，只有那块内存会被加入了 GCRoots 进行扫描，提高了 GC 的效率。</p><h3 id="2-2-术语定义"><a href="#2-2-术语定义" class="headerlink" title="2.2 术语定义"></a>2.2 术语定义</h3><p>hotspot 常用的 GC 类型：</p><ul><li>部分收集：针对堆中某些部分进行垃圾收集<ul><li>Minor GC：也成 Young GC，在新生代进行收集；</li><li>Major GC：也称 Old GC，在老年代进行收集，只有 CMS 的并发收集是这个模式；</li><li>Mixed GC：收集新生代和部分老年代，只有 G1 使用该模式。</li></ul></li><li>整堆收集：Full GC，收集整个堆，包括新生代、老年代、永久代（如果有的话）。</li></ul><blockquote><p>Major GC 通常等价于 Full GC，hotspot 历史悠久，外界对各种名词的解读已经完全混乱了，需要仔细辨别。</p></blockquote><p>接下来将介绍三个常见的垃圾收集算法。</p><h3 id="2-3-标记-清除算法"><a href="#2-3-标记-清除算法" class="headerlink" title="2.3 标记-清除算法"></a>2.3 标记-清除算法</h3><p>标记-清除算法首先标记需要回收的对象，在标记完成后，回收被标记的对象。</p><p>该算法优点是直观简单，但有以下缺点：</p><ul><li>执行效率随需要被回收的对象数量增加</li><li>产生内存碎片</li><li>与 copy on write 机制不兼容，需要引入其他机制弥补</li></ul><p><img src="标记清除.png" alt="alt"></p><h3 id="2-4-标记-复制算法"><a href="#2-4-标记-复制算法" class="headerlink" title="2.4 标记-复制算法"></a>2.4 标记-复制算法</h3><p>标记-复制算法将内存分为相等的两块 T1 和 T2，每次只使用其中一块，发生 GC 时，将 T1 存活的对象复制到 T2，并回收 T1，交换 T1 和 T2 的角色。</p><p>标记-复制算法解决了标记-清除算法面对大量可回收对象效率低下的问题，但是可用内存缩小了原来的一半，更容易发生 GC，故常用在新生代。</p><p><img src="标记复制.png" alt="alt"></p><h3 id="2-5-标记-整理算法"><a href="#2-5-标记-整理算法" class="headerlink" title="2.5 标记-整理算法"></a>2.5 标记-整理算法</h3><p>标记-整理算法的标记过程与标记-清除算法相同，但后续不是直接回收对象，而是让存活的对象往一端移动，并清理到边界以外的对象。</p><p><img src="标记整理.png" alt="alt"></p><p>整理的过程需要 STW，如果内存中只有少量存活对象，那么标记-整理算法既高效又节约内存，常用在老年代。但如果存在大量存活对象，标记-整理算法将十分低效。</p><h2 id="3-垃圾收集器"><a href="#3-垃圾收集器" class="headerlink" title="3. 垃圾收集器"></a>3. 垃圾收集器</h2><p>接下来将介绍 hotspot 中的垃圾收集器。</p><h3 id="3-1-Serial-和-Serial-Old"><a href="#3-1-Serial-和-Serial-Old" class="headerlink" title="3.1 Serial 和 Serial Old"></a>3.1 Serial 和 Serial Old</h3><p>Serial 是新生代的收集器，使用标记-复制算法，只使用一个线程去完成 GC 工作，并且整个过程需要 STW。</p><p>Serial 是老年代的收集器，使用标记-整理算法，其他特点与 Serial 相同。</p><h3 id="3-2-ParNew"><a href="#3-2-ParNew" class="headerlink" title="3.2 ParNew"></a>3.2 ParNew</h3><p>ParNew 是 Serial 的多线程版本，使用多线程在新生代进行 GC，其余均与 Serial 相同，整个过程仍需 STW。</p><h3 id="3-3-Parallel-Scavenge-和-Paralllel-Old"><a href="#3-3-Parallel-Scavenge-和-Paralllel-Old" class="headerlink" title="3.3 Parallel Scavenge 和 Paralllel Old"></a>3.3 Parallel Scavenge 和 Paralllel Old</h3><p>Parallel Scavenge 是新生代的收集器，采用标记-复制算法，关注吞吐量，其中 吞吐量 = 用户代码运行时间 / (用户代码运行时间 + GC 运行时间)，它会根据用户设置的预期吞吐量自行分配堆运行。</p><p>Parallel Old 是 Parallel Scavenge 的老年代版本，采用标记-整理算法。</p><h3 id="3-4-CMS"><a href="#3-4-CMS" class="headerlink" title="3.4 CMS"></a>3.4 CMS</h3><p>Concurrent Mark Sweep，CMS，是一款老年代收集器，基于标记-清除算法，其关注点是 <strong>STW 的时间尽可能短</strong>。</p><p>CMS 的 GC 分为四个过程：</p><ul><li>初始标记：标记 GCRoots 直接引用的对象，需要 STW</li><li>并发标记：遍历引用链进行三色标记，CMS 避免误标的方式是使用增量更新</li><li>重新标记：使用增量更新重新标记，需要 STW</li><li>并发清除：清除所有的对象</li></ul><blockquote><p>在上文收集算法中提出，老年代常使用的标记-整理算法需要 STW。CMS 的关注点是暂停时间，这是 CMS 虽然是老年代收集器，但使用标记-清除算法的原因。</p></blockquote><p><img src="cms.png" alt="alt"></p><p>虽然 CMS 带来了极低的暂停时间，但也存在以下问题：</p><ul><li>在 CPU 核心数较低时开销较大，CMS 的回收线程配置为 （处理器核心数量 +3）/4，在低配计算机上 GC 过程会影响用户体验；</li><li>无法处理浮动垃圾，即并发标记和并发删除期间，用户线程产生的垃圾无法在本次 GC 回收；</li><li>采用标记-清除算法带来的内存碎片。</li></ul><h3 id="3-5-G1"><a href="#3-5-G1" class="headerlink" title="3.5 G1"></a>3.5 G1</h3><p>Garbage Firtst，G1，其目标是 <strong>soft real time</strong>，在固定时间内，停顿的时间不超过预期，例如在任意 1s 内，停顿的时间不超过 10ms。</p><p>为了实现可预测的停顿时间，G1 将堆内存化整为零，将堆内存划分为多个大小相同的区域 Region，每个 Region 根据需要可以成为新生代和老年代，并采用不同的策略进行处理。Region 是回收的最小单位，每个 Region 都会根据可回收的空间和回收所需时间维护优先级，优先回收高优先级的 Region。</p><p>由于将堆分为多个 Region，G1 对以下问题进行了额外的处理：</p><ul><li>跨 Region 引用：维护双向卡表，记录每个 Region 的指向和被指向关系；</li></ul><blockquote><p>双向卡表在此处主要是为了便于理解，在 G1 的论文中使用的都是记忆集 Remembered Set 。</p></blockquote><ul><li>三色标记的误删问题：采用原始快照算法实现，并且在标记前设置了 TAMS（Top at Mark Start） 指针，并发标记期间用户线程只能在指针之间的区域创建对象。</li></ul><p>类似 CMS，G1 的 GC 也分为四个过程：</p><ul><li>初始标记：标记 GCRoots 直接引用的对象，设置 TAMS，需要 STW</li><li>并发标记：遍历引用链进行标记，并记录原始快照</li><li>最终标记：根据原始快照重新标记防止误删，需要 STW</li><li>筛选回收：更新 Region 的优先级，将待回收 Region 的存活对象复制到空 Region中，回收整个 Region，需要 STW</li></ul><p><img src="g1.png" alt="alt"></p><p>G1 有以下两种模式，并视情况切换：</p><ul><li>Young GC：回收区域为新生代的 Region，初始标记在这个过程执行</li><li>Mixed GC：回收区域为新生代的 Region 和部分高优先级老年代 Region</li></ul><blockquote><p>这不代表 G1 就不进行 Full GC，当 Mixed GC 无法更上内存分配的速度时将触发 Full GC。使用了 G1 的 System.gc() 默认是 Full GC。</p><p>此处强烈推荐关注 RednaxelaFX 的博客，博主对 JVM 的理解非常深入，在博客中介绍了大量实现细节，链接放在参考资料。</p></blockquote><p>限于篇幅，G1 的调优相关可以阅读 <a href="https://www.oracle.com/technical-resources/articles/java/g1gc.html">G1 Tuning</a>。</p><h3 id="3-6-ZGC"><a href="#3-6-ZGC" class="headerlink" title="3.6 ZGC"></a>3.6 ZGC</h3><h4 id="3-6-1-介绍"><a href="#3-6-1-介绍" class="headerlink" title="3.6.1 介绍"></a>3.6.1 介绍</h4><p>Z Garbage Collector，ZGC 是最新的垃圾收集器，采用标记-整理算法，其目标是在对吞吐量影响不大的前提，对于任意堆大小实现停顿时间在 10 ms 以内。官方的定义为可伸缩的低延迟收集器。</p><p><img src="zgc的目标.png" alt="alt"></p><blockquote><p>ZGC 刚发布时仅支持在 64 bit Linux 下使用，java 14 提供了对 Windows 和 macOS 的支持。下文将以 Linux 上的 ZGC 进行介绍。</p></blockquote><p>与 G1 类似，ZGC 将堆分为小型 Region（4MB）、中型 Region（32MB）、大型 Region。</p><h4 id="3-6-2-染色指针和读屏障"><a href="#3-6-2-染色指针和读屏障" class="headerlink" title="3.6.2 染色指针和读屏障"></a>3.6.2 染色指针和读屏障</h4><p>ZGC 的关键在于虽然使用了标记-复制算法，但是移动对象的过程不需要 STW，即并发转移。</p><p>ZGC 通过着色指针和读屏障技术实现并发转移。并发转移过程中 GC 线程在转移对象的时候，应用线程也在不停地访问对象。假设对象发生转移，但对象地址未及时更新，那么应用线程可能访问到旧地址，从而造成错误。在 ZGC 中，应用线程访问对象将触发读屏障，如果对象被移动了，读屏障将会把读出来的指针更新到对象的新地址上。应用线程始终访问的都是对象的新地址，而不需要 STW 来让 GC 和应用之间同步。</p><h5 id="染色指针"><a href="#染色指针" class="headerlink" title="染色指针"></a>染色指针</h5><p>ZGC 的一大特点是使用了染色指针，相比于 G1 使用额外的空间记录三色标记，ZGC 直接将其记录在堆中对象的指针上。Linux 中 64 bit 的指针只使用了低 46 位，而 ZGC 将 46 位中的高 4 位用于标记，可见 ZGC 只能够管理 4 TB 堆空间，其中高 4 位的使用如下图所示。</p><p><img src="染色指针.png" alt="alt"></p><p>由上面分布可知，虚拟地址 [0，4TB）、[4，8TB）、[8，12TB）、[16，20TB）分别对应 Java 程序的虚拟地址、Marked0、Marked1、Remapped 视图。当程序对象时，在堆中申请一个虚拟地址，该地址不会映射到物理地址，而是为该对象在 Marked0、Marked1、Remapped 分别申请一个虚拟地址，并且映射到同一块内存，效果如下图所示。三个视图的切换在下文介绍。</p><p><img src="内存映射.png" alt="alt"></p><h5 id="读屏障"><a href="#读屏障" class="headerlink" title="读屏障"></a>读屏障</h5><p>读屏障是JVM向应用代码插入一小段代码的技术。当应用线程从堆中读取对象引用时，就会执行这段代码。</p><p>读屏障用于在对象标记和移动对象过程中，用于确定对象的引用地址是否满足条件，并作出相应动作。</p><p><img src="读屏障.png" alt="alt"></p><h4 id="3-6-3-地址视图切换"><a href="#3-6-3-地址视图切换" class="headerlink" title="3.6.3 地址视图切换"></a>3.6.3 地址视图切换</h4><p>ZGC 的回收周期如下图所示，其中只有 初始阶段、再标记、初始转移是 STW 的。</p><p><img src="zgc周期.png" alt="alt"></p><p>在一个周期中的地址视图切换（更新指针）过程如下：</p><ul><li>初始化：整个地址空间被设置为 Remapped，满足 GC 条件后进入标记阶段；</li><li>并发标记：如果对象被标记线程或者用户线程访问过（即被引用），则从 Remapped 改为 Marked0。标记结束后，如果对象地址是 Marked0 视图，则该对象存活，为 Remapped 则该对象是不活跃的，内存可以被回收；</li><li>并发转移：标记结束后就进入转移阶段，此阶段如果对象被转移，则从 Marked0 改为Remapped。</li></ul><p>上述过程仿佛只用到了 Marked0，那么 Marked1 在何处使用呢？Marked0 和 Marked1 主要用于区分前一次标记和当前标记，第二次进入并发标记阶段后，地址视图将改为 Marked1。对象 0 所在的页面要被回收，需要转移，对象 2 所在的页面不用被回收，不需要转移。对象 0 转移过后它的视图改为 Remapped，对象 2 仍为 Marked0。那么下一次垃圾回收标记阶段开始的时候，存在两种地址视图，Remapped 和 Marked0，如果本次标记仍然使用 Marked0 这个地址视图，那么就不能区分出对象是活跃的，还是上一次标记过的。所以新标记阶段使用了另外一个地址视图 Marked1，标记结束后所有活跃对象的地址视图都为 Marked1。</p><blockquote><p>具体算法实现可见 《新一代垃圾回收器ZGC设计与实现》第 4 章。</p></blockquote><p><img src="视图转变.png" alt="alt"></p><p>此时三个视图代表的含义为：</p><ul><li>Marked1：本次 GC 识别的活跃对象。</li><li>Marked0：前一次垃圾回收的标记阶段被标记过的活跃对象，对象在转移阶段未被转移，但是在本次垃圾回收中被识别为不活跃对象。</li><li>Remapped：前一次垃圾回收的转移阶段发生转移的对象或者是被应用程序线程访问的对象，但是在本次垃圾回收中被识别为不活跃对象。</li></ul><h2 id="4-总结图"><a href="#4-总结图" class="headerlink" title="4. 总结图"></a>4. 总结图</h2><p><img src="总结.png" alt="alt"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/26821357/">垃圾回收的算法与实现</a></li><li><a href="https://www.zhihu.com/question/41922036">Major GC和Full GC的区别是什么？ RednaxelaFX的回答</a></li><li><a href="https://www.iteye.com/blog/rednaxelafx-362738">RednaxelaFX的博客</a></li><li><a href="https://hllvm-group.iteye.com/group/topic/44381#post-272188">G1 GC的讨论</a></li><li><a href="https://openjdk.java.net/jeps/365">JEP 365</a></li><li><a href="https://tech.meituan.com/2020/08/06/new-zgc-practice-in-meituan.html">美团团队 新一代垃圾回收器ZGC的探索与实践</a></li><li><a href="https://book.douban.com/subject/34812818/">新一代垃圾回收器ZGC设计与实现</a></li><li><a href="https://www.youtube.com/watch?v=88E86quLmQA&amp;t=1663s">ZGC: The Next Generation Low-Latency Garbage Collector</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(2) 类加载</title>
      <link href="/2022/02/09/JVM%E7%B3%BB%E5%88%97(2)%20%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
      <url>/2022/02/09/JVM%E7%B3%BB%E5%88%97(2)%20%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="1-类加载过程"><a href="#1-类加载过程" class="headerlink" title="1. 类加载过程"></a>1. 类加载过程</h2><p>在程序运行期间，JVM 把描述类的数据从 class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成被虚拟机直接使用的类型，这个过程被称为虚拟机的类加载机制。</p><p>一个类型从被加载开始，到被卸载出内存为止，其生命周期会经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、准备、解析三个过程合称为连接，如下图所示。</p><p><img src="生命周期.png" alt="alt"></p><p>类加载包含上述加载、连接和初始化三个阶段，下面将逐个进行介绍。</p><h3 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h3><p>加载是使用类的全限定名<strong>读取该类的二进制流</strong>，将其转换为<strong>某种特定的数据结构</strong>存储在<strong>方法区</strong>，并在<strong>堆</strong>中生成一个供用户调用的 <strong>java.lang.Class</strong> 类型的对象的过程。</p><p>上面加粗的部分为加载的关键点：</p><ul><li>类的二进制流不限定本地的 class 文件，可以来源于网络；</li><li>在方法区的数据结构即为 klass 对象；</li><li>堆中的 java.lang.Class 类型的对象是方法区的访问入口。</li></ul><h3 id="1-2-验证"><a href="#1-2-验证" class="headerlink" title="1.2 验证"></a>1.2 验证</h3><p>验证是连接阶段的第一步，目的是保证字节流中的信息符合虚拟机规范的约束，大致上会分为以下阶段，并 <strong>分散在各个阶段</strong> ：</p><ul><li>文件格式验证：验证字节流是否符合 class 文件的格式，例如魔数、版本号等，文件格式验证发生在加载阶段获取字节流之后，验证通过才能完成加载；</li><li>元数据验证、字节码验证：验证字节流来确定程序语意正确性，并且不会危害虚拟机；</li><li>符号引用验证：检验该类是否缺少或者禁止访问它依赖的某些外部类、方法和字段等资源，主要目的是确保解析的正常执行，发生在解析阶段内。</li></ul><h3 id="1-3-准备"><a href="#1-3-准备" class="headerlink" title="1.3 准备"></a>1.3 准备</h3><p>准备为类中的 <strong>静态变量</strong> 分配内存并设置初值，例如下面的静态变量，在准备阶段后 value 的值为 0，flag 的值为 false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> bool flag = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>但如果虚拟机判断为常量，则会给赋予常量值，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>; <span class="comment">// 准备阶段后值为123</span></span><br></pre></td></tr></table></figure><h3 id="1-4-解析"><a href="#1-4-解析" class="headerlink" title="1.4 解析"></a>1.4 解析</h3><p>解析将 class 文件中与内存分布无关的符号引用（常量池的索引）转化为直接引用（内存地址）。解析在类加载中的顺序规范中没有明确规定，可以由虚拟机自行实现。</p><p>例如类 A 引用了类 B，在编译时，A 是无法得知 B 的地址的，故只能采用符号引用存储。当程序运行时触发 A 的类加载时，在解析阶段会发现 B 未被加载，将触发 B 的类加载，将类 B 加载到虚拟机中，此时就可以利用类 B 的实际地址来替换符号引用了。</p><p>但事情并没有这么简单，当 B 是个具体实现类时，会按照上述的过程执行，称为静态解析。如果 B 是个抽象类或者接口，当 B 有多个实现类例如 C、D、E，此时 A 无法明确具体实现类，将等到发生调用时，根据栈中的具体类型信息将符号引用替换为具体实现类的地址，这被称为动态解析。</p><p><img src="静态解析和动态解析.png" alt="alt"></p><h3 id="1-5-初始化"><a href="#1-5-初始化" class="headerlink" title="1.5 初始化"></a>1.5 初始化</h3><p>执行类中的主动资源初始化动作，例如成员变量的赋值、静态变量的赋值、静态代码块等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class Test &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        b = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下图为类加载的流程，实线代表类加载的实际流程，虚线表示属于关系。</p><p><img src="类加载流程.png" alt="alt"></p><h2 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h2><h3 id="2-1-类与类加载器"><a href="#2-1-类与类加载器" class="headerlink" title="2.1 类与类加载器"></a>2.1 类与类加载器</h3><p>加载过程中根据类限定名获得字节流的动作放到虚拟机外，由应用程序自行决定如何获取类，实现这个动作的代码被称为类加载器。</p><p>一个类由加载它的类加载器和类自身确定在虚拟机中的唯一性，每个类加载器都有自己的命名空间。换句话说，两个类相同的条件是，其 class 文件相同，并且被同一个类加载器加载。</p><h4 id="2-2-双亲委派模型"><a href="#2-2-双亲委派模型" class="headerlink" title="2.2 双亲委派模型"></a>2.2 双亲委派模型</h4><p>对于 jdk 1.8 及以前的版本，绝大多数 Java 程序会使用下列 3 个系统提供的类加载器：</p><ul><li>Bootstrap Class Loader：启动类加载器，使用 C++ 实现，是虚拟机的一部分。负责加载 rt.jar 等 jdk 库；</li><li>Extension Class Loader：拓展类加载器，负责加载 <JAVA_HOME>\lib\ext 目录下的类；</li><li>Application Class Loader：应用程序/系统类加载器，负责加载用户实现的类。</li></ul><blockquote><p>说明：虚拟机规范对类加载器只分为启动类加载器和非启动类加载器，上述分类是 hotspot 的实现。</p></blockquote><p>除了上面 3 个类加载器，用户可以加入自定义的类加载器进行拓展。</p><p><img src="双亲委派模型.png" alt="alt"></p><p>上图各种类加载器的层次关系被称为 双亲委派模型（Parents Delegation Model），在 jdk 1.2 引入。其工作流程分为向上委托和向下委派，类加载器收到加载请求时，向上委托给父加载器加载，当父加载器无法完成加载，向下委派给子加载器尝试加载。</p><p>双亲委派模型的优点是例如 java.lang.Object 等核心类，无论被哪个类加载器加载，最终都会委派给启动类加载器，用于保证保证 Java 程序的正确运行。用户即使自定义了一个 java.lang.Object 类，对程序也无法造成影响。同时，类加载器都会向上委托加载，也避免了类的重复加载问题。</p><p>双亲委派的逻辑位于 java.lang.ClassLoader 的 loadClass 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 检查类是否被加载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// parent = null 即为启动类加载器</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// 抛出异常则上层加载器无法完成加载，c = null</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 调用自身的类加载机器</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类加载器之间所谓的父子关系不是通过继承获得，更像是通过优先级决定，上层的类加载拥有更高的优先级，优先进行加载。双亲委派的双亲是翻译问题，从实际体现上来看，称为 父辈委派模型 更为直观贴切。</p></blockquote><h3 id="2-3-破坏双亲委派模型"><a href="#2-3-破坏双亲委派模型" class="headerlink" title="2.3 破坏双亲委派模型"></a>2.3 破坏双亲委派模型</h3><p>在 Java 历史上，主要有 3 次对双亲委派模型的破坏。</p><p>第一次是为了兼容性，由于双亲委派模型在 jdk 1.2 后才引入，之前版本已经存在大量自定义类加载器。这些类加载器通过重写 loadClass 方法实现自己的加载逻辑，双亲委派的逻辑都在 loadClass 方法中，所以不会遵守后来版本才出现的 “规范”。对于 Java 团队做出了一定妥协，在 java.lang.ClassLoader 中添加 findClass 方法，并推荐用户重写该方法来实现类加载逻辑。</p><p><img src="第一次破坏双亲委派.png" alt="alt"></p><p>第二次是由于双亲委派的缺陷，一个典型例子是数据库的 Driver 接口，该接口定义在 jdk 源码中（rt.jar）由启动类加载器加载，但接口由数据库厂商实现， 实现类存放在 classpath 目录下，由系统类加载器加载，启动类加载器无法加载这些类，无法加载驱动。为此引入了线程上下文加载器，一般情况下就是系统类加载器，Driver 服务通过线程类加载器去加载类，这是一种父类加载器委托子类加载器的行为，违背了双亲委派模型。</p><p><img src="第二次破坏双亲委派.png" alt="alt"></p><p>第三次是用户对热替换、热部署的追求，限于篇幅在此处不进行介绍。</p><p>从上文，我们也知道了在 jdk 1.8 中破坏双亲委派的手段：</p><ul><li>自定义类加载器，重写 loadClass 方法，不进行双亲委派机制</li><li>使用线程上下文加载器</li></ul><blockquote><p>除非有特殊的业务需求，否则不推荐破坏双亲委派模型。</p></blockquote><h2 id="3-总结图"><a href="#3-总结图" class="headerlink" title="3. 总结图"></a>3. 总结图</h2><p><img src="总结.png" alt="alt"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></p></li><li><p><a href="https://book.douban.com/subject/26418340/">Java虚拟机规范(JavaSE 8版)</a></p></li><li><p><a href="https://www.bilibili.com/video/BV14U4y1L75q?spm_id_from=333.999.0.0">Java类加载机制这块算是玩明白了</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1X5411K7cw?spm_id_from=333.999.0.0">Java双亲委派、类加载器这块算是玩明白了</a></p></li><li><p><a href="https://www.bilibili.com/video/BV1RP4y1E7pA?spm_id_from=333.999.0.0">JVM第一弹</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM系列(1) Java内存区域</title>
      <link href="/2022/02/09/JVM%E7%B3%BB%E5%88%97(1)%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2022/02/09/JVM%E7%B3%BB%E5%88%97(1)%20Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-JVM简介"><a href="#1-JVM简介" class="headerlink" title="1. JVM简介"></a>1. JVM简介</h2><p>Java Virutal Machine，JVM，Java 虚拟机，是用于执行字节码的虚拟计算机。</p><p>JVM 是 Java 平台的基石，是实现硬件无关和平台无关的关键部分，是字节码的运行平台。它与 Java 语言没有必然联系，只与特定的 class 文件格式所关联，并且遵守自己的虚拟机规范。</p><p>目前最主流的虚拟机是 Oracle 的 hotspot。</p><h2 id="2-Java内存区域"><a href="#2-Java内存区域" class="headerlink" title="2. Java内存区域"></a>2. Java内存区域</h2><h3 id="2-1-运行时数据区"><a href="#2-1-运行时数据区" class="headerlink" title="2.1 运行时数据区"></a>2.1 运行时数据区</h3><p>JVM 规范定义了若干程序运行期间会使用到的运行数据区，如下图所示。</p><p><img src="运行时数据区.png" alt="alt"></p><p>运行时数据区：</p><ul><li>程序计数器：线程私有，记录线程执行上下文。程序的分支、异常处理、线程切换等工作依赖这个计数器完成；</li><li>Java 虚拟机栈：线程私有，生命周期和线程相同。每个方法执行时，都会栈中创建一个栈帧，用于存储局部变量、方法调用等，方法调用结束则回收栈帧。如果栈深度溢出抛出 StackOverflowError，无法申请到足够内存则抛出 OutOfMemoryError；</li><li>本地方法栈：线程私有，与虚拟机栈类似，但用于本地方法调用，同样也会抛出 StackOverflowError 和 OutOfMemoryError；</li><li>堆：线程共享，对象分配内存的区域，溢出抛出 OutOfMemoryError；</li><li>方法区：线程共享，存储类元信息、常量、静态变量等，溢出抛出 OutOfMemoryError。</li></ul><p>除了运行时数据区外，JVM 还管理直接内存。直接内存不属于运行时数据区，它是 jvm 所属进程的内存，即操作系统给该进程分配的堆空间，溢出抛出 OutOfMemoryError。</p><h3 id="2-2-永久代和元空间"><a href="#2-2-永久代和元空间" class="headerlink" title="2.2 永久代和元空间"></a>2.2 永久代和元空间</h3><p>方法区是虚拟机规范中所定义的内存区域，在具体的虚拟机上实现可能不同。</p><p>永久代是早期 hotspot 对方法区的实现，包含类元数据、字符串常量池、静态变量等，在 jdk 1.7 后字符串常量池和静态变量被移动到堆中。</p><p>永久代可以将垃圾收集自然拓展到方法区，减少了 hotspot 团队的工作量，但是存在以下问题：</p><ul><li>永久代的内存较少回收，并且和老年代关联垃圾回收，容易触发 Full GC;</li><li>永久代的概念只属于 hotspot，对合并 hotspot 和其他虚拟机造成阻碍。 </li></ul><p>对于永久代的问题，在 jdk 1.8 后，hotspot 团队放弃了永久代，而是采用元空间来代替永久代，元空间存放在直接内存中，更不易出现 OutOfMemoryError。</p><h2 id="3-对象存储"><a href="#3-对象存储" class="headerlink" title="3. 对象存储"></a>3. 对象存储</h2><h3 id="3-1-对象访问"><a href="#3-1-对象访问" class="headerlink" title="3.1 对象访问"></a>3.1 对象访问</h3><p>对于堆中的对象，虚拟机主要有两种访问方式：</p><ul><li><p>句柄访问：堆中划分出句柄池，引用存储对象的句柄，句柄包含对象实例数据指针和类型数据指针。优点是对象移动时只需要改变句柄的实例数据指针。</p><p><img src="句柄访问.png" alt="alt"></p></li><li><p>直接指针访问：引用直接存储对象地址，在堆中的对象实例中存储了实例数据和指向类型的指针，优点是少一次指针定位。</p><p><img src="句柄访问.png" alt="alt"></p></li></ul><p>hotspot 采用直接指针访问的方式。</p><h3 id="3-2-内存分布"><a href="#3-2-内存分布" class="headerlink" title="3.2 内存分布"></a>3.2 内存分布</h3><p>在 hotspot 虚拟机中，对象在堆内存中的内存分布可以划分为 3 个部分：</p><ul><li><p>对象头，主要包含：</p><ul><li><p>Mark Word：记录对象自身的运行时数据，64 位虚拟机的 Mark Word 内容如下图所示。</p><p><img src="markword.png" alt="alt"></p></li><li><p>类型指针：指向类元数据的指针，JVM 通过指针定位方法区中的 klass 对象。</p></li></ul></li><li><p>实例数据：存储对象的属性内容，即各种类型字段的值；</p></li><li><p>对齐填充：hotspot 虚拟机要求对象大小是 8 字节的整数倍。</p></li></ul><p>hotspot 基于 oop-klass 模型来描述一个对象，oop 指普通对象指针 ordinary object pointer，指向类实例数据的内存地址；klass 是方法区中类元信息的运行时数据结构，记录了类的继承信息、成员方法、构造函数等，日常开发使用的 Class 对象可以理解为指向方法区 klass 对象的指针。</p><blockquote><p>对 oop-klass 的具体分析可见《揭秘Java虚拟机》第 5 章。</p></blockquote><p>以下代码的 oop-klass 模型如图所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Model</span><span class="params">(<span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">10</span>;</span><br><span class="line">    Model modelA = <span class="keyword">new</span> Model(<span class="number">2</span>);</span><br><span class="line">    Model modelB = <span class="keyword">new</span> Model(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="oop-klass.png" alt="alt"></p><blockquote><p>此图存在一定问题，在 jdk 1.7 之后，静态变量被移动到堆中，故图中的 a 变量应该位于堆而不是方法区。</p></blockquote><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>上文主要介绍了虚拟机的内存是如何划分的，以及相应区域溢出时会产生的异常。除此之外，还介绍了对象在堆中的内存分布和访问手段。本文的思维导图如下：</p><p><img src="总结.png" alt="alt"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/26418340/">Java虚拟机规范(JavaSE 8版)</a></li><li><a href="https://book.douban.com/subject/27086821/">揭秘Java虚拟机</a></li><li><a href="https://www.cnblogs.com/thiaoqueen/p/9314745.html">对象的创建和OOP-Klass模型</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈MySQL的索引</title>
      <link href="/2022/02/08/%E6%B5%85%E8%B0%88MySQL%E7%9A%84%E7%B4%A2%E5%BC%95/"/>
      <url>/2022/02/08/%E6%B5%85%E8%B0%88MySQL%E7%9A%84%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-B-树"><a href="#1-B-树" class="headerlink" title="1. B+树"></a>1. B+树</h2><p>关系型数据库的表类似 Excel，但与表格不同的时，它还提供了索引、事务等额外的机制，其中索引是数据库的一个关键点。</p><p>索引是为了提高查询速度而出现的，查询主要有等值查询和范围查询。直观的一个想法使用哈希表实现索引，哈希表可以实现 O(1) 查找复杂度，但是对于范围查询，哈希表需要遍历所有数据。</p><p>另一个想法是使用有序数组，通过二分查找的方式，等值查询和范围查询都能在 O(logn) 复杂度下完成。但是一个问题也紧接而来，当在表中插入数据时，有序数组需要进行 O(n) 复杂度的元素移动，显然不适合实现索引。</p><p>于是我们想到另一个综合了查询和修改功能的数据结构，二叉搜索树，它可以在 O(logn) 复杂度下完成查询和修改操作，看起来已经十分完美。但这仍有一个问题，二叉搜索树在内存这表现优异，那在磁盘中呢？磁盘的 IO 次数直接由树的高度决定，而表中存有几万甚至几十万的数据是一件常事，每次查询都需要经过多次 IO，依旧十分耗时。</p><p>说了这么多，终于引出我们的主角，B+ 树。B+ 树可以看成一个多叉搜索树，其中每个节点都是有序的，并且只有叶节点存储数据，非叶节点进行不存储，非叶节点能够存放大量索引，大幅度降低树的高度。除此之外，叶节点连接形成有序链表，可以实现范围查询。</p><p><img src="b+树.png" alt="alt"></p><h3 id="2-MySQL中的索引"><a href="#2-MySQL中的索引" class="headerlink" title="2. MySQL中的索引"></a>2. MySQL中的索引</h3><h3 id="2-1-索引类型"><a href="#2-1-索引类型" class="headerlink" title="2.1 索引类型"></a>2.1 索引类型</h3><h4 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h4><p>根据底层数据结构实现，MySQL 提供了 4 种索引类型：</p><ul><li>BTREE 索引：最常见的索引类型，大部分引擎都支持该索引</li><li>HASH 索引：查找速度快，但只有 Memory 引擎支持，无法用于排序</li><li>Full-text 索引：全文索引，是 MyISAM 的一个特殊索引类型，主要用于大本文搜索， InnoDB 在 MySQL 5.6 后支持</li><li>R-tree 索引：又称空间索引，主要用于地理空间数据，使用较少</li></ul><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引根据值能否重复可以分为：</p><ul><li><p>非唯一索引：索引的值可以重复</p></li><li><p>唯一索引：索引的值必须唯一，但可以存在多个 null，可以通过以下方式创建。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX key_name ON table_name(col_name);</span><br></pre></td></tr></table></figure></li></ul><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>索引根据包含列的数量又可分为：</p><ul><li>单值索引：一个索引只包含一个列</li><li>联合索引：将多个列联合，并根据列出现的顺序排序。例如索引 (a，b，c)，会先 a 进行排序，a 相同的情况再根据 b 排序，最后根据 c 排序。</li></ul><h3 id="2-2-聚簇索引"><a href="#2-2-聚簇索引" class="headerlink" title="2.2 聚簇索引"></a>2.2 聚簇索引</h3><h4 id="2-2-1-介绍"><a href="#2-2-1-介绍" class="headerlink" title="2.2.1 介绍"></a>2.2.1 介绍</h4><p>聚簇索引是 InnoDB 的一个特点，聚簇索引会将数据存放在叶子节点，并且一个表只能有一个聚簇索引，通常为主键。其他的索引称为二级索引，二级索引会在叶节点存储自身和主键。</p><p>通过主键查询数据时，访问到索引叶节点即可获取数据；而通过二级索引查询数据，访问到索引叶节点只能拿到主键，需要利用主键和聚簇索引再进行查找，这一过程称为回表。</p><p>用户可以自定义一个聚簇索引，未指定的话 InnoDB 会将主键列为聚簇索引，不存在主键则定义一个隐式自增主键 row_id。 </p><h4 id="2-2-2-聚簇索引的优缺点"><a href="#2-2-2-聚簇索引的优缺点" class="headerlink" title="2.2.2 聚簇索引的优缺点"></a>2.2.2 聚簇索引的优缺点</h4><p>优点：</p><ul><li>叶节点直接存储数据，磁盘 I/O 少</li></ul><p>缺点：</p><ul><li>更新和非顺序插入数据可能导致页分裂，效率低</li><li>降低了二级索引的查询效率</li></ul><h2 id="3-使用索引"><a href="#3-使用索引" class="headerlink" title="3. 使用索引"></a>3. 使用索引</h2><h3 id="3-1-索引失效"><a href="#3-1-索引失效" class="headerlink" title="3.1 索引失效"></a>3.1 索引失效</h3><p>下列场景将导致索引失效：</p><ul><li><p>最左匹配原则：使用联合索引查询，依次根据索引的列顺序查询，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 联合索引为 (name, email, address)</span><br><span class="line"></span><br><span class="line"># 索引生效</span><br><span class="line">select * from user where name = &#x27;bzzb&#x27; and email = &#x27;xx@qq.com&#x27;</span><br><span class="line"># 只用了name索引</span><br><span class="line">select * from user where name = &#x27;bzzb&#x27; and address = &#x27;xx&#x27;</span><br><span class="line"># 索引失效</span><br><span class="line">select * from user where email = &#x27;xx@qq.com&#x27; and address = &#x27;xx&#x27;</span><br></pre></td></tr></table></figure></li><li><p>OR 连接的所有字段没有都含有索引，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 索引为 (name, email, address)</span><br><span class="line"></span><br><span class="line"># nickname不含索引, 索引失效</span><br><span class="line">select * from user where name = &#x27;bzzb&#x27; or nickname = &#x27;zhibin&#x27;</span><br></pre></td></tr></table></figure></li><li><p>模糊匹配 LIKE 中的字符串以 % 开始，因为会匹配所有字符，将导致索引失效；</p></li><li><p>使用不等于（!= 和 &lt;&gt;）只能全表扫描，无法使用索引；</p></li><li><p>存在字符串隐式转换将导致索引失效，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 索引为 (name, email, address)</span><br><span class="line"># 需要将2000转换为字符串&quot;2000&quot;，索引失效</span><br><span class="line">select * from user where name = 2000</span><br></pre></td></tr></table></figure></li><li><p>在索引在的列上进行运算，将导致索引失效。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 索引为 (name, email, address)</span><br><span class="line"></span><br><span class="line"># 使用了字符串运算，索引失效</span><br><span class="line">select * from user where left(name, 2) = &quot;bz&quot; </span><br></pre></td></tr></table></figure></li></ul><blockquote><p>即使不符合上述的情况，MySQL 的优化器也会根据情况不使用索引，而是进行全表扫描。查询语句是否使用到索引可以使用 explain 查看。</p></blockquote><h3 id="3-2-索引使用建议"><a href="#3-2-索引使用建议" class="headerlink" title="3.2 索引使用建议"></a>3.2 索引使用建议</h3><p>除了避免索引失效，还有以下索引使用建议：</p><ul><li><p>主键设置为自增类型，提高数据插入的效率；</p></li><li><p>对于常用的查询，考虑使用覆盖查询减少回表；</p></li><li>索引列的类型尽量小，类型越小，占用的存储空间更小，单页能放下索引的数目更高；</li><li>只为用于搜索、排序或分组的列创建索引，引入索引虽然提高了查询性能，但也影响数据插入和删除的性能；</li><li>取值较少的列不建议单独建立索引，例如性别，虽然存在根据性别查询的场景，但 MySQL 优化器大概率会进行全表扫描。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/book/6844733769996304392/section/6844733770046636045">MySQL是怎样运行的</a></li><li><a href="https://time.geekbang.org/column/intro/100020801">MySQL实战45讲</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL中的锁</title>
      <link href="/2022/02/08/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2022/02/08/MySQL%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>上篇博客 <a href="https://strokebun.github.io/2022/02/08/MySQL的事务隔离级别和MVCC/">MySQL的事务隔离级别和MVCC</a> 介绍了 MySQL 如何使用 MVCC 解决读写冲突，实现并发事务读取数据。那么对于并发修改，MySQL 又采用了什么机制呢？</p><p>MySQL 使用锁来解决并发修改问题，锁结构包含很多信息，其中最主要的有：</p><ul><li>事务信息：记录这个锁由哪个事务生成</li><li>is_waiting：事务是否在等待，值为 false 则该事务获得了锁</li></ul><p>如下图所示，事务 T1 获取到锁，继续执行，而 T2 未得到锁，则进行等待。</p><p><img src="锁结构.png" alt="alt"></p><p>当事务 T1 提交之后，会将生成的锁释放，同时检查是否有其他在等待，此时发现事务 T2，将 T2 的锁结构中 is_waiting 属性设置为 false，T2 获得锁继续执行。</p><p>上一篇博客提到，利用 MVCC 读取数据称为一致性锁，相对应的，采用锁读取和更新称为锁定读或者当前读，可以通过以下方式开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">INSERT, UPDATE, DELETE # 修改操作</span><br><span class="line">SELECT ... LOCK IN SHARE MODE # 对读取的记录加S锁</span><br><span class="line">SELECT ... LOCK FOR UPDATE # 对读取的记录加X锁</span><br></pre></td></tr></table></figure><h2 id="2-锁分类"><a href="#2-锁分类" class="headerlink" title="2. 锁分类"></a>2. 锁分类</h2><h3 id="2-1-共享和排他锁"><a href="#2-1-共享和排他锁" class="headerlink" title="2.1 共享和排他锁"></a>2.1 共享和排他锁</h3><p>MySQL 中的锁按照性质可以分为：</p><ul><li>共享锁：Shared Locks，简称 S 锁，S 锁与 S 锁兼容，即一个事务获得 S 锁后不释放，其他事务也可获得 S 锁；</li><li>独占锁：Exclusive Locks，简称 X 锁，X 锁与 X 锁、S 锁都不兼容。也就是说，一个事务获得 X 锁之后，其他事务无法获得 S 锁获得 X锁；一个事务获得 S 锁后，其他事务也无法获得 X 锁。</li></ul><h3 id="2-2-多粒度锁"><a href="#2-2-多粒度锁" class="headerlink" title="2.2 多粒度锁"></a>2.2 多粒度锁</h3><p>MySQL 为了提高并发程度，提出了多粒度锁，分为全局锁、表锁和行锁。</p><h4 id="2-2-1-全局读锁"><a href="#2-2-1-全局读锁" class="headerlink" title="2.2.1 全局读锁"></a>2.2.1 全局读锁</h4><p>全局锁即对整个数据库加锁，MySQL 提供了一个加全局读锁的命令，即 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flush tables with read lock</span><br></pre></td></tr></table></figure><p>整个库将处于只读状态，典型使用场景是做全库备份。</p><h4 id="2-2-2-表级锁"><a href="#2-2-2-表级锁" class="headerlink" title="2.2.2 表级锁"></a>2.2.2 表级锁</h4><p>MySQL 表级锁以下类型：</p><ul><li><p>表锁：对整个表添加 S 锁或者 X 锁，开启方式是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lock tables ... read # 添加表级S锁</span><br><span class="line">lock tables ... write # 添加表级X锁</span><br></pre></td></tr></table></figure></li><li><p>元数据锁：metadata lock，MDL，用于保证读写的正确性，会默认添加。增删改查时会加 MDL 读锁，修改表结构（添加/删除列、添加索引等）时会加 MDL 写锁，保证在表结构修改时进行数据读写的正确性；</p></li><li><p>AUTO-INC 锁：在某列添加 AUTO_INCREMENT 属性之后，执行插入语句时会在表级别添加该锁</p></li></ul><blockquote><p>对于 MyISAM、MEMORY 等存储引擎而言，只支持表级锁。</p></blockquote><h2 id="3-行锁"><a href="#3-行锁" class="headerlink" title="3. 行锁"></a>3. 行锁</h2><p>本文最重点的部分是行锁。行锁也称记录锁，顾名思义加在某行记录上的锁，InnoDB 由于支持行锁和事务，成为最常被使用的存储引擎。</p><h3 id="3-1-两阶段协议"><a href="#3-1-两阶段协议" class="headerlink" title="3.1 两阶段协议"></a>3.1 两阶段协议</h3><p>MySQL 是怎么管理锁的呢？这就需要提到两阶段协议，例如下图的操作，事务 B 的 update 操作会阻塞，直到事务 A 提交之后才继续执行。</p><p><img src="两阶段协议.png" alt="alt"></p><p>两阶段锁协议指的是，InnoDB 事务中行锁是在需要的时候才加上，但不是立马释放，并且等到事务结束释放所有的锁。根据这个协议，当我们的事务需要锁多个行时，要尽量把会导致锁冲突的操作往后放。</p><h3 id="3-2-行锁类型"><a href="#3-2-行锁类型" class="headerlink" title="3.2 行锁类型"></a>3.2 行锁类型</h3><p>在解释各种行锁之前，先定义数据库含有以下数据。</p><p><img src="数据.png" alt="alt"></p><p>常见的行锁类型有：</p><ul><li><p>Record Locks：分为 S 锁和 X 锁，仅锁住一条记录，示意图如下：</p><p><img src="record_lock.png" alt="alt"></p></li><li><p>Gap Locks：间隙锁，在 Repeatalbe Read 级别下生效，锁定该行记录与之前记录的间隙，用来解决幻读问题。</p><p><img src="gap_lock.png" alt="alt"></p><p>给 number 为 8 的行加了间隙锁后，则其它事务无法在 (3，8) 这个区间插入新记录。</p></li><li><p>Next-Key Locks：Record Locks + Gap Locks，既锁出该行，也锁住间隙，是前开后闭区间；</p></li><li><p>Insert Intetion Locks：插入意向锁，当一个事务想插入数据的位置被加了 Gap Locks 时，需要在内存中生成一个锁结构，表明想在某个间隙插入新记录，但是现在在等待。</p></li></ul><blockquote><p>间隙锁的引入，虽然解决了幻读问题，但同时也降低了并发度。为了提高并发度可以选择将隔离级别改为 Read Commited，同时将 binlog 格式设置为 row 解决数据和日志不一致的问题。</p></blockquote><h3 id="3-3-加锁规则"><a href="#3-3-加锁规则" class="headerlink" title="3.3 加锁规则"></a>3.3 加锁规则</h3><p>上文介绍了各种行锁，那么 MySQL 是根据什么规则加锁的呢？</p><p>其加锁规则如下：</p><ul><li>原则 1：加锁的基本规则是 Next-Key Lock；</li><li>原则 2：查找过程中访问到的数据才会加锁；</li><li>优化 1：索引上的等值查询，给唯一索引加锁时，改为行锁 Record Lock；</li><li>优化 2：索引上的等值查询，向右遍历且最后一个不满足等值条件时，改为 Gap Lock；</li><li>一个例外：唯一索引的范围查询会访问到第一个不满足条件的值；</li></ul><p>假设有以下数据：</p><div class="table-container"><table><thead><tr><th style="text-align:center">id(primar  key)</th><th style="text-align:center">c (key)</th><th style="text-align:center">d</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">5</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">10</td><td style="text-align:center">10</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">15</td><td style="text-align:center">15</td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">20</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">25</td><td style="text-align:center">25</td></tr></tbody></table></div><h4 id="案例1：等值查询间隙锁"><a href="#案例1：等值查询间隙锁" class="headerlink" title="案例1：等值查询间隙锁"></a>案例1：等值查询间隙锁</h4><p><img src="案例1.png" alt="alt"></p><p>根据加锁规则判断：</p><ul><li>根据原则 1，会给 (5，10] 加上 Next-Key Lock；</li><li>根据优化 2：表中不存在 id = 7 的数据，向右遍历到最后一个不满足等值条件的数据 id = 10，改为 Gap Lock，所以会给  (5，10）添加 Gap Lock。</li></ul><p>根据上述分析，由于间隙锁事务 B 会阻塞直到 A 释放，而事务 C 不影响执行。</p><h4 id="案例2：-非唯一索引等值锁"><a href="#案例2：-非唯一索引等值锁" class="headerlink" title="案例2： 非唯一索引等值锁"></a>案例2： 非唯一索引等值锁</h4><p><img src="案例2.png" alt="alt"></p><ul><li>根据原则 1， 给 (0，5] 添加 Next-Key Lock；</li><li>由于 c 是普通索引，故根据优化 2，需要向右遍历直到 c = 10，因此需要给 (5，10) 加 Gap Lock；</li><li>根据原则 2，访问到的数据才会加锁，这个查询不访问主键索引，故主键索引没有锁。</li></ul><p>根据上述分析，事务 A 的锁不影响事务 B 执行，事务 C 需要插入 (7，7，7)，将会被事务 A 的间隙锁 (5，10) 锁住。</p><p>其余分析可见 <a href="https://time.geekbang.org/column/article/75659">为什么我只改一行语句，锁这么多</a>。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/book/6844733769996304392/section/6844733770071801864">MySQL是怎样运行的：锁</a></li><li><a href="https://time.geekbang.org/column/article/69862">MySQL实战45讲</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL的事务隔离级别和MVCC</title>
      <link href="/2022/02/08/MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8CMVCC/"/>
      <url>/2022/02/08/MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8CMVCC/</url>
      
        <content type="html"><![CDATA[<h2 id="1-事务隔离级别"><a href="#1-事务隔离级别" class="headerlink" title="1. 事务隔离级别"></a>1. 事务隔离级别</h2><p>在数据库事务中有隔离性的特性，在某个事务对数据库进行访问时，其他事务应该等待这个事务完成再能访问这个数据。但这样的处理使数据访问完全串行化，严重影响性能，故提供不同的隔离级别，用户可以结合业务需求使用。</p><h3 id="1-1-事务并发执行的问题"><a href="#1-1-事务并发执行的问题" class="headerlink" title="1.1 事务并发执行的问题"></a>1.1 事务并发执行的问题</h3><p>访问相同数据的事务在不保证串行执行的情况下可能遇到以下问题。</p><ul><li><p>脏写：一个事务修改了另一个未提交事务修改过的数据；</p></li><li><p>脏读：一个事务读到了另一个未提交事务修改过的数据；</p></li><li><p>不可重复读：一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值；</p><p><img src="不可重复读.png" alt="alt"></p><p>如上图，在事务 B 中提交了几个事务（不可重复读针对的是已提交事务，读到未提交事务的数据是脏读），修改了 number 为 1 对应的 name 值，如果事务 A 都能查到最新的值，就称为不可重复读。</p></li><li><p>幻读：一个事务先根据某些条件查询出一些记录，之后另一个事务又向表中插入了符合这些条件的记录（要求是插入，如果是删除仍为不可重复读），原先的事务再次按照该条件查询时，能把插入的记录也读出来。</p><p><img src="幻读.png" alt="alt"></p><p>事务 A 首先根据 number &gt; 0 的条件查询，得到一条结果，之后事务 B 向表中插入新数据并提交，如果事务 A 使用相同的查询，得到不只一条数据，则称为幻读。</p></li></ul><h3 id="1-2-事务隔离级别"><a href="#1-2-事务隔离级别" class="headerlink" title="1.2 事务隔离级别"></a>1.2 事务隔离级别</h3><p>上文提到的问题根据严重性排序为 脏写 &gt; 脏读 &gt; 不可重复读 &gt; 幻读，由于脏写问题过于严重，无法容忍，必须避免，而对于其他三种问题 SQL 标准设立了不同的隔离级别：</p><ul><li>Read Uncommited：读未提交。一个事务未提交时，做的变更能被其他事务看到；</li><li>Read Commited：读已提交。一个事务提交之后，做的变更才能被其他事务看到，可以解决脏读问题；</li><li>Repeatable Read：可重复读。一个事务执行过程中，看到的数据是一致的，可解决脏读、不可重复读问题；</li><li>Serializable：串行化。对于同一行记录会加锁，可解决脏读、不可重复读、幻读问题。</li></ul><blockquote><p> MySQL 支持上面 4 种隔离级别，但与标准不同的是，MySQL 使用了间隙锁，在 Repeatable Read 级别下，可以解决幻读问题。MySQL 默认使用的隔离级别是 Repeatable Read。</p></blockquote><h2 id="2-MVCC"><a href="#2-MVCC" class="headerlink" title="2. MVCC"></a>2. MVCC</h2><p>MVCC，Multi-Version Concurrency Control，多版本并发控制，在 InnoDB 存储引擎中用于提高数据库并发性能，针对于读写冲突，用非阻塞读的方式获取数据。</p><blockquote><p>MVCC 只针对普通 SELECT 生效，对于加锁的读取不生效。利用 MVCC 读取数据被称为一致性读。</p></blockquote><h3 id="2-1-版本链"><a href="#2-1-版本链" class="headerlink" title="2.1 版本链"></a>2.1 版本链</h3><p>对于 InnoDB 引擎而言，其每行包含两个隐藏列：</p><ul><li>trx_id：每次一个事务对某行进行改动时，会将该事务 id 赋值给这个隐藏列</li></ul><blockquote><p>事务 id 不是事务启动时生成的，而是当事务对行数据进行改动时生成。</p></blockquote><ul><li>roll_pointer：回滚指针，每次对某行改动时，将旧版本写入 undo log 中，并将这个列指向之前按的数据</li></ul><blockquote><p>undo log 会用来记录每次修改前的历史值，在 MySQL 中主要用于事务回滚和实现 MVCC。</p></blockquote><p>每一行的更新记录会放到一条 undo log 中，包含更新记录和事务 id，并使用 roll_pointer 形成一个链表，被称为版本链，下文将会介绍如何使用版本链实现 MVCC。</p><p><img src="版本链.png" alt="alt"></p><h3 id="2-2-ReadView"><a href="#2-2-ReadView" class="headerlink" title="2.2 ReadView"></a>2.2 ReadView</h3><p>对于 Read Uncommited 级别的事务而言，读取版本链中最新的数据即可；而对于 SERIALZABLE 级别的事务，读写时都需要进行加锁，那么对于 Read Commited 和 Repeatable Read，就需要读取版本链中特定的版本，那么 MySQL 是如何判断某个版本对于当前事务可不可见呢？</p><p>InnoDB 引入了 Consistent ReadView （下文称作 ReadView）的概念，事务执行某个阶段会生成 ReadView，ReadView 主要包括 4 个内容：</p><ul><li><p>m_ids：生成 ReadView 时当前系统未提交的事务 id 集合；</p></li><li><p>min_trx_id：m_ids 中的最小值，即未提交的事务 id 最小值；</p></li><li><p>max_trx_id：生成 ReadView 时系统应该分配给下一个事务的 id，当前系统已经创建过的事务id+1；</p><p>注：max_trx_id 不是 m_ids 的最大值</p></li><li><p>creator_trx_id：生成该 ReadView 的事务的 id。</p></li></ul><p>再结合上述版本链中每个版本的 trx_id，某个版本对于当前事务是否可见便有以下判断依据：</p><ul><li>trx_id = creator_trx_id，即当前事务在访问自己修改的数据，那么当前事务对该版本可见；</li><li>trx_id &lt; min_trx_id，即生成该版本的事务在当前 ReadView 生成前已经提交，该版本对当前事务可见；</li><li>trx_id &gt;= max_trx_id，即生成该版本的事务在当前 ReadView 生成之后才开启，该版本对当前事务不可见；</li><li>min_trx_id &lt; trx_id &lt; max_trx_id，则需要判断 trx_id 在不在 m_ids 中，在则说明创建 ReadView 时生成该版本的事务还未提交，不可以被当前事务访问，不在则可以访问。</li></ul><p>事务会顺着版本链判断可见性，找到可见的数据为止，如果最后一个版本也不可见，意味该行对该事务不可见，查询结果不含该行记录。</p><h3 id="2-3-生成ReadView的时机"><a href="#2-3-生成ReadView的时机" class="headerlink" title="2.3 生成ReadView的时机"></a>2.3 生成ReadView的时机</h3><p>根据 ReadView，我们可以判断某个版本对事务是否可见，那么 Read Commited 和 Repeatale Read 如何区分呢？关键在于生成 ReadView 的时机。</p><ul><li>Read Commited 级别下每次读取都生成 ReadView；</li><li>Repeatable Read 只在第一次读取时生成 ReadView，之后使用同一个 ReadView，对之后的修改不可见，所以能够实现可重复读。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://juejin.cn/book/6844733769996304392/section/6844733770071801870">MySQL是怎样运行的：MVCC篇</a></li><li><a href="http://mysql.taobao.org/monthly/2021/10/01/">Undo log介绍</a></li><li><a href="https://time.geekbang.org/column/article/70562">SQL实战45讲-事务隔离</a></li><li><a href="https://www.cnblogs.com/xuwc/p/13873611.html">MVCC详解</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>系统设计(1): 短域名系统</title>
      <link href="/2022/02/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1(1)%20%E7%9F%AD%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/02/07/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1(1)%20%E7%9F%AD%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>短域名 TinyURL 是一个在线服务，可以将长的 URL 转化为一个短的 URL 完成重定向。</p><p>微博/Twitter 要求推文限制在 100 多个字符，如果直接使用原始链接，将大幅度限制用户的发表字数；日常使用的二维码是根据字符生成的，长 URL 生成的二维码更加不好识别。</p><p>以上场景导致短域名系统的出现。</p><h2 id="2-分析"><a href="#2-分析" class="headerlink" title="2. 分析"></a>2. 分析</h2><h3 id="2-1-系统输入"><a href="#2-1-系统输入" class="headerlink" title="2.1 系统输入"></a>2.1 系统输入</h3><ul><li>一个冗长的域名</li><li>一个自定义的别名</li><li>一个过期时间</li></ul><h3 id="2-2-系统输出"><a href="#2-2-系统输出" class="headerlink" title="2.2 系统输出"></a>2.2 系统输出</h3><p>自定义别名或者随机生成的短域名，在过期时间到来前访问都可以被重定向到原始的冗长域名上</p><h3 id="2-3-系统要求"><a href="#2-3-系统要求" class="headerlink" title="2.3 系统要求"></a>2.3 系统要求</h3><h4 id="2-3-1-需求"><a href="#2-3-1-需求" class="headerlink" title="2.3.1 需求"></a>2.3.1 需求</h4><ul><li>过期后短域名将失效</li><li>短域名是唯一的</li><li>支持自定义短域名，并且限制规则</li></ul><h4 id="2-3-2-系统指标"><a href="#2-3-2-系统指标" class="headerlink" title="2.3.2 系统指标"></a>2.3.2 系统指标</h4><ul><li>读多写少系统，估算 1 亿用户使用<ul><li>写 QPS = 100 M * 0.1 / 86400 = 1k -&gt; 峰值 2k -&gt; 预估值 = 4k</li><li>读 QPS = 100 M * 10 / 86400 = 115k -&gt; 峰值 230k -&gt; 预估值 = 460k</li></ul></li></ul><blockquote><p>系统设计时需要考虑峰值和预估值，峰值为用户访问的上限值，预估值为经过几年用户增长后，用户访问的上限值。</p></blockquote><ul><li>延迟、可靠性（几个 9）、安全性</li></ul><h2 id="3-方案设计"><a href="#3-方案设计" class="headerlink" title="3. 方案设计"></a>3. 方案设计</h2><h3 id="3-1-可行解"><a href="#3-1-可行解" class="headerlink" title="3.1 可行解"></a>3.1 可行解</h3><p>先从业务需要简单实现一个可用的系统，需要完成以下接口。</p><p>写接口：</p><ul><li>输入长域名，判断是否存储</li><li>生成一个从未使用过的短域名</li><li>将长域名和短域名的关联持久化到数据库中</li></ul><p>读接口：</p><ul><li>获取短域名，判断是否有效</li><li>根据短域名查询长域名</li><li>使用长域名通知客户端重定向</li></ul><h4 id="处理过期时间"><a href="#处理过期时间" class="headerlink" title="处理过期时间"></a>处理过期时间</h4><p>增加过期时间有以下方案：</p><ul><li>延迟删除：获取短域名时判断是否过期，过期则进行删除。优点是性能损失小，修改方便；缺点是造成空间浪费</li><li>定时删除：设置定时任务，为每个短域名设置删除回调，过期则立即删除。优点是空间利用率最高；缺点是维护定时任务占用大量内存，性能差</li><li>轮询删除：设置后台逻辑，定时清理过期元素。空间和性能的折中考虑。</li></ul><p>由于系统要求低延迟，性能要求高，故选择延迟删除方案。</p><h4 id="保证域名唯一"><a href="#保证域名唯一" class="headerlink" title="保证域名唯一"></a>保证域名唯一</h4><p>一个全局唯一的分布式 id 便能保证域名的唯一性，实现分布式 id 有以下方案：</p><ul><li>哈希，需要处理哈希冲突</li><li>UUID，性能损耗大</li><li>数据库自增 id，可以通过号端模式降低性能开销，但安全性较低</li><li>雪花算法</li></ul><p>综上，一个可行的系统如下图所示：</p><p><img src="可行解.png" alt="alt"></p><h3 id="3-2-系统优化"><a href="#3-2-系统优化" class="headerlink" title="3.2 系统优化"></a>3.2 系统优化</h3><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><ul><li>水平拓展系统，使用 NGINX 进行负载均衡</li><li>进行分片、数据副本</li></ul><h4 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h4><p>数据库层面：</p><ul><li>数据表的业务逻辑很简单，考虑将关系型数据库改为持久化 kv 引擎，例如 LevelDB</li><li>构建索引：写入时需要判断长域名是否存在，对长域名建立索引</li></ul><p>缓存层面：</p><ul><li>判断长域名是否存储和短域名是否分配，可以构建布隆过滤器</li><li>考虑在客户端建立缓存，存储长短域名映射，进一步降低延迟</li></ul><p>业务层面：</p><ul><li>利用号端模式获取批量 id，降低全局 id 的性能开销</li></ul><h4 id="可靠和安全性"><a href="#可靠和安全性" class="headerlink" title="可靠和安全性"></a>可靠和安全性</h4><ul><li>数据库采用主从模式</li><li>使用 kafka 与 binlog 的方式进行全量与增量的跨机房数据冗余备份</li><li>根据监控指标，进行系统熔点、限流、扩缩容 </li><li>直接使用自增 id 作为短域名，避免被遍历爬取</li><li>进行 IP 限流和黑名单防止 DOS 攻击</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/TinyURL">TinyURL wikipedia</a></li><li><a href="https://www.bilibili.com/video/BV1Jb4y197ks">系统设计 短地址系统</a></li><li><a href="https://hardcore.feishu.cn/docs/doccnAfY0f35ZgnrFg7jSTQmOOf">实现一个短域名系统</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 系统设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis核心原理与实战(4) 实战</title>
      <link href="/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(4)%20%E5%AE%9E%E6%88%98/"/>
      <url>/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(4)%20%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h2 id="1-缓存"><a href="#1-缓存" class="headerlink" title="1. 缓存"></a>1. 缓存</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>Redis 最常用的场景是在系统中作缓存使用，部署在数据库的前端，在访问数据时，先访问 Redis，无法访问到数据再访问数据库。</p><p>缓存可分为：</p><ul><li>只写缓存：所有写操作直接发往数据库，读操作先访问缓存</li><li>读写缓存：读写操作都会经过缓存</li></ul><p>读写缓存的写入分为两种策略：</p><ul><li>同步直写：写请求同时发给缓存和数据库，两者都写完后才返回客户端。优点是保持了数据一致性，缺点是增加了响应延迟</li><li>异步写回：写请求先在缓存处理，等到数据将被缓存淘汰时，才同步给数据库</li></ul><p><img src="写入策略.png" alt="alt"></p><h3 id="1-2-数据一致性"><a href="#1-2-数据一致性" class="headerlink" title="1.2 数据一致性"></a>1.2 数据一致性</h3><p>对于读写缓存而言，要保证数据一致性只能采用同步直写策略，并且数据库和缓存的写入必须是原子的。而对于只读缓存，保证数据一致性策略更为复杂，一般有以下策略。</p><h4 id="1-2-1-设置过期时间"><a href="#1-2-1-设置过期时间" class="headerlink" title="1.2.1 设置过期时间"></a>1.2.1 设置过期时间</h4><p>给缓存设置过期时间，所有的写操作以数据库为准，对缓存操作只是尽最大努力即可；数据库写成功，缓存更新失败，可以保证最终一致性。</p><h4 id="1-2-2-先更新数据库，再更新缓存"><a href="#1-2-2-先更新数据库，再更新缓存" class="headerlink" title="1.2.2 先更新数据库，再更新缓存"></a>1.2.2 先更新数据库，再更新缓存</h4><p>该方案由于并发情况下会导致脏数据，一般不使用，例如 A，B 先后进行数据更新，但由于网络问题，A 在 B 之后更新了缓存，导致了脏数据。</p><h4 id="1-2-3-先删缓存，再更新数据库"><a href="#1-2-3-先删缓存，再更新数据库" class="headerlink" title="1.2.3 先删缓存，再更新数据库"></a>1.2.3 先删缓存，再更新数据库</h4><p>该方案也可能导致数据不一致，例如：</p><ul><li>请求 A 进行写操作，删除缓存 </li><li>请求 B 查询发现缓存不存在 ，B 去数据库查询得到旧值，B 将旧值写入缓存</li><li>A 将新值写入数据库</li></ul><p>上述场景请求 B 最终将旧值写入缓存，其他请求访问缓存得到的仍然是旧值。</p><p>解决方案是使用延迟双删，在 A 更新完数据库之后，睡眠一段时间，额外进行一次删除缓存的操作。</p><h4 id="1-2-4-先更新数据库值，再删除缓存"><a href="#1-2-4-先更新数据库值，再删除缓存" class="headerlink" title="1.2.4 先更新数据库值，再删除缓存"></a>1.2.4 先更新数据库值，再删除缓存</h4><p>如果 A 更新了数据库的值，B 在 A 还没更新缓存前仍会读到旧值，如果并发读缓存的请求不多，那只有少量错误，对业务影响比较小。</p><h3 id="1-3-缓存击穿、穿透和雪崩"><a href="#1-3-缓存击穿、穿透和雪崩" class="headerlink" title="1.3 缓存击穿、穿透和雪崩"></a>1.3 缓存击穿、穿透和雪崩</h3><h4 id="1-3-1-缓存击穿"><a href="#1-3-1-缓存击穿" class="headerlink" title="1.3.1 缓存击穿"></a>1.3.1 缓存击穿</h4><p>缓存击穿指对于某个热点数据，无法在缓存中处理，访问该数据的大量请求直接发送到数据库。</p><p>解决方案：</p><ul><li>热点数据永不过期</li><li>限制只有少量请求访问数据库并重新构建缓存</li></ul><h4 id="1-3-2-缓存穿透"><a href="#1-3-2-缓存穿透" class="headerlink" title="1.3.2 缓存穿透"></a>1.3.2 缓存穿透</h4><p>缓存穿透指要访问的数据既不在 Redis 中，也不在数据库中，导致请求访问缓存之后都得再次访问数据库，缓存失去了作用。</p><p>解决方案：</p><ul><li>缓存空值或缺省值</li><li>在业务层使用布隆过滤器判断数据是否存在</li></ul><h4 id="1-3-3-缓存雪崩"><a href="#1-3-3-缓存雪崩" class="headerlink" title="1.3.3 缓存雪崩"></a>1.3.3 缓存雪崩</h4><p>缓存雪崩指大量请求无法在 Redis 中处理，直接发送到数据库，导致数据库的压力激增。</p><p>缓存雪崩一般有两个原因，一个原因是缓存中大量数据同时过期，导致大量请求无法处理，解决方案有：</p><ul><li>微调过期时间，添加一定随机值防止同时过期</li><li>服务降级：当发生缓存雪崩时，如果访问非核心数据，直接返回空值或者错误信息，如果访问核心数据，允许通过数据库读取。</li></ul><p>另一个原因是 Redis 宕机，无法处理请求，解决方案是：</p><ul><li>在业务中实现服务熔断或者请求限流，降低数据库的压力</li><li>建立 Redis 高可用集群</li></ul><h2 id="2-分布式锁"><a href="#2-分布式锁" class="headerlink" title="2. 分布式锁"></a>2. 分布式锁</h2><p>在分布式系统中，某些数据也需要进行并发访问，需要加锁。分布式锁需要一个共享存储系统来维护，可以创建一个锁变量，相应的加锁、解锁操作就变成读取、判断和设置变量值。</p><p>Redis 可用于实现分布式锁，但需要考虑单机和集群两种场景。</p><h3 id="2-1-单机实现分布式锁"><a href="#2-1-单机实现分布式锁" class="headerlink" title="2.1 单机实现分布式锁"></a>2.1 单机实现分布式锁</h3><p>一个直观想法是使用 SETNX 和 DEL 创建和释放锁，但这个方案存在两个问题。</p><p>一个问题是如果获取到锁的客户端发生异常，没有执行 DEL 命令释放锁，将导致死锁。针对这个问题，一个有效方案是给锁设置过期时间，注意过期时间的合理性，保证不会在业务在运行完之前释放锁。</p><p>另一个问题是无法区分客户端，A 使用 SETNX 创建了锁，但 B 使用 DEL 则直接释放了锁。解决方案是让客户端给锁变量设置唯一值，释放锁时使用 lua 脚本先判断 Redis 中锁变量的值与客户端的值，一致才能释放锁。</p><h3 id="2-2-集群实现分布式锁"><a href="#2-2-集群实现分布式锁" class="headerlink" title="2.2 集群实现分布式锁"></a>2.2 集群实现分布式锁</h3><p>单机 Redis 节点宕机之后便无法提供服务，需要引入集群实现高可用的分布式锁。</p><p>上述单机分布式锁的解决方案可以作用在集群上，但如果主节点申请的锁还未同步到从节点，此时主节点宕机，重新选取的主节点未持有该锁，会导致两个客户端同时获得锁，一般业务场景可以容忍这个问题，追求更强的一致性可以使用 Redlock 算法。</p><p>Redlock 算法是 Redis 开发人员提出的分布式锁算法，其基本思路是，让客户端和多个 Redis 实例依次</p><p>加锁，如果和半数以上的实例完成加锁操作并且未超过锁的有效时间，则成功获得分布式锁，释放锁时向所有节点解锁。</p><h2 id="3-消息队列"><a href="#3-消息队列" class="headerlink" title="3.消息队列"></a>3.消息队列</h2><p>现在的互联网应用基本是分布式架构，而其中一个基础组件就是消息队列，那么 Redis 能够实现消息队列吗？</p><h3 id="3-1-消息队列的需求"><a href="#3-1-消息队列的需求" class="headerlink" title="3.1 消息队列的需求"></a>3.1 消息队列的需求</h3><p>消息队列在存取消息时，需要满足三个需求：</p><ul><li>消息保序：消费者能够按照生产者发送消息的顺序来处理，防止业务错误</li><li>重复消息处理</li><li>可靠性保证：由于网络或者机器故障，消息可能未处理完，需要能提供消息可靠性的保证</li></ul><h3 id="3-2-基于List实现"><a href="#3-2-基于List实现" class="headerlink" title="3.2 基于List实现"></a>3.2 基于List实现</h3><p>一个直观想法是使用 List 实现，List 是按照 FIFO 的顺序存储的，符合消息保序的需求。</p><p>生产者使用 LPUSH 命令写入消息，消费者使用 RPOP 从另一端拉取数据并处理。由于 List 不会主动通知有新消息，在消费侧需要死循环调用 RPOP 指令，带来性能损失，对此 Redis 提供 BRPOP 命令，BRPOP 为阻塞式读取，没有读到队列数据时会自动阻塞直到有新数据入队，节省 CPU 开销。</p><p>对于重复消息，List 没有提供保证，生产者在生产时需要提供全局唯一 id，消费者程序需要实现幂等消费。</p><p>对于可靠性，Redis 提供了 BRPOPLPUSH 命令，该命令需要维护两个 List，从列表中取出最后一个元素，并插入备份列表的头部，如果消费者未能正常处理，重启后从备份列表重新拉取处理。</p><h3 id="3-3-Streams"><a href="#3-3-Streams" class="headerlink" title="3.3 Streams"></a>3.3 Streams</h3><p>Streams 是 Redis 5.0 专门为消息队列设计的数据类型，提供以下命令：</p><ul><li>XADD：插入消息，保证有序，并生成全局唯一 ID</li><li>XREAD：读取消息，可以按 ID 读取</li><li>XREADGROUP：按消费组形式读取消息</li><li>XPENDING：查询每个消费组内消费组已读取但未确认的消息</li><li>XACK：确认消息处理完成</li></ul><blockquote><p>对于 Redis 做消息队列，业界一直有所争议，认为应该使用 Kafka、RocketMQ 等专业的消息队列。笔者认为 Redis 基于 List 实现的消息队列较为繁琐，一般不推荐使用， Streams 使用较为简单，可用在消息通信量较小的场合。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis核心原理与实战(3) 底层实现</title>
      <link href="/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(3)%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
      <url>/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(3)%20%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1. 字符串"></a>1. 字符串</h2><p>Redis 中的字符串采用简单动态字符串（Simple Dynamic String，SDS），实现如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// buf数组已使用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// buf数组未使用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 保存数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SDS 相比 C 字符串的优势：</p><ul><li>计数方式不同，C 字符串获取长度时间复杂度 O(n)，sdshdr 为 O(1)</li><li>杜绝了缓冲区溢出，进行自动扩容</li><li>空间预分配和惰性空间释放<ul><li>空间预分配：对 sdshdr 拓展时，会分配多余的 free空间 + 1 byte，其余 1 byte 用于存空字符</li><li>惰性空间释放：sdshdr 缩减后，不会立即回收多余空间</li></ul></li><li>二进制安全，对于二进制文件中存在 ‘\0’ , C 字符串会截断，sdshdr 则不存在这个问题。</li><li>sdshdr 兼容 string.h 的某些操作，并且支持二进制格式</li></ul><h2 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h2><p>Redis 采用双向链表实现 List。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">pre</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> * <span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 采用void* 可以保存任意类型</span></span><br><span class="line">    <span class="keyword">void</span> * value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode * head;</span><br><span class="line">    listNode * tail;</span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点值对比函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-字典"><a href="#3-字典" class="headerlink" title="3. 字典"></a>3. 字典</h2><p>Redis 会保存一个全局字典记录 key-value 映射，采用哈希表实现。</p><p><img src="全局哈希表.png" alt="alt"></p><h3 id="3-1-字典实现"><a href="#3-1-字典实现" class="headerlink" title="3.1 字典实现"></a>3.1 字典实现</h3><p>字典底层采用哈希表实现，使用拉链法解决哈希冲突。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型特定函数，保存了操作该类型的函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="comment">// 保存了传给该类型的可选参数</span></span><br><span class="line">    <span class="keyword">void</span> *pridata;</span><br><span class="line">    <span class="comment">// ht[0]存储数据，ht[1]用于rehash复制</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 是否在rehash, 如果不在rehash，则值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哈希函数</span></span><br><span class="line">    <span class="function"><span class="keyword">unsigned</span> <span class="title">int</span> <span class="params">(*hashFunction)</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">    <span class="comment">// 复制key的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 复制value的函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">// 对比key的函数</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span>* key2);</span><br><span class="line">    <span class="comment">// 销毁key的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="comment">// 销毁value的函数</span></span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>字典中保存了两个哈希表和一个下标 rehashidx 用以实现 rehash，结构如下图所示。</p><p><img src="字典示意.jpg" alt="alt"></p><h3 id="3-2-rehash"><a href="#3-2-rehash" class="headerlink" title="3.2 rehash"></a>3.2 rehash</h3><p>rehash 的流程：</p><ul><li>为 ht[1] 分配空间，ht[1] 的长度为 2 的幂</li><li>渐进 rehash：当用户执行增删改查时，定位其索引 rehashidx，将 ht[0] 对应的节点复制到 ht[1]，故 resash 操作被平摊到各个操作上。故在 rehash 过程中，用户的操作需要在 ht[0] 和 ht[1] 两个表进行（增加操作只在 ht[1] 进行，保证 ht[0] 只减不增），rehash 结束，rehashidx变为 -1</li><li>释放 ht[1]，将 ht[1] 设置为 ht[0]，ht[1] 创建一个空表，为下次 rehash 做准备</li></ul><p>rehash 时机：</p><ul><li>拓展<ul><li>目前没有执行 BGSAVE 或 BGREWRITEAOF，且负载因子大于等于 1</li><li>目前正在执行 BGSAVE 或 BGREWRITEAOF，且负载因子大于等于 5 (BGSAVE/BGREWRITEAOF 采用 copy-on-write 机制，redis 提高了负载因子的上限，避免子进程运行期间哈希表进行扩容，减少不必要的内存写入）</li></ul></li><li>收缩：负载因子小于 0.1</li></ul><h2 id="4-跳跃表"><a href="#4-跳跃表" class="headerlink" title="4. 跳跃表"></a>4. 跳跃表</h2><p>跳跃表是 Redis 有序集合的基础，是多层有序链表。</p><p>传统的有序链表插入和查找的复杂度都为 O(n)，如果我们将有序链表的节点分层，每一层都是有序链表，在查找时从最高层开始查找，如果 next 节点大于要寻找的值或 next 为空，则到下一层查找，即可完成 O(logn) 的查找复杂度。跳表的具体实现不在此介绍，感兴趣的读者可以翻阅数据结构教材查看。</p><p><img src="跳表.png" alt="alt"></p><h2 id="5-压缩列表"><a href="#5-压缩列表" class="headerlink" title="5. 压缩列表"></a>5. 压缩列表</h2><p>压缩列表 ziplist 本质上是个字节数组，是 Redis 为了节约内存而设计的一种线性数据结构，Redis 的游戏集合、哈希和列表都使用了压缩列表。</p><p>ziplist 的结构如下图所示。</p><p><img src="压缩列表示意.png" alt="alt"></p><ul><li>zlbytes：压缩列表的字节长度</li><li>zltail：压缩列表尾元素相对于压缩列表起始地址的偏移量</li><li>zllen：压缩列表的元素个数</li><li>entryX：压缩列表存储的元素，可以是字节数组或者整数，长度不限</li><li>zlend：压缩列表的结尾标志符，恒为0xFF</li></ul><p>根据上面的结构，我们很容易就可以得到压缩列表的字节长度、元素个数等，那么对于任意一个元素，如何判断其类型，以其元素的长度呢？</p><p>回答这些问题前，首先需要了解元素的结构，如下图所示。</p><p><img src="压缩列表元素结构.png" alt="alt"></p><ul><li>previous_entry_length：前一个元素的字节长度</li><li>encoding：编码，当前元素的数据类型，整数或者字节数组</li><li>content：数据内容</li></ul><p>ziplist 遍历时从尾部开始遍历（通过 ztail 定位），根据 previous_entry_length 即可不断向前遍历，直到表头节点。</p><h2 id="6-quicklist"><a href="#6-quicklist" class="headerlink" title="6. quicklist"></a>6. quicklist</h2><p>低版本 Redis 的 List 使用 ziplist 和双向链表作为底层实现，在 3.2 版本引入 quicklist 综合考虑时间和空间效率。</p><p>quicklist 是一个双向链表， 链表中的每个节点都是一个 ziplist，结构如下图所示。</p><p><img src="quicklist.png" alt="alt"></p><h2 id="7-整数集合"><a href="#7-整数集合" class="headerlink" title="7. 整数集合"></a>7. 整数集合</h2><p>整数集合 intset 用于保存整数值的集合，可以保存 int16_t、int32_t、int64_t 的整数值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 包含元素个数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 存储元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>intset 的插入可能会触发升级</p><ul><li>触发条件：添加的新元素超过当前类型能表示的范围（过大或者过小），则会触发升级</li><li>过程：根据新元素类型拓展数组，并转换原有元素，之后添加新元素（只会放在最后或者 0 号位置）</li><li>自动升级的优点：灵活，节省内存</li></ul><h2 id="8-对象"><a href="#8-对象" class="headerlink" title="8. 对象"></a>8. 对象</h2><p>上文陆续介绍了 Redis 使用到的主要数据结构和底层实现，但 Redis 并没有直接使用这些数据结构来实现，而是创建了一个对象系统，包含字符串、列表、哈希、集合和有序集合五种对象，主要有以下两个优点：</p><ul><li>Redis会根据场景为对象选择特定的数据结构，来优化效率</li><li>使用引用计数来实现统一的内存回收</li></ul><p>Redis 的每个对象都由一个 redisObject 结构体组成，其代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码格式</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 指向底层实现的数据结构</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><ul><li><p>type：类型，string、list、hash、set、zset 中的一个</p></li><li><p>encoding：编码，即对象使用的数据结构</p></li><li>ptr：对象的底层实现</li><li>refcount：引用计数，为 0 时被回收</li></ul><p>每种类型的对象都至少使用了两种不同的数据结构。</p><p><img src="基本类型底层实现.png" alt="alt"></p>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis核心原理与实战(2) 高可用</title>
      <link href="/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(2)%20%E9%AB%98%E5%8F%AF%E7%94%A8/"/>
      <url>/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(2)%20%E9%AB%98%E5%8F%AF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-复制"><a href="#1-复制" class="headerlink" title="1. 复制"></a>1. 复制</h2><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><p>对于单机的 Redis，有 RDB 和 AOF 持久化机制，在宕机过后可以恢复数据，但在恢复过程中仍然存在不可用的问题。对于这个问题，Redis 提供了主从库模式，主从库采用读写分离的方式，写操作都作用在主库，并同步给从库。</p><p>可以通过 relicaof 指令形成主从库，例如现有实例 1（ip: 172.16.19.3）和实例 2，在实例 2 上执行以下命令，实例 2 就变成了实例 1 从库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicafof   172.16.19.3   6379</span><br></pre></td></tr></table></figure><p>Redis 的复制功能分为同步和命令传播两个操作：</p><ul><li>同步：将从库的状态更新到主库的状态</li><li>命令传播：主库数据修改，将数据同步给从库</li></ul><p>其中命令传播较为简单，下面主要介绍同步。</p><h3 id="1-2-同步"><a href="#1-2-同步" class="headerlink" title="1.2 同步"></a>1.2 同步</h3><p>主库和从库的同步需要经历三个阶段：</p><ul><li>从库发送 psync 命令，表示要进行数据同步，该命令包含主库的标识 runID 和复制进度 offset，主库对此响应 FULLRESYNC 命令并携带两个参数</li><li>主库执行 bgsave 命令，生成 RDB 文件发送给从库，从库接收文件后清空数据库并进行加载</li><li>主库将第二阶段新收到的写命令发送给从库，从库执行后完成同步</li></ul><p><img src="主从库同步.png" alt="alt"></p><p>上述过程对于主库而言，生成和传输 RDB 文件较为耗时，如果从库数量很多，将会导致主库忙于 fork 进程生成 RDB 文件，而 fork 操作会阻塞主线程处理正常请求，导致响应变慢。为了分担主库的压力，可以采用 主 - 从- 从 模式。</p><p>主 - 从 - 从 模式在部署从库时，可以手动选择一个从库，其他部分 Redis 实例作为这个从库的从库。这些 Redis 实例在进行同步时，只需要从级联的从库同步写操作即可。</p><p><img src="级联从库.png" alt="alt"></p><h3 id="1-3-增量复制"><a href="#1-3-增量复制" class="headerlink" title="1.3 增量复制"></a>1.3 增量复制</h3><p>主从库如果出现了网络中断，重连之后进行全量复制的开销非常大，对此 Redis 2.8 引入增量复制。</p><p>增量复制的奥妙在于 repl_backlog_buffer 缓冲区，这是一个环形缓冲区，主库记录自己写到的位置，从库记录已读的位置。</p><p>在主从库断连后，主库会把这期间收到的写操作，同时写入 replication buffer 和 repl_backlog_buffer。在从库恢复链接后，发送 psync 命令和自己的已读偏移给主库，主库响应从库缺失的指令，从库运行之后即可完成同步。</p><p><img src="增量复制.png" alt="alt"></p><h2 id="2-Sentinel"><a href="#2-Sentinel" class="headerlink" title="2. Sentinel"></a>2. Sentinel</h2><p>在主从库模式中，如果主库宕机，写请求将无法处理，此时需要将一个从库切换为主库，这就要提到哨兵机制，这是实现主从库自动切换的关键机制。</p><p>哨兵 Sentinel 是 Redis 的高可用方案，本质是一个运行在特殊模式下的 Redis 实例，主要负责三个任务：监控、选主和通知。</p><h3 id="2-1-监控"><a href="#2-1-监控" class="headerlink" title="2.1 监控"></a>2.1 监控</h3><p>监控即判断主库是否为下线状态，Sentinel 会按一定频率向所有跟它连接的实例发送 PING 命令，判断实例是否在线。</p><p>哨兵对主库的判断有 主观下线 和 客观下线 两种，当哨兵发现实例对 PING 的响应超时了，就会把它标记为主观下线。此时并不会开启主从切换，因为可能主库并没有故障，但由于网络拥塞导致超时，导致误判。</p><p>在日常开发中，会采用多实例组成的哨兵集群，当超过半数的哨兵判断为主观下线时，才会将主库判定为客观下线，进行主从库切换。</p><h3 id="2-2-选主"><a href="#2-2-选主" class="headerlink" title="2.2 选主"></a>2.2 选主</h3><p>哨兵集群首先使用 Raft 算法选出领头 Sentinel，再选择新主库。哨兵选择新主库的过程分为 筛选 + 打分，首先会根据一定条件去掉不符合条件的从库，再根据一定规则给从库打分，选择得分最高的从库作为主库。</p><p>筛选条件：从库首先得是正常在线状态，最近 5 秒内有回复过领头 Sentinel，并且与主库的断连次数少于一定阈值。</p><p>打分规则分为三轮，只要在某一轮中有从库得分最高，则会被选为主库。</p><ul><li>从库优先级：用户可以通过 slave-priority 给从库设置优先级</li><li>从库复制进度：选择和旧主库同步最接近的从库，即增量复制下标最解决主库的从库</li><li>ID ：选择从 ID 最小的从库</li></ul><h3 id="2-3-通知"><a href="#2-3-通知" class="headerlink" title="2.3 通知"></a>2.3 通知</h3><p>在选出新主库后，Sentinel 发送 SLAVEOF 命令通知从库去复制新主库，并将旧主库变为从库。</p><h2 id="3-切片"><a href="#3-切片" class="headerlink" title="3. 切片"></a>3. 切片</h2><p>当 Redis 中存放大量键值对时，将会占据大量内存，并且影响 RDB 持久化的性能，对此引入切片集群。</p><p>切片集群，也称分片集群，指启动多个 Redis 实例组成集群，并按照一定规则，将数据划分多份，交由不同实例保存。</p><h3 id="3-1-数据和实例的映射"><a href="#3-1-数据和实例的映射" class="headerlink" title="3.1 数据和实例的映射"></a>3.1 数据和实例的映射</h3><p>在切片集群中，数据需要分布在不同实例上，那么数据和实例之间如何对应呢？</p><p>Redis 3.0 引入 Redis Cluster 提供针对切片集群的方案，采用哈希槽 Hash Slot 来处理数据和实例的映射。一个切片集群共有 16384 个槽，根据 key 计算 16 bit 的值并对 16384 取模，可以得到 key 对应的槽，那么槽如何与实例对应呢？</p><p>默认情况下 Redis 会把这些槽平均分配各个实例，用户也可以自定义槽与实例的映射。</p><h3 id="3-2-客户端定位数据"><a href="#3-2-客户端定位数据" class="headerlink" title="3.2 客户端定位数据"></a>3.2 客户端定位数据</h3><p>在集群创建过程中，每个实例会把自己的哈希槽发给预期连接的实例，最终得到所有哈希槽的分布，客户端与集群实例建立连接后，便能得到所有分布信息缓存在本地。</p><p>当实例和哈希槽的对应关系改变之后，例如新增/删除实例，此时客户端是无法获知这个槽变化的，Redis Cluster 提供了一种重定向机制，给客户端发送新实例的地址。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 槽变为12321，IP地址为192.168.1.1</span></span><br><span class="line">(error) MOVED   12321   192.168.1.1</span><br></pre></td></tr></table></figure><p>但可能192.168.1.1 的数据迁移仍未结束，此时会回传 ASK 报错信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(error) ASK 12321 192.168.1.1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis核心原理与实战(1) 介绍</title>
      <link href="/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(1)%20%E4%BB%8B%E7%BB%8D/"/>
      <url>/2022/02/06/Redis%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98(1)%20%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="1-Redis"><a href="#1-Redis" class="headerlink" title="1. Redis"></a>1. Redis</h2><p>Redis，Remote Dictonary Server，远程字典服务，是一个高性能键值数据库，在后端开发中广泛使用。</p><p>Redis 的数据存储在内存中，其网络 IO 处理和数据处理采用一个线程实现，也称 Redis 是单线程的。</p><blockquote><p>严格上来说 Redis 不是单线程的，持久化、异步删除等操作是由额外的线程执行的。由于单个主线程处理网络请求跟不上底层硬件的速度，在 Redis 6.0 后，网络 IO 处理改为多线程，数据访问仍为单线程。</p></blockquote><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><h3 id="2-1-基本类型"><a href="#2-1-基本类型" class="headerlink" title="2.1 基本类型"></a>2.1 基本类型</h3><p>Redis 的五大基本数据类型包括：String、List、Set、Hash、Zset。</p><h4 id="2-1-1-String"><a href="#2-1-1-String" class="headerlink" title="2.1.1 String"></a>2.1.1 String</h4><p>String 即字符串，常见用途是存储序列化后的用户信息</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> APPEND key str ---&gt; 追加字符串，如果key不存在，则新建</span><br><span class="line"><span class="bullet">2.</span> STRLEN key ---&gt; 获取字符串长度</span><br><span class="line"><span class="bullet">3.</span> incr/decr key ---&gt; key对应的值自增/自减</span><br><span class="line"><span class="bullet">4.</span> INCRBY/DECRBY key step ---&gt; key对应的值增加/减少step</span><br><span class="line"><span class="bullet">5.</span> GETRANGE key start end ---&gt; 类似substr，截取字符串</span><br><span class="line"><span class="bullet">6.</span> SETRANGE key start end ---&gt; 替换部分字符串</span><br><span class="line"><span class="bullet">7.</span> setex key timeout value ---&gt; 设置k/v以及过期时间</span><br><span class="line"><span class="bullet">8.</span> setnx key value ---&gt; 设置k/v，如果key存在则失败</span><br><span class="line"><span class="bullet">9.</span> mset/msetnx k1 v1 k2 v2 ---&gt; 设置多个k/v，msetnx是原子操作，只能一起成功或者一起失败</span><br></pre></td></tr></table></figure><h4 id="2-1-2-List"><a href="#2-1-2-List" class="headerlink" title="2.1.2 List"></a>2.1.2 List</h4><p>List 即链表，常用于消息队列</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> LPUSH/RPUSH key value ---&gt; 往列表key头/尾插入数值</span><br><span class="line"><span class="bullet">2.</span> LPOP/RPOP key ----&gt; 移除列表的头/尾元素</span><br><span class="line"><span class="bullet">3.</span> LRANGE key start end ---&gt; 获取列表key一部分数据</span><br><span class="line"><span class="bullet">4.</span> LINDEX key index ---&gt; 获取第index个元素</span><br><span class="line"><span class="bullet">5.</span> LREM key count value ---&gt; 移除指定个数的value</span><br><span class="line"><span class="bullet">6.</span> LLEN key ---&gt; 获取列表的长度</span><br><span class="line"><span class="bullet">7.</span> LTRIM key start stop ---&gt; 通过下标截取指定范围的数据</span><br><span class="line"><span class="bullet">8.</span> LSET list index value ---&gt; 更新第index元素的value</span><br></pre></td></tr></table></figure><h4 id="2-1-3-Set"><a href="#2-1-3-Set" class="headerlink" title="2.1.3 Set"></a>2.1.3 Set</h4><p>Set 即集合，实现集合交并操作</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> sadd myset value ---&gt; 添加元素</span><br><span class="line"><span class="bullet">2.</span> SMEMBERS myset  ---&gt; 查看指定set的所有值</span><br><span class="line"><span class="bullet">3.</span> SISMEMBER myset value  ---&gt; 查看value是否在myset中</span><br><span class="line"><span class="bullet">4.</span> scard myset ---&gt; 查看元素个数</span><br><span class="line"><span class="bullet">5.</span> srem myset value ---&gt; 删除set中的value元素</span><br><span class="line"><span class="bullet">6.</span> 集合操作</span><br><span class="line"><span class="bullet">-</span> 差集: SDIFF set1 set2 </span><br><span class="line"><span class="bullet">-</span> 交集: SINTER set1 set2</span><br><span class="line"><span class="bullet">-</span> 并集: SUNION set1 set2</span><br></pre></td></tr></table></figure><h4 id="2-1-4-Hash"><a href="#2-1-4-Hash" class="headerlink" title="2.1.4 Hash"></a>2.1.4 Hash</h4><p>Hash 即字典，类似 java 中的 HashMap</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> hset myhash key1 value1   ---&gt; 设置元素</span><br><span class="line"><span class="bullet">2.</span> hmset myhash k1 v1 k2 v2  ---&gt; 批量设置</span><br><span class="line"><span class="bullet">3.</span> hgetall myhash ---&gt; 获得key对应的map</span><br><span class="line"><span class="bullet">4.</span> hdel myhash ---&gt;删除key对象的map</span><br><span class="line"><span class="bullet">5.</span> hlen myhash ---&gt; 获取字段数量</span><br></pre></td></tr></table></figure><h4 id="2-1-5-Zset"><a href="#2-1-5-Zset" class="headerlink" title="2.1.5 Zset"></a>2.1.5 Zset</h4><p>Zset 为排序的集合</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> zadd myset score value  ---&gt; 添加元素，优先级为score</span><br><span class="line"><span class="bullet">2.</span> ZRANGEBYSOCRE myset min max [WITHSOCRES] ---&gt; 获取score范围在min - max 之间的元素，可选带优先级</span><br><span class="line"><span class="bullet">3.</span> zcount myset min max ---&gt; 获取指定区间的成员数量</span><br></pre></td></tr></table></figure><h3 id="2-2-特殊数据类型"><a href="#2-2-特殊数据类型" class="headerlink" title="2.2 特殊数据类型"></a>2.2 特殊数据类型</h3><h4 id="2-2-1-geospatial-地理位置"><a href="#2-2-1-geospatial-地理位置" class="headerlink" title="2.2.1 geospatial 地理位置"></a>2.2.1 geospatial 地理位置</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">常用命令</span><br><span class="line"><span class="bullet">1.</span> geoadd table 经度 纬度 placename ---&gt; 添加地理位置</span><br><span class="line"><span class="bullet">2.</span> getpos table placename ---&gt; 获取指定位置的经度和纬度</span><br><span class="line"><span class="bullet">3.</span> geodist table placename1 placename2 单位 ---&gt; 获取两地的直线距离</span><br><span class="line"><span class="bullet">4.</span> georadius table 经度 纬度 半径 单位 ---&gt; 以所给经度、纬度为圆心，获得在半径范围内的位置</span><br><span class="line"><span class="bullet">5.</span> georadiusbymember table place 半径 单位 ---&gt; 以所给位置为圆心，获得在半径范围内的位置</span><br></pre></td></tr></table></figure><h4 id="2-2-Hyperloglog"><a href="#2-2-Hyperloglog" class="headerlink" title="2.2 Hyperloglog"></a>2.2 Hyperloglog</h4><p>Redis 2.8.9 加入了 hyperloglog，用来进行基数统计，基数为一个数据集中不重复元素的个数。其优点是占用内存固定，但计算存在一定误差。适用场景为允许误差的统计，例如一个网站每天的用户访问量。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用命令</span><br><span class="line"><span class="bullet">1.</span> PFadd mykey v1 v2 v3 v4.... ---&gt; 添加元素</span><br><span class="line"><span class="bullet">2.</span> PFCOUNT mykey ---&gt; 计算mykey的基数</span><br><span class="line"><span class="bullet">3.</span> PFMERGE dist mykey1 mykey2... ---&gt; 合并多个hyperloglog</span><br></pre></td></tr></table></figure><h4 id="2-3-Bitmaps"><a href="#2-3-Bitmaps" class="headerlink" title="2.3 Bitmaps"></a>2.3 Bitmaps</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用命令</span><br><span class="line"><span class="bullet">1.</span> setbit mapname index value ---&gt; 将第index位设置为value，value为0/1</span><br><span class="line"><span class="bullet">2.</span> getbit mapname index ---&gt; 取得第index位</span><br><span class="line"><span class="bullet">3.</span> bitcount mapname ---&gt; 计算位图中1的个数</span><br></pre></td></tr></table></figure><p>各数据类型的特点和对比如下图所示。</p><p><img src="数据类型.png" alt="alt"></p><h2 id="3-持久化"><a href="#3-持久化" class="headerlink" title="3. 持久化"></a>3. 持久化</h2><p>Redis 的数据都是保存在内存的，如果宕机会丢失所有数据，Redis 为了数据恢复，引入了 RDB 和 AOF  两种机制。</p><h3 id="3-1-RDB"><a href="#3-1-RDB" class="headerlink" title="3.1 RDB"></a>3.1 RDB</h3><h4 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h4><p>RDB 是 Redis 的内存快照，只保存当前时刻的数据，在创建 RDB 文件过程中的数据修改不会记录，不具备数据完整性。</p><p>优缺点：</p><ul><li>优点：适合大规模的数据恢复，对数据的完整性要求不高</li><li>缺点：需要一定时间进程才能操作，Redis 挂了的话，最后一次修改数据的操作丢失；fork 进程的时候占用较大内存</li></ul><h4 id="3-1-2-触发时机"><a href="#3-1-2-触发时机" class="headerlink" title="3.1.2 触发时机"></a>3.1.2 触发时机</h4><ul><li>用户执行 SAVE、BGSAVE</li><li>配置的 save 规则满足</li><li>执行 flushall 命令</li><li>退出 redis</li></ul><h4 id="3-1-3-创建指令"><a href="#3-1-3-创建指令" class="headerlink" title="3.1.3 创建指令"></a>3.1.3 创建指令</h4><ul><li>SAVE：阻塞服务器进程，直到文件创建完毕</li><li>BGSAVE：默认使用，利用 copy on write 创建一个子进程进行持久化，父进程继续处理客户端请求，在此过程中拒绝 SAVE、BGSAVE 操作防止竞争</li></ul><p><img src="bgsave.png" alt="alt"></p><h3 id="3-2-AOF"><a href="#3-2-AOF" class="headerlink" title="3.2 AOF"></a>3.2 AOF</h3><h4 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h4><p>AOF 以写后日志的形式记录每个写操作，利用 AOF 恢复数据会重新执行这些操作。</p><blockquote><p>写后日志即先执行命令后写数据，为了降低开销，Redis 向 AOF 记录日志并不会进行语法检查，所以先执行命令成功再写入日志。写后日志会丢失最新一次的修改。</p></blockquote><h4 id="3-2-2-写回策略"><a href="#3-2-2-写回策略" class="headerlink" title="3.2.2 写回策略"></a>3.2.2 写回策略</h4><p>写回策略决定了 AOF 持久化的时机，包括：</p><ul><li>Always：同步写回，每个写命令执行完立即同步日志到磁盘。基本不丢数据，但影响主线程性能。</li><li>Everysec：每秒写回，将日志写到 AOF 文件的内存缓冲区，每隔一秒同步到磁盘。宕机时丢失 1 秒内的数据，对性能影响折中。</li><li>No：操作系统控制写回，将日志写到缓冲区，由操作习题决定同步磁盘的时机。丢失数据最多，但对性能影响最小。</li></ul><h4 id="3-2-3-AOF重写"><a href="#3-2-3-AOF重写" class="headerlink" title="3.2.3 AOF重写"></a>3.2.3 AOF重写</h4><p>由于 AOF 文件只能追加，经过长时间运行，AOF 文件过大，继续追加日志以及数据恢复的耗时都会变长，故引入 AOF 重写机制。</p><p>重写的思想为将旧日志中的对同一个 key 的多条命令变为一条命令。</p><p>AOF 重写流程：</p><ul><li>创建子进程进行重写操作</li><li>在重写过程如果服务器收到指令，则将追加到 AOF 缓冲区和 AOF 重写缓冲区</li><li>子进程完成重写向父进程发送信号，父进程原子替换 AOF 文件</li></ul><h2 id="4-淘汰策略"><a href="#4-淘汰策略" class="headerlink" title="4. 淘汰策略"></a>4. 淘汰策略</h2><p>随着服务的运行，缓存被写满是不可避免的，此时需要对缓存中的数据进行淘汰，Redis 的淘汰策略包含：</p><ul><li>noeviction：默认淘汰策略，可进行删读，不可增改</li><li>volatile-lru：使用 LRU 淘汰设置了过期时间的 key</li><li>volatile-lfu：使用 LFU 淘汰设置了过期时间的 key</li><li>volatile-ttl：淘汰最先要过期的 key</li><li>volatile-random：随机淘汰会过期的 key</li><li>allkeys-lru：使用 LRU 淘汰 key</li><li>allkeys-lfu：使用 LFU 淘汰 key</li><li>allkets-random：随机淘汰key</li></ul><blockquote><p>LRU，Least Recently Used，最近最少使用算法，淘汰最近未被使用过的数据；</p><p>LFU，Least Frequently Used，最不经常使用算法，淘汰使用次数最少的数据。</p></blockquote><p><img src="淘汰策略.png" alt="alt"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://time.geekbang.org/column/intro/100056701">Redis核心技术与实战</a></li><li><a href="https://book.douban.com/subject/25900156/">Redis设计与实现</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> NoSQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(5) 线程池</title>
      <link href="/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(5)%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(5)%20%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><h3 id="1-1-使用线程池的原因"><a href="#1-1-使用线程池的原因" class="headerlink" title="1.1 使用线程池的原因"></a>1.1 使用线程池的原因</h3><p>使用线程池主要有以下原因：</p><ul><li><p>控制并发的数量。每一个线程操作系统都需要为其分配资源，并发数量过多会导致资源消耗大</p></li><li><p>创建/销毁线程开销大，线程池通过复用已创建的线程降低开销</p></li><li>统一管理</li></ul><h3 id="1-2-ThreadPoolExecutor简介"><a href="#1-2-ThreadPoolExecutor简介" class="headerlink" title="1.2 ThreadPoolExecutor简介"></a>1.2 ThreadPoolExecutor简介</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="params"><span class="function">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="params"><span class="function">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="params"><span class="function">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> :</span><br><span class="line">            AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code> 包含 7 个参数，其中 <code>threadFactory</code> 和<code>handler</code> 为可选项，其他为必选项，各参数含义如下：</p><ul><li><p><code>corePoolSize</code>：核心线程最大值。线程池的线程分为核心线程和非核心线程，核心线程闲置也不会被销毁，非核心线程闲置一定时间后会被回收</p></li><li><p><code>maximumPoolSize</code>：线程总数最大值，等于核心线程数+非核心线程数</p></li><li><p><code>keepAliveTime</code>：非核心线程闲置超时时长，超过将被销毁</p></li><li><p><code>unit：keepAliveTime</code> 的单位，是个枚举类型，包括天、小时、分、秒、毫秒、微秒、纳秒</p></li><li><p><code>workQueue</code>：工作队列，维护等待执行的任务对象</p><p>常用的几个阻塞队列：</p><ul><li><code>LinkedBlockingQueue</code>：链表实现的阻塞队列，默认大小是 <code>Integer.MAX_VALUE</code>，也可用户指定大小</li><li><code>ArrayBlockingQueue</code>：数组实现的阻塞队列，需要指定大小</li><li><code>SynchronousQueue</code>：同步队列，内部容量为 0，<code>put</code> 操作必须等待一个 <code>take</code> 操作，反之亦然</li><li><code>DelayQueue</code>：延时队列，当队列的元素到达延时时间，才能够被获取</li></ul></li><li><p><code>threadFactory</code>：线程工厂，用于批量创建线程，不指定则使用默认工厂</p></li><li><p><code>handler</code>：拒绝处理策略，当任务无法入队且达到线程数量限制时采用处理策略，有 4 种实现：</p><ul><li><code>AbortPolicy</code>：默认使用，丢弃任务并抛出 <code>RejectedExecutionException</code></li><li><code>DiscardPolicy</code>：忽略任务，不抛出异常</li><li><code>DiscardOldestPolicy</code>：丢弃最旧的任务，尝试执行新任务，失败则重复该过程</li><li><code>CallerRunsPolicy</code>：由调用线程（将该任务添加到线程池的线程）处理该任务</li></ul></li></ul><h3 id="1-3-线程池状态"><a href="#1-3-线程池状态" class="headerlink" title="1.3 线程池状态"></a>1.3 线程池状态</h3><p>类似线程，线程池也有自己的状态，在代码中通过一些常量来表示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// COUNT_BITS = 29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><ul><li><code>RUNNING</code>：接受新任务，也能处理阻塞队列中的任务</li><li><code>SHUTDOWN</code>：不接受新任务，但能处理队列中的任务</li><li><code>STOP</code>：不接受新任务，不处理队列中的任务，并且中断正在处理的任务</li><li><code>TIDYING</code>：已经没有工作线程和任务，并且马上要调用 <code>terminated</code> 方法</li><li><code>TERMINATED</code>：调用 <code>terminated</code> 方法结束，线程池停止</li></ul><p><img src="线程池状态转移.png" alt="alt"></p><p>线程池内部用一个 int 类型变量 ctl 同时表示线程池状态和线程数量，高 3 位用于表示线程池状态，而低 29 位表示线程的数量。</p><blockquote><p>此处使用一个变量的好处是如果对两个状态都进行同步修改，只需要通过位操作即可，免去了加锁操作，从这里也能感受到 Doug Lea 的精心设计。</p></blockquote><h3 id="1-4-线程池配置"><a href="#1-4-线程池配置" class="headerlink" title="1.4 线程池配置"></a>1.4 线程池配置</h3><p>给出如下定义：</p><ul><li>CPU 的数量 = N</li><li>预期 CPU 使用率 = U</li><li>等待时间与计算时间的比率 = W/C</li></ul><p>则推荐的线程池大小为：</p><ul><li>CPU 密集型：N + 1</li><li>IO 密集型：N x U x (1 + W/C)</li></ul><h2 id="2-线程池工作流程"><a href="#2-线程池工作流程" class="headerlink" title="2. 线程池工作流程"></a>2. 线程池工作流程</h2><h3 id="2-1-execute"><a href="#2-1-execute" class="headerlink" title="2.1 execute"></a>2.1 execute</h3><p><code>execute</code> 是线程池处理任务的核心方法，其 JDK 1.8 版本的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    <span class="comment">// 当前线程数小于corePoolSize,调用addWorker创建核心线程加载任务</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 核心线程数已达上限，则将任务添加到队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">// 线程池已经不再运行，则移除该任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">// 线程池仍在工作，但还未创建线程，则创建新线程</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加队列失败，则创建非核心线程，创建失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其流程如下：</p><p><img src="主流程.png" alt="alt"></p><p><img src="线程池处理流程.png" alt="alt"></p><h3 id="2-2-线程复用"><a href="#2-2-线程复用" class="headerlink" title="2.2 线程复用"></a>2.2 线程复用</h3><p>上述 <code>execute</code> 方法是线程池处理任务、创建线程和执行拒绝策略的主流程。那么如何进行线程复用呢？这需要提及上面的 <code>addWorker</code> 方法，创建线程时，会将线程封装为 worker，将其添加到工作组，这个 worker 则会不断从阻塞队列拿任务执行。<code>addWorker</code> 的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 省略判断线程数量的代码</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建worker</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 线程池全局加锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Recheck while holding lock.</span></span><br><span class="line">                <span class="comment">// Back out on ThreadFactory failure or if</span></span><br><span class="line">                <span class="comment">// shut down before lock acquired.</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 启动线程</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addWorker</code> 方法先对线程数量进行判断，如果达到上限则返回 false（execute 中即可执行拒绝策略），否则获得全局锁后创建线程封装为 worker，将其添加到工作组中，并启动线程。</p><p>接下来我们看看 Worker 的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    Runnable firstTask;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其余代码略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker 的构造函数创建了一个线程，并且任务就是自身，当 <code>addWorker</code> 方法中调用 <code>t.start</code> 方法时，将会调用 Worker 的 <code>run</code> 方法，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runWorker(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 1.线程启动之后，通过unlock方法释放锁</span></span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 2.Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.1进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）</span></span><br><span class="line">            w.lock();</span><br><span class="line">            <span class="comment">// 2.2检查线程池状态，倘若线程池处于中断状态，当前线程将中断。 </span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 2.3执行beforeExecute，默认无实现，由用户提供</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 2.4执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 2.5执行afterExecute方法，默认无实现，由用户提供</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">// 2.6解锁操作</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>runWorker</code> 方法会进入一个死循环，优先执行 firstTask，然后再通过 <code>getTask</code> 方法从阻塞队列中获取任务执行。除此之外线程池还提供了 <code>beforeExecute</code> 和 <code>afterExecute</code> 两个 hook 方法交由用户自定义实现任务执行前和执行后的操作。</p><p>到此我们知道了，只要 <code>getTask</code> 方法不返回 null，那么这个线程就不会被回收。那么 <code>getTask</code> 方法是如何实现闲置一定时间后返回 null 呢，其代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// getTask源码，省略部分判断代码</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// Did the last poll() time out?</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line">           <span class="comment">// ... </span></span><br><span class="line">           <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">           <span class="comment">// 是否有非核心线程</span></span><br><span class="line">           <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">           <span class="comment">// 非核心线程闲置一定时间，则任何null</span></span><br><span class="line">           <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">               &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">               <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 核心线程和非核心线程的调用方法不同</span></span><br><span class="line">               Runnable r = timed ?</span><br><span class="line">                   workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                   workQueue.take();</span><br><span class="line">               <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                   <span class="keyword">return</span> r;</span><br><span class="line">               timedOut = <span class="keyword">true</span>;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">               timedOut = <span class="keyword">false</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>核心线程调用的 <code>workQueue.take</code> 方法，如果队列为空将阻塞在当前调用，直到有新任务入队；而非核心线程调用 <code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> 方法，一段时间未获取任务将会返回 null，在下一轮循环则会退出循环返回 null 给 <code>runWorker</code> 方法，<code>runWorker</code> 方法退出循环回收线程，至此线程池的运行逻辑便梳理清楚了。</p><h2 id="3-常见线程池"><a href="#3-常见线程池" class="headerlink" title="3. 常见线程池"></a>3. 常见线程池</h2><p><code>Executors</code> 类提供了几个静态方法创建特定类型的线程池。</p><h3 id="3-1-newCachedThreadPool"><a href="#3-1-newCachedThreadPool" class="headerlink" title="3.1 newCachedThreadPool"></a>3.1 newCachedThreadPool</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static ExecutorService newCachedThreadPool() &#123;</span><br><span class="line">    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,</span><br><span class="line">                                  60L, TimeUnit.SECONDS,</span><br><span class="line">                                  new SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CachedThreadPool</code> 不会创建核心线程，并且采用 <code>SynchronousQueue</code> 存储，提交任务后如果有空闲线程则进行处理，没有则创建一个非核心线程，空闲线程在 60s 后将被回收。</p><p>根据 <code>CachedThreadPool</code> 的上述特点，它适合使用在 大量短时间任务 的场景。</p><h3 id="3-2-FixedThreadPool"><a href="#3-2-FixedThreadPool" class="headerlink" title="3.2 FixedThreadPool"></a>3.2 FixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>FixedThreadPool</code> 只能创建核心线程，提交任务后核心线程空闲进行处理，不空闲则入列等待，等待的任务数量上限是 <code>Integer.MAX_VALUE</code>。</p><p>特点：</p><ul><li>只会创建核心线程</li><li>线程不会被回收，一直阻塞</li><li>几乎不会触发拒绝策略</li></ul><h4 id="3-3-SingleThreadExecutor"><a href="#3-3-SingleThreadExecutor" class="headerlink" title="3.3 SingleThreadExecutor"></a>3.3 SingleThreadExecutor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SingleThreadPool</code> 有且仅有一个核心线程工作，不会创建非核心线程，所有任务按 先来先服务的顺序执行。</p><h4 id="3-4-ScheduledThreadPool"><a href="#3-4-ScheduledThreadPool" class="headerlink" title="3.4 ScheduledThreadPool"></a>3.4 ScheduledThreadPool</h4><p><code>ScheduledThreadPool</code> 会创建一个定长线程池，支持定时和周期性任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>《阿里巴巴开发手册》中不推荐通过这些方法创建线程池，推荐通过调用 <code>ThreadPoolExecutor</code> 构造函数的方式创建，这样处理让创建线程池的同学需要明确业务场景，选择合适的参数。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://concurrent.redspider.group/article/03/12.html">深入浅出Java多线程</a></li><li><a href="https://book.douban.com/subject/2148132/">Java并发编程实践</a></li><li><a href="https://book.douban.com/subject/30333948/">码出高效</a></li><li><a href="https://www.bilibili.com/video/BV11A411V78m?spm_id_from=333.999.0.0">源码级解读ThreadPoolExecutor</a></li><li><a href="https://book.douban.com/subject/26591326/">Java并发编程的艺术</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(4) CAS</title>
      <link href="/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(4)%20CAS/"/>
      <url>/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(4)%20CAS/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.  介绍"></a>1.  介绍</h2><p>锁可以分为：</p><ul><li>悲观锁：认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</li><li>乐观锁：总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。</li></ul><p>由于无锁操作中没有锁的存在，因此不会出现死锁，换句话说，乐观锁免疫死锁。</p><p>乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；而悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。</p><p>乐观锁底层依赖 CAS 实现，CAS，Compare and Swap，比较并交换，是一种乐观锁实现。CAS 有 3 个操作数，内存位置 V，期望值 A，新值 B，如果 V 中的值等于 A，则将 V 中的数据更新为 B；否则则不进行操作，最终返回 V 的数值。</p><h2 id="2-Java中的CAS"><a href="#2-Java中的CAS" class="headerlink" title="2. Java中的CAS"></a>2. Java中的CAS</h2><p><code>sun.misc.Unsafe</code> 包中提供了 CAS 支持</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* var1: 要操作的对象</span></span><br><span class="line"><span class="comment">* var2: 要操作的属性的地址偏移量</span></span><br><span class="line"><span class="comment">* var1 + var2 可以确定内存位置V的值</span></span><br><span class="line"><span class="comment">* var4: 期望值A</span></span><br><span class="line"><span class="comment">* var5: 新值B</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object var1, <span class="keyword">long</span> var2, Object var4, Object var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4, <span class="keyword">long</span> var6)</span></span>;</span><br></pre></td></tr></table></figure><p>CAS 是 atomic 包的原子类的实现基础。例如 <code>AtmoicInteger</code> 的 <code>getAndSet</code> 方法，即通过 CAS 设置新值并返回旧值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndSetInt(<span class="keyword">this</span>, valueOffset, newValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-CAS底层实现"><a href="#3-CAS底层实现" class="headerlink" title="3. CAS底层实现"></a>3. CAS底层实现</h2><p>在 intel x86 平台下，CAS 通过 cmpxchg 指令实现：</p><ul><li>多处理器: 添加 lock 前缀</li><li>单处理器: 不添加 lock 前缀</li></ul><p>lock 前缀的指令具有以下特点：</p><ul><li>如果待访问的数据已经位于 cache 中，并且 Cache Line 的状态为已修改或独占，则直接更新，否则锁住总线进行更新</li><li>禁止该指令前后的读写指令重排序</li><li>将写缓冲区的数据刷新到内存</li></ul><h2 id="4-CAS-的不足"><a href="#4-CAS-的不足" class="headerlink" title="4. CAS 的不足"></a>4. CAS 的不足</h2><ul><li><p>循环时间长，高并发下开销大</p></li><li><p>只能保证一个变量的原子操作</p><p>解决方案：<code>AtomicReference</code> 类能够保证对象之间的原子性，可以把多个变量放到一个对象里面进行 CAS 操作。</p></li><li><p>ABA 问题：一个变量的数据由 A 改为 B 再改为 A，CAS 无法分辨</p><p>解决方案：增加了版本号 version</p><p>JDK 提供了 <code>AtomicStampedReference</code> 作为解决方案</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReference</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部类Pair包括引用和版本号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> T reference;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stamp;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> Pair&lt;V&gt; pair;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * expectedReference: 期望引用</span></span><br><span class="line"><span class="comment">   * newReference: 新值引用</span></span><br><span class="line"><span class="comment">   * expectedStamp: 期望版本号</span></span><br><span class="line"><span class="comment">   * newStamp: 新版本号</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(V   expectedReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 V   newReference,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> expectedStamp,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="keyword">int</span> newStamp)</span> </span>&#123;</span><br><span class="line">        Pair&lt;V&gt; current = pair;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">            expectedReference == current.reference &amp;&amp; <span class="comment">// 引用一致</span></span><br><span class="line">            expectedStamp == current.stamp &amp;&amp; <span class="comment">// 版本一致</span></span><br><span class="line">            ((newReference == current.reference &amp;&amp;</span><br><span class="line">              newStamp == current.stamp) ||</span><br><span class="line">             casPair(current, Pair.of(newReference, newStamp))); <span class="comment">// 设置新值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casPair</span><span class="params">(Pair&lt;V&gt; cmp, Pair&lt;V&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, pairOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(3) synchronized</title>
      <link href="/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(3)%20synchronized/"/>
      <url>/2022/02/05/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(3)%20synchronized/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p><code>synchronized</code> 是 Java 中的一个关键字，用于对代码块的互斥访问，是非公平可重入锁。</p><blockquote><p>公平锁指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁，非公平锁则不保证该顺序性；可重入锁又称递归锁，指该获取到锁的线程，递归调用再次访问互斥代码块时，不会被阻塞。</p></blockquote><p><code>synchronized</code> 有三种加锁方式：</p><ul><li>普通方法，相当于给 实例对象加锁，进入同步代码之前要获得当前实例的锁</li><li>静态方法，相当于给类对象加锁</li><li>代码块，需要指定加锁对象</li></ul><h2 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h2><p><code>synchronized</code> 经过编译之后，会在同步块前后形成 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，当执行 <code>monitorenter</code> 指令时，尝试获取锁，获取成功则计数 +1，执行 <code>monitorexit</code> 则计数 -1，当计数为 0 时，锁即被释放。</p><p><code>monitorenter</code> 和 <code>monitorexit</code> 两个指令，主要是基于 Mark Word 实现的。Java 的对象头由 Mark Word 和 Klass Point 组成。</p><ul><li><p>Mark Word：存储对象的运行数据，64 位 JVM 的 Mark Word 组成如下：</p><p><img src="markword.png" alt="alt"></p><p>其中 monitor 字段即指向堆中相应的监视器对象。</p></li><li><p>Klass Point：指向类元数据（方法区中的 Klass 对象）的指针</p></li></ul><p>在 JVM 层面，监视器对象含有 owner 属性，当获取锁时，使用 CAS 尝试将该字段设置为当前线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _count        = <span class="number">0</span>; <span class="comment">// 该线程获取锁的次数</span></span><br><span class="line">    _owner        = NULL; <span class="comment">// 持有ObjectMonitor对象的线程</span></span><br><span class="line">    _EntryList    = NULL ; <span class="comment">// 等待锁释放的线程队列</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="3-锁升级"><a href="#3-锁升级" class="headerlink" title="3. 锁升级"></a>3. 锁升级</h2><p>传统的锁（下文的重量级锁）依赖操作系统的同步函数，涉及用户态和内核态的切换，而程序实际运行时可能并不存在多线程竞争，此时使用这种机制是十分低效的。</p><p>针对上述问题，在 jdk 1.6 时引入偏向锁和轻量级锁，并搭配锁升级机制，解决没有多线程竞争和少量竞争的场景下重量级锁的性能开销问题。</p><h3 id="3-1-偏向锁"><a href="#3-1-偏向锁" class="headerlink" title="3.1 偏向锁"></a>3.1 偏向锁</h3><p>Hotspot 的开发人员发现很多情况下锁不存在多线程竞争，总由同一个线程多次获得，于是引入偏向锁。偏向锁会偏向第一个访问锁的线程，在接下来的运行过程中，如果该锁没有被其他线程访问，则持有偏向锁的线程将不会触发同步。偏向锁只在第一次获取锁时有一个 CAS 操作，后续操作只会执行几个简单的命令。</p><p>新创建对象的 Mark Word 是可偏向状态，其中的 thread id 为 0，称为匿名偏向。</p><h4 id="偏向锁的加锁"><a href="#偏向锁的加锁" class="headerlink" title="偏向锁的加锁"></a>偏向锁的加锁</h4><ul><li>该对象第一次被线程获取锁，为匿名偏向状态，会使用 CAS 尝试将 thread id 改为当前线程，成功则获得锁，否则撤销偏向锁，并升级为轻量级锁</li><li>被偏向的线程再次进入同步块，发现 thread id 为自身，则往当前线程栈中添加一条 Lock Record，并指向锁对象，执行同步代码块</li><li>当其他线程进入同步块，发生锁已偏向，进入撤销锁的逻辑</li></ul><p>锁升级的时机为：当锁已经发生偏向后，如果另一个线程尝试获得未释放的偏向锁，就会升级成轻量级锁。</p><h4 id="偏向锁的撤销"><a href="#偏向锁的撤销" class="headerlink" title="偏向锁的撤销"></a>偏向锁的撤销</h4><p>偏向锁的撤销需要等待 safe point，暂停所有线程，并进行判断：</p><ul><li>偏向的线程仍存活并且在同步块中，则升级为轻量级锁，原偏向的线程继续拥有锁</li><li>偏向的线程已经死亡或者不在同步块，则将 Mark Word 改为无锁状态，升级为轻量级锁</li></ul><blockquote><p>hotspot 团队在多年验证之后发现，鉴于撤销锁的高成本，从整体而言偏向锁带来的性能提升没有太大收益，偏向锁在 jdk 15 中已经默认关闭偏向锁。</p></blockquote><h3 id="3-2-轻量级锁"><a href="#3-2-轻量级锁" class="headerlink" title="3.2 轻量级锁"></a>3.2 轻量级锁</h3><p>引入轻量级锁的目的：在多线程交替执行同步块的情况下，尽量避免重量级锁使用的操作系统互斥量带来的开销。</p><h4 id="轻量级锁的加锁"><a href="#轻量级锁的加锁" class="headerlink" title="轻量级锁的加锁"></a>轻量级锁的加锁</h4><p>JVM 会为每次线程在线程栈中创建空间存储锁记录 Lock Record，这个空间称为 Displaced Mark Word。如果一个线程获得锁时发现是轻量级锁，则将锁对象的 Mark Word 复制到自己的 Displaced Mark Word。</p><p>线程尝试用 CAS 自旋将锁的 Mark Word 替换为指向 Lock Record 的指针，成功则获取锁，失败则说明有其他线程在竞争锁。</p><p>当自旋超过一定次数之后，则会升级为重量级锁。</p><h4 id="轻量级锁的释放"><a href="#轻量级锁的释放" class="headerlink" title="轻量级锁的释放"></a>轻量级锁的释放</h4><p>释放锁时，当前线程使用 CAS 将 Displaced Mark Word 的内容复制回锁的 Mark Word，没有发生竞争则会成功，如果已经升级为重量级锁，则复制失败，此时会释放锁并唤醒被阻塞的线程。</p><h3 id="3-3-重量级锁"><a href="#3-3-重量级锁" class="headerlink" title="3.3 重量级锁"></a>3.3 重量级锁</h3><p>重量级锁依赖于操作系统的互斥量实现的，效率很低，但被阻塞的线程不会消耗 CPU。</p><p>一个 monitor 对象包括两个同步队列 cxq 和 EntryList，以及一个等待队列 WaitSet，都为 ObjectWaiter 组成的链表。</p><p><img src="重量级锁.png" alt="alt"></p><p>当一个线程尝试获得重量级锁失败时，将该线程封装为 ObjectWaiter 插入到 cxq 队列队首，并挂起当前线程，进入 BLOCKED 状态；当线程释放锁时，会根据唤醒策略，从 cxq 或 EntryList 中挑选一个线程唤醒。</p><p>如果调用的是 wait 方法，则将该线程加入 WaitSet，该线程进入 WAITING 或 TIMED_WAITING 状态。当被 notify 唤醒后，会将线程从 WaitSet 移动到 cxq 或 EntryList 中去，进入 BLOCKED 状态。</p><p>锁升级的全流程如下图：</p><p><img src="锁升级.png" alt="alt"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://github.com/farmerjohngit/myblog/issues/12">死磕synchronized底层实现</a></li><li><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a></li><li><a href="http://concurrent.redspider.group/article/02/9.html">深入浅出Java多线程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(2): JMM和volatile</title>
      <link href="/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(2)%20JMM%E5%92%8Cvolatile/"/>
      <url>/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(2)%20JMM%E5%92%8Cvolatile/</url>
      
        <content type="html"><![CDATA[<h2 id="1-并发编程模型"><a href="#1-并发编程模型" class="headerlink" title="1. 并发编程模型"></a>1. 并发编程模型</h2><p>在并发编程中，必须解决两个问题：</p><ul><li>线程通信：线程之间通过什么机制交换信息</li><li>线程同步：用什么机制控制不同线程操作的相对顺序</li></ul><p>为了解决上述问题，有两种主流的并发模型：</p><ul><li>消息传递模型：线程之间没有公共状态，线程间通过发送消息进行通信，并且发送消息总是在接收消息之前，因此线程同步是天然的</li><li>共享内存模型：线程之间共享程序的公共状态，通过读写内存进行通信，线程同步必须显示指定某段代码在线程之间互斥执行</li></ul><p>消息传递模型的典型代表是 go 中的 channel，而在 Java 中使用的是共享内存模型。</p><h2 id="2-共享内存模型的三个关键点"><a href="#2-共享内存模型的三个关键点" class="headerlink" title="2. 共享内存模型的三个关键点"></a>2. 共享内存模型的三个关键点</h2><p>当设计共享内存模型时，需要考虑三个关键点：</p><ul><li>原子性</li><li>可见性</li><li>有序性</li></ul><h3 id="2-1-原子性"><a href="#2-1-原子性" class="headerlink" title="2.1 原子性"></a>2.1 原子性</h3><p>原子性指一个操作是不可中断的，即使在多线程环境中，一个操作一旦开始，也不会被另一个线程打断。</p><p>例如线程 A 和线程 B 同时对一个变量 i 赋值，A 给 i 赋值为 1， B 给 i 赋值为 2，原子性保证 i 的值要么是 1，要么是 2，不会出现其他的值。这样看来原子性保证仿佛是必然的，其实不然，例如对 64 位的 long 类型进行赋值，假设 long 类型的读写不是原子的，那么便可能存在预期之外的数字。</p><h3 id="2-2-可见性"><a href="#2-2-可见性" class="headerlink" title="2.2 可见性"></a>2.2 可见性</h3><p>可见性是指当一个线程修改某一个共享变量的值时，其他线程能够立即知道这个修改。</p><p>对于单线程程序而言，可见性问题是不存在的。在多线程程序中，可能由于缓存的存在，其他线程读取变量时读到的仍是旧值，怎么解决可见性问题也是并发编程的一个考虑点。</p><h3 id="2-3-有序性"><a href="#2-3-有序性" class="headerlink" title="2.3 有序性"></a>2.3 有序性</h3><p>有序性问题指程序在执行过程中，进行指令重排，导致与原指令的顺序未必一致，可能在多线程带代码中导致另一个线程读到脏值。</p><p>指令是否发生重排、如何重排是我们无法预测的，也就是说，线程 A 的执行顺序对于线程 B 而言是没有保证的，而日常开发中线程 B 的结果可能依赖线程  A 部分代码的运行顺序，所以便需要保持其有序性。</p><h2 id="3-JMM"><a href="#3-JMM" class="headerlink" title="3. JMM"></a>3. JMM</h2><h3 id="3-1-硬件的效率与一致性"><a href="#3-1-硬件的效率与一致性" class="headerlink" title="3.1 硬件的效率与一致性"></a>3.1 硬件的效率与一致性</h3><p>为了减少 CPU 和内存之间处理速度带来的限制，现代 CPU 引入了 cache 的概念，CPU 读取数据先从缓存中读取，读取失败后再从内存中读取。</p><p>由于每个 CPU 核心都包含 cache，这也引入了缓存一致性问题，CPU 层面通过 MESI 等缓存一致性协议解决了该问题。除了 cache 之外，为了提高 CPU 的运算效率，会对代码进行指令重排序和乱序执行，CPU 会保证最后的执行结果一致，但不保证代码顺序运行。 </p><blockquote><p>相关知识具体可见博客中的 程序员需要了解的计组知识(2) 和 (3) 。</p></blockquote><h3 id="3-2-JMM"><a href="#3-2-JMM" class="headerlink" title="3.2 JMM"></a>3.2 JMM</h3><p>JMM，Java Memory Model，Java 内存模型与硬件模型高度类似，并且在编译器层面也对指令进行重排序。</p><p>JMM 主要目的是定义程序中共享字段的访问规则。</p><ul><li>所有变量都存储在主内存中（虚拟机内存的一部分，不是计算机中的内存）</li><li>每条线程还要自己的工作内存，线程的工作内存保存了主内存的部分副本，线程对变量的所有操作必须在工作内存中进行</li><li>线程的工作内存是独立的，无法互相访问</li></ul><p><img src="jmm.png" alt="alt"></p><p>所以当线程读取共享变量的值时，先在工作内存中寻找，如果变量已经被更新中，则从主内存中将数据拷贝到工作内存中。</p><h2 id="4-happens-before原则"><a href="#4-happens-before原则" class="headerlink" title="4. happens-before原则"></a>4. happens-before原则</h2><p>上文提到，java 在编译器层面会对指令进行重排序，保证单线程内的最终结果一致，那么对于多线程程序呢？</p><p>一方面，程序员需要 JMM 提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望 JMM 对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。</p><p>JMM 在其中找到了平衡点，对编译器和处理器来说，只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。也就是说，JMM 并不能保证未同步的多线程程序与其顺序执行的结果一致。</p><p>不过对程序员也提供了弥补错误，对于使用同步语意（<code>synchronized</code>、<code>volatile</code>、<code>Lock</code> 等），提供了 happens-before 原则，只要程序满足了该原则，便能保证运行结果与预期相同。happens-before定制了两个操作之间的执行顺序，其定义如下：</p><ul><li><p>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p></li><li><p>如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</p></li></ul><p>在 Java 程序中，有如下天然的 happens-before 关系：</p><ul><li>程序顺序规则：一个线程中的每一个操作，happens-before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个锁的解锁，happens-before 于随后对这个锁的加锁。</li><li>volatile 变量规则：对一个 <code>volatile</code> 域的写，happens-before 于任意后续对这个 <code>volatile</code> 域的读。</li><li>传递性：如果 A happens-before B，且 B happens-before C，那么 A happens-before C。</li><li>start 规则：如果线程 A 执行操作 <code>ThreadB.start()</code> 启动线程B，那么 A 线程的 <code>ThreadB.start()</code> 操作 happens-before 于线程 B 中的任意操作、</li><li>join 规则：如果线程 A 执行操作 <code>ThreadB.join()</code> 并成功返回，那么线程 B 中的任意操作 happens-before 于线程 A 从 <code>ThreadB.join()</code>   操作成功返回。</li></ul><h2 id="4-volatile"><a href="#4-volatile" class="headerlink" title="4. volatile"></a>4. volatile</h2><p>在 Java 中，<code>volatile</code> 关键字有两个作用：</p><ul><li>保证变量的内存可见性</li><li>禁止 <code>volatile</code> 变量和普通变量重排序</li></ul><h3 id="4-1-内存可见性"><a href="#4-1-内存可见性" class="headerlink" title="4.1 内存可见性"></a>4.1 内存可见性</h3><p>当一个线程对 <code>volatile</code> 修饰的变量进行写操作时， JMM 会立即把该线程对应的本地内存的值刷新到主内存；而对这个变量进行读操作时， JMM 会立即把该线程的本地内存置为无效，从主内存中读取共享变量的值。</p><p>内存可见性不代表线程安全，例如以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码允许之后 count 并不为 200000，这是由于自增操作并不保证原子性，所以仍不是线程安全的。</p><h3 id="4-2-禁止指令重排序"><a href="#4-2-禁止指令重排序" class="headerlink" title="4.2 禁止指令重排序"></a>4.2 禁止指令重排序</h3><p>如果允许 <code>volatile</code> 变量和普通变量重排序，可能会发生问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileExample</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>; <span class="comment">// step 1</span></span><br><span class="line">        flag = <span class="keyword">true</span>; <span class="comment">// step 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123; <span class="comment">// step 3</span></span><br><span class="line">            System.out.println(a); <span class="comment">// step 4</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中线程 A 调用 writer，线程 B 调用 reader。可能出现以下场景：</p><ul><li>线程 A 设置 flag 为 true</li><li>线程 B 读取 flag 为 true</li><li>线程 B 读普通变量 a 的值为 0</li><li>线程 A 写普通变量 a 的值为 1</li></ul><p>虽然 <code>volatile</code> 保证了内存可见性，但是普通变量的值发生了读取错误。</p><p>因此 jdk 1.5 中增强了 <code>volatile</code> 的内存语义，禁止 <code>volatile</code> 变量和普通变量重排序。JVM 层面通过内存屏障来实现，内存屏障是硬件层面而言的，有两个作用：</p><ul><li>屏障两侧的指令进制重排序</li><li>强制把 cache 中的脏数据写入内存，或者使相应的 cache line 失效</li></ul><p>内存屏障有 LoadLoad、LoadStore、StoreStore、StoreLoad 四种。</p><blockquote><p>其规则是 Store 为写指令，Load 为读指令，并按顺序代表屏障前后的指令。例如 LoadLoad 即屏障前后都是读指令，LoadStore 即屏障前是读指令，屏障后是写指令。</p></blockquote><p>对于 <code>volatile</code> 而言，其策略是</p><ul><li>在每个 <code>volatile</code> 写操作前插入一个 StoreStore 屏障</li><li>在每个 <code>volatile</code> 写操作后插入一个 StoreLoad 屏障</li><li>在每个 <code>volatile</code> 读操作后插入一个 LoadLoad 屏障</li><li>在每个 <code>volatile</code> 读操作后再插入一个 LoadStore 屏障</li></ul><p><code>volatile</code> 禁止重排序的功能最经典的用法是双重检测的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明：因为代码复杂，考虑点多，日常开发中不建议双重检测的单例模式，更加推荐使用静态内部类或者枚举的形式，具体可见作者的 小话设计模式(2)。</p></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://concurrent.redspider.group/">深入浅出Java多线程</a></li><li><a href="https://book.douban.com/subject/26663605/">实战Java高并发程序设计</a></li><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/26591326/">Java并发编程的艺术</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java并发编程(1): 多线程基础</title>
      <link href="/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(1)%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/30/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(1)%20%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程"></a>1. 线程</h2><h3 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h3><p>在谈论什么是线程之前需要先介绍一下进程。最初的计算机运行方式是串行的，当程序通过网络、IO 请求资源时，必须等待操作完成，在这段等待的时间中计算机的 CPU 资源便被浪费了。为了提高计算机的运行效率，计算机科学家们创建了操作系统，并提出了进程的概念。</p><blockquote><p>程序等待资源返回的过程称为 阻塞。</p></blockquote><p>进程即运行的程序，包括程序代码和资源两个部分，各个进程之间互不干扰，并且保存着各自的运行状态。当遇到网络、IO 等导致进程阻塞时，操作系统将其他可运行的进程调度到 CPU 上运行，提高了计算机的运行效率，给用户一种一段时间内多个程序同时运行的感觉，这被称之为并发。</p><blockquote><p>关于并发与并行，并发指多个任务交替运行，不限制 CPU 核心数；而并行指多个任务在多个 CPU 核心上同时执行，要求是多核 CPU。</p></blockquote><h3 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h3><p>虽然进程的出现提高了计算机的运行效率，但进程对于开发者而言还是存在一些问题：</p><ul><li><p>多进程的通讯较为繁琐，虽然操作系统提供一系列的通信手段，但是对于开发者而言需要熟悉相应操作系统的 API 才能够实现进程通信</p></li><li><p>进程切换的代价太高了，进程的调度过程涉及进程大量资源替换，是一个耗时的工作</p></li></ul><p>于是，计算机科学家们提出了一个新的概念，线程。多个线程共享同一个进程的地址空间，并且更加轻量，相较进程切换成本有所降低。线程是对逻辑的抽象，而进程是对资源的抽象。</p><h3 id="1-3-上下文切换"><a href="#1-3-上下文切换" class="headerlink" title="1.3 上下文切换"></a>1.3 上下文切换</h3><p>当操作系统将一个进程（或线程）切换到另一个进程（或线程）时，需要涉及上下文切换。上下文是指某个时间点 CPU 寄存器和程序计数器的内容，在切换前需要保存当前的上下文，下次切换为这个任务时，可以再加载这个任务的状态，这个上下文保存再加载的过程就是上下文切换。</p><p>上下文操作会消耗大量的 CPU 时间，适合 IO 密集型应用，而对于计算密集型应用，使用太多线程会导致大量的上下文切换，反而会导致性能降低。</p><blockquote><p>计算密集型指操作主要是 CPU 进行计算，较少涉及 IO 操作。IO 密集型指应用经常需要请求 IO 资源，易进入阻塞状态。</p></blockquote><h3 id="1-4-线程实现方式"><a href="#1-4-线程实现方式" class="headerlink" title="1.4 线程实现方式"></a>1.4 线程实现方式</h3><p>(1) 内核线程实现</p><p><img src="内核线程实现.png" alt="alt"></p><p>由内核通过调度器来完成线程切换，优点是每个线程是独立的调度单元，线程之间互不影响，但缺点是线程创建和切换开销大。</p><p>(2) 用户线程实现</p><p><img src="用户线程实现.png" alt="alt"></p><p>完全建立在用户空间，内核无法感知线程的存在，内核只对线程所属的进程进行控制。优点是不依赖内核实现，但用户需要在用户态实现线程创建和调度功能，一般只在不支持多线程的操作系统上使用，实现并发。</p><p>(3) 混合实现</p><p><img src="混合实现.png" alt="alt"></p><p>即存在用户线程，也存在轻量级进程，支持大规模的用户线程并发，同时使用内核线程进行调度和处理映射。用户线程和内核线程的映射有 1:1，M:N 两种形式，Java 线程为 1:1 的形式，go 的 goroutine 为 M:N 的形式。</p><h3 id="2-在Java中使用多线程"><a href="#2-在Java中使用多线程" class="headerlink" title="2. 在Java中使用多线程"></a>2. 在Java中使用多线程</h3><p>在 Java 中有三种线程创建方式，分别为继承 <code>Thread</code> 类，实现 <code>Runnable</code> 接口和实现 <code>Callable</code> 接口。</p><h3 id="2-1-继承-Thread"><a href="#2-1-继承-Thread" class="headerlink" title="2.1 继承 Thread"></a>2.1 继承 Thread</h3><p>继承 <code>Thread</code> 的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread myThread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意需要调用 <code>start()</code> 方法后，才会创建线程。</p><p>由于 Java 只支持单继承，如果继承了 <code>Thread</code> 类，便无法继承其他类，故直接继承的方式在实际开发中很少使用。</p><h3 id="2-2-实现Runnable接口"><a href="#2-2-实现Runnable接口" class="headerlink" title="2.2 实现Runnable接口"></a>2.2 实现Runnable接口</h3><p>实现<code>Runnable</code> 接口的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 采用函数式编程实现</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Java 8 匿名内部类&quot;</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-实现Callable接口"><a href="#2-3-实现Callable接口" class="headerlink" title="2.3 实现Callable接口"></a>2.3 实现Callable接口</h3><p>实现 <code>Runnable</code> 接口没有返回值，如果我们需要任务运行后的返回值，这时候应该实现 <code>Callable</code> 接口，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FutureTask&lt;String&gt; task = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallerTask());</span><br><span class="line">        <span class="keyword">new</span> Thread(task).run();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(task.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;call&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：继承 <code>Thread</code> 的方式较少使用，实现 <code>Runnable</code> 接口在不需要任务返回值的场景使用，需要返回值则采用实现 <code>Callable</code> 接口的方式。</p><h2 id="3-线程状态与切换"><a href="#3-线程状态与切换" class="headerlink" title="3. 线程状态与切换"></a>3. 线程状态与切换</h2><h3 id="3-1-线程状态"><a href="#3-1-线程状态" class="headerlink" title="3.1 线程状态"></a>3.1 线程状态</h3><p><code>Thread</code> 类中定义了线程的状态为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">State</span> </span>&#123;  </span><br><span class="line">    NEW,</span><br><span class="line">    RUNNABLE,</span><br><span class="line">    BLOCKED,</span><br><span class="line">    WAITING,</span><br><span class="line">    TIMED_WAITING,</span><br><span class="line">    TERMINATED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="New"><a href="#New" class="headerlink" title="New"></a>New</h4><p>当创建 <code>Thread</code> 并且未调用 <code>start()</code> 方法时，操作系统还未为此创建线程，此时处于 <code>New</code> 状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread();</span><br></pre></td></tr></table></figure><h4 id="Runnable"><a href="#Runnable" class="headerlink" title="Runnable"></a>Runnable</h4><p>调用<code>start()</code> 方法之后，<code>Thread</code> 处于 <code>Runnable</code> 状态，该状态并不一定在 CPU 上运行。</p><blockquote><p><code>Runnable</code> 在操作系统的状态中还细分为 <code>READY</code> 和 <code>RUNNING</code>，<code>RUNNING</code> 才是在 CPU 上运行。Java 团队认为 <code>READY</code> 切换到 <code>RUNNING</code> 的时间较短，故在 java 中不进行区分。</p></blockquote><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>当线程执行完毕后，状态就变为 <code>TERMINATED</code>，该状态不可逆。</p><h4 id="BLOKCED"><a href="#BLOKCED" class="headerlink" title="BLOKCED"></a>BLOKCED</h4><p>当线程竞争锁失败之后，状态变为 <code>BLOCKED</code> 状态，阻塞等待锁的释放。</p><blockquote><p>BLOCKED 状态不关心内核线程的阻塞态，只针对 Java 层面的锁，例如 <code>synchronized</code>，<code>Lock</code> 等。操作系统的线程在遇到 IO 等也会进入阻塞状态，此时 <code>Thread</code> 的状态是 <code>Runnable</code>。</p></blockquote><h4 id="WAITING"><a href="#WAITING" class="headerlink" title="WAITING"></a>WAITING</h4><p>该状态下，线程等待并且无时间限制。</p><h4 id="TIMED-WAITING"><a href="#TIMED-WAITING" class="headerlink" title="TIMED_WAITING"></a>TIMED_WAITING</h4><p>等待状态，但有时间限制，如果超时则转换为 <code>RUNNABLE</code> 状态。</p><h3 id="3-2-状态切换"><a href="#3-2-状态切换" class="headerlink" title="3.2 状态切换"></a>3.2 状态切换</h3><h4 id="wait和notify"><a href="#wait和notify" class="headerlink" title="wait和notify"></a>wait和notify</h4><p><code>wait</code> 和 <code>notify</code> 是 Java 多线程等待/通知机制的一种，以下是使用示例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitAndNotify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadA: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        System.out.println(<span class="string">&quot;ThreadB: &quot;</span> + i);</span><br><span class="line">                        lock.notify();</span><br><span class="line">                        lock.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadA()).start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadB()).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：</span></span><br><span class="line">ThreadA: <span class="number">0</span></span><br><span class="line">ThreadB: <span class="number">0</span></span><br><span class="line">ThreadA: <span class="number">1</span></span><br><span class="line">ThreadB: <span class="number">1</span></span><br><span class="line">ThreadA: <span class="number">2</span></span><br><span class="line">ThreadB: <span class="number">2</span></span><br><span class="line">ThreadA: <span class="number">3</span></span><br><span class="line">ThreadB: <span class="number">3</span></span><br><span class="line">ThreadA: <span class="number">4</span></span><br><span class="line">ThreadB: <span class="number">4</span></span><br></pre></td></tr></table></figure><p>在上述代码中，线程 A 和线程 B 首先打印出自己的信息，然后使用 <code>notify()</code>方法叫醒另一个正在等待的线程，然后自己使用 <code>wait()</code> 方法陷入等待并释放 lock 锁。</p><blockquote><p><code>notify()</code> 会唤醒一个等待的线程，与其对应的还有一个 <code>notifyAll()</code>，会唤醒所有等待的线程。</p><p><code>wait</code>、<code>notify</code>、<code>notify</code> 需要和 <code>synchronized</code> 配合使用。 </p></blockquote><p>当一个线程调用 <code>wait()</code> 方法后，会进入 <code>WAITING</code> 状态，直到其他线程调用相应的 <code>notify()</code> 方法。</p><p>如果调用 <code>wait(long timeout)</code> ，则进入 <code>TIMED_WAITING</code> 状态。</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h4><p>线程调用 <code>sleep(long timeout)</code>，进入 <code>TIMED_WAITING</code> 状态，与 <code>wait(long timeout)</code> 的区别是 <code>sleep</code> 不释放锁。</p><h4 id="join"><a href="#join" class="headerlink" title="join"></a>join</h4><p>调用 <code>join()</code> 之后，当前线程必须等待另一个线程执行完毕，<code>join()</code> 的底层实现是 <code>wait()</code>，与 <code>wait()</code> 的状态转移一致</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread test = <span class="keyword">new</span> Thread(...);</span><br><span class="line">test.start();</span><br><span class="line"><span class="comment">// 当前线程必须等待test线程执行完毕</span></span><br><span class="line">test.join();</span><br></pre></td></tr></table></figure><h4 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h4><p>当一个线程调用 <code>yield()</code> 之后，会主动让出 CPU，进入 <code>RUNNABLE</code> 状态等待调度。</p><h4 id="park和unpark"><a href="#park和unpark" class="headerlink" title="park和unpark"></a>park和unpark</h4><p>每个线程都与一个许可(permit)关联。<code>unpark</code> 函数为线程提供 permit，线程调用 <code>park</code> 则等待（进入 <code>WAITING</code> 状态）并消耗permit。<code>park</code> 和 <code>unpark</code> 方法具体实现比较复杂，这里不展开。</p><h4 id="状态转移图"><a href="#状态转移图" class="headerlink" title="状态转移图"></a>状态转移图</h4><p>综上，我们可以得到 <code>Thread</code> 的状态转移图。</p><p><img src="状态转移图.png" alt="alt"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://concurrent.redspider.group/">深入浅出Java多线程</a></li><li><a href="https://book.douban.com/subject/34907497/">深入理解Java虚拟机</a></li><li><a href="https://book.douban.com/subject/30351286/">Java并发编程之美</a></li><li><a href="https://tech.youzan.com/javasuo-yu-xian-cheng-de-na-xie-shi/">Java锁与线程的那些事</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员需要了解的计组知识(3): 存储器</title>
      <link href="/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3)%20%E5%AD%98%E5%82%A8%E5%99%A8/"/>
      <url>/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3)%20%E5%AD%98%E5%82%A8%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-存储金字塔"><a href="#1-存储金字塔" class="headerlink" title="1. 存储金字塔"></a>1. 存储金字塔</h2><p>计算机中使用的存储器可分为</p><ul><li><p>RAM ：静态存储器，读写速度快。举例 CPU Cache</p></li><li><p>DRAM ：动态存储器，读写速度慢，集成度高，掉电失去数据。举例 内存</p></li><li><p>硬盘</p></li></ul><p>计算机中使用的存储设备构成了存储器金字塔</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=YjZjYzE2NmNmZTMzYmNlYThkMDc4NjY0Y2VmZjE0OGZfc0ZmdTJ5Sk5FMEt6a0oyTjRyS3poa1BqTFhEQ0FsNDRfVG9rZW46Ym94Y25wNWd5ZVZDYjF1Y0RiMnp3dzh3cWtjXzE2NDMzNjI3Njg6MTY0MzM2NjM2OF9WNA" alt="img"></p><p>各个存储器只和相邻的一层存储器打交道，并且随着一层层向下，存储器的容量逐层增大，访问速度逐层变慢，而单位存储成本也逐层下降。上一层的存储器可以看出下一层存储器的缓存。</p><h2 id="2-局部性原理"><a href="#2-局部性原理" class="headerlink" title="2. 局部性原理"></a>2. 局部性原理</h2><p>上文说到，上层存储是下层存储的缓存，那么通过添加缓存能加快访问吗？</p><p>是的，计算机的前辈们概括出了局部性原理，包括：</p><ul><li>时间局部性：刚被访问的数据，短时间内容易被再次访问</li><li>空间局部性：刚被访问的数据，其附近的数据容易被访问</li></ul><p>其中时间局部性在 内存管理 中得到广泛应用，空间局部性在 cache、文件系统、磁盘缓存、数据库 中得到广泛应用。</p><h2 id="3-cache"><a href="#3-cache" class="headerlink" title="3. cache"></a>3. cache</h2><h3 id="3-1-介绍"><a href="#3-1-介绍" class="headerlink" title="3.1 介绍"></a>3.1 介绍</h3><p>在过去几十年的计算机发展中，CPU 的性能提升远超内存，内存的存取速度严重滞后于处理器的计算速度，内存瓶颈导致高性能处理器难以发挥出应有的功效，这对日益增长的高性能计算形成了极大的制约，这一问题称为 内存墙 Memory wall。</p><p>为了弥补 CPU 和内存之间的性能差距，在 CPU 中引入高速缓存 cache，CPU 先从 cache 尝试访问数据和指令，访问失败再从内存中访问。</p><p>现在的 CPU 一般包含 L1、L2、L3 三级高级缓存，前一级可以当成后一级的缓存，L3 作为内存的缓存。L1、L2 每个核心独有，而 L3 缓存所有核心共用。</p><p>根据空间局部性原理，cache 从内存中读入是按块进行的，这样一块数据，称之为 cache line，cache line 的大小通常是 64 字节。</p><h3 id="3-2-伪共享问题"><a href="#3-2-伪共享问题" class="headerlink" title="3.2 伪共享问题"></a>3.2 伪共享问题</h3><p>Cache 每次都会读入一个 cache line 大小的数据，在多线程环境中，如果两个线程各自的变量（共两个）被放在同一个 cache line，每次写其中一个变量将导致整个 cache line 失效，相当于只有一个线程可以同时访问这个 cache line，降低了访问速度，这被称为伪共享问题。</p><p>伪共享问题的解决方案是进行字节填充。即增加没有实际意义的填充字段，保证一个 cache line 中只能存储一个对象，在 java 中可以使用 <code>@Contended</code> 注解实现。</p><h3 id="3-3-缓存一致性"><a href="#3-3-缓存一致性" class="headerlink" title="3.3 缓存一致性"></a>3.3 缓存一致性</h3><p>在多核 CPU 中，每个核都会有 L1 和 L2 缓存，对于内存中的同一个数据，两个核心的 cache 都了进行缓存，当其中一个核心的程序对该变量进行修改后，另一个核心的 cache 还保留着改动前的数据，可能会业务逻辑错误，这被称为缓存一致性问题。</p><p>解决一致性问题最常见的方案是总线嗅探，即所有的读写请求都经过总线进行广播，其他核心根据这些广播更新自己的缓存。基于总线嗅探有很多协议，其中最常见的是 MESI 协议。</p><p>MESI 协议，是一种写失效协议。在写失效协议中，只有一个 CPU 核心负责写入数据，其他的核心只是同步读取到这个写入。在一个 CPU 核心写入 cache 之后，会广播一个“失效”请求告诉所有其他的 CPU 核心，其他的 CPU 核心判断是否需要将相应的 cache line 标记为脏。</p><p>MESI 对应着 Cache Line 的四个标记：</p><ul><li><p>M：已修改，Modified，脏数据</p></li><li><p>E：独占，Exclusive；当前数据为该 cache 独占，写入不需要广播，如果接收到读取请求，则转变为 S 标记</p></li><li><p>S：共享，Shared；写入前需要进行广播，要求其他核心的 cache line 失效，再更新数据</p></li><li><p>I：已失效，Invalidated，脏数据</p></li></ul><p>其状态图如下</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=YTk0N2U2ODJjNzE0ZGJmNzU1YTk5NjEwOWRiOTk5MGRfUGtvSmhwR2RpWWk0b3p4NWhwYkx4UjNMSHZaeWZQY2hfVG9rZW46Ym94Y242OUc2UW1UYXNDbGVEVUVkVUlpTDdiXzE2NDMzNjI3Njg6MTY0MzM2NjM2OF9WNA" alt="img"></p><p>说明：c、c++、java 中均有 volatile 关键字，被 volatile 修饰的变量，要求写入时直接写入内存，读取时直接从内存读取，底层便依赖 MESI 协议实现。</p><h2 id="4-NUMA"><a href="#4-NUMA" class="headerlink" title="4. NUMA"></a>4. NUMA</h2><p>numa 非统一内存访问是一种关于多个 cpu 核心如何访问内存的架构模型，现在的 cpu 基本都是 numa 架构。</p><p>numa 架构简单而言就是一个 CPU 核心和一组内存插槽构成一个 node，每个核心可以访问自己 node下的内存，也可以访问其他 node 的内存，但是访问自己 node 内存的速度快于其他 node。</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=ODQzN2FmYjEwMzdhMDg4MWM2N2FkOGVlYzlkM2NmNmRfNGptc0JWTFNKVm1VSWVNQzR2RVVwMzA5VTFoTHlxQktfVG9rZW46Ym94Y25DT3dvWnRNSFdlWUxzelVEemo2UHNmXzE2NDMzNjI3Njg6MTY0MzM2NjM2OF9WNA" alt="img"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h2><ul><li><p><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></p></li><li><p><a href="https://time.geekbang.org/column/intro/100026001">极客时间：深入浅出计算机组成原理</a></p></li><li><p><a href="https://book.douban.com/subject/1230413/">深入理解计算机系统</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/Random-access_memory#Memory_wall">memory wall wikipedia</a></p></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1">程序员需要了解的计组知识(1): 二进制数</a>%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2">程序员需要了解的计组知识(2): CPU</a>%20CPU/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3">程序员需要了解的计组知识(3): 存储器</a>%20%E5%AD%98%E5%82%A8%E5%99%A8/)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员需要了解的计组知识(2): CPU</title>
      <link href="/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2)%20CPU/"/>
      <url>/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2)%20CPU/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>CPU 从功能上由控制器、运算器、寄存器和时钟四个部分组成，CPU 需要与内存、IO 设备配合工作。程序启动后，根据时钟信号，CPU 会从内存中不断读取指令和数据进行运算，控制器再根据运算结果进行控制。</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFiNzBjOWE0OTYxMTk5NGRkYWI3NjUwMjYyYTNiOWNfcnoxazNGb0xGSW1oalVjeTFIcDF1eUpMM2trRWNjTGJfVG9rZW46Ym94Y25GSEo5YTJYS0xLNUNyUDVjalNyY3RjXzE2NDMzNTY2Mjk6MTY0MzM2MDIyOV9WNA" alt="img"></p><p>这些指令就是最底层的机器语言，由 0 和 1 组成，程序员无法直接阅读，故引入汇编语言。汇编语言是 “给程序员看的机器码”，汇编语言与机器码一一对应，通常将汇编语言转换为机器码的过程称为汇编，将机器码转换为汇编语言称为反汇编。</p><p>对于程序员而言，我们只需要关注其中的寄存器，CPU 是寄存器的集合。</p><h2 id="2-程序控制"><a href="#2-程序控制" class="headerlink" title="2. 程序控制"></a>2. 程序控制</h2><h3 id="2-1-逻辑跳转"><a href="#2-1-逻辑跳转" class="headerlink" title="2.1 逻辑跳转"></a>2.1 逻辑跳转</h3><p>CPU 执行指令，是一条条按顺序执行的，并且有一个 PC 寄存器用来存储下一条要执行指令的地址，上文说到的 CPU 从内存中读取指令，便是根据 PC 寄存器中存放的地址，从内存中加载指令执行。</p><p>汇编语言中包含 jmp、jne、goto 等指令，会直接或者根据条件间接改变 PC 寄存器的值，达到跳转代码的效果。平常代码中的 if else、for/while 循环等会被编译成 jmp 等指令，实现逻辑控制的效果。</p><h3 id="2-2-函数调用"><a href="#2-2-函数调用" class="headerlink" title="2.2 函数调用"></a>2.2 函数调用</h3><p>函数调用也是通过设置 PC 寄存器为函数的地址实现的，不过与逻辑跳转不一样的地方在于，函数调用不是使用 jmp 等指令，而是采用 call 和 return 两个指令。</p><p>call 指令会将函数执行后的下一条指令地址存放在栈中，而 return 指令会将栈顶的指令地址给 PC 寄存器赋值。</p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=YmE1OWRlZjY3OTVlOTc1MDFlMTFiY2VjZjM3NWVmYmZfTlpWWnVRbXRyS1I1WGlsVEF2N0R0ZnpaWDFDN1REOElfVG9rZW46Ym94Y25hMEtIekp1Z3d1VU9nZmRQeVN5WThjXzE2NDMzNTY2Mjk6MTY0MzM2MDIyOV9WNA" alt="img"></p><p><img src="https://kya7nvdl65.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQ3ZjcxNDg5MGJiNjc5ODQwYTUxYzM5OTI5ZmFhZmRfTkdsd0s0aDdBdnBiSkNodWlKVmN1ZVpsdUdMVUlQcnhfVG9rZW46Ym94Y25uRzZTWjRNR1JrZTBsalptZmVtTUFoXzE2NDMzNTY2Mjk6MTY0MzM2MDIyOV9WNA" alt="img"></p><h2 id="3-堆和栈"><a href="#3-堆和栈" class="headerlink" title="3. 堆和栈"></a>3. 堆和栈</h2><p>寄存器只能存放很少量的数据，大多数时候，CPU 要指挥寄存器跟内存交换数据。所以，除了寄存器，还必须了解内存怎么储存数据。</p><p>程序运行时，OS 会预先分配一段内存，用于存储数据。</p><p>对于动态的内存占用（例如 C 语言中的 malloc），会从预先分配的内存中划分出一部分，这种用户主动请求而划分的内存，称之为堆，堆的一个特点是不会自动释放，依赖用户或者垃圾收集器进行回收。</p><p>函数调用需要在内存中创建一个帧，用于存储函数的内部变量，例如</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 test 函数前，需要将 x 先存放在内存之中，而函数执行过程中变量 a 和 b 也需要存储在帧中。在函数调用结束之后，帧的内存会被自动回收，而这块内存称之为栈。</p><p>说明：</p><ul><li>数据结构中的堆是用数组实现的二叉树，其父节点的值比所有子节点的大/小。本节讨论的堆主要针对内存而言，两者没有实质联系</li><li>在日常交流或者其他技术文章中会存在 堆栈 这个概念，而 堆栈 = 栈</li></ul><h2 id="4-一些科普"><a href="#4-一些科普" class="headerlink" title="4. 一些科普"></a>4. 一些科普</h2><ul><li>乱序执行：为了提高运行效率，CPU 不严格按照指令出现的顺序执行，例如下面的计算，d 依赖 a 的结果，必须在  a = b + c 允许之后计算，但 x 与 a、d 没有关系，x 的计算可能在 a、d 计算之前，也可能在 a、d 计算之后。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = b + c</span><br><span class="line">d = a * c</span><br><span class="line">x = y * z</span><br></pre></td></tr></table></figure><ul><li>指令集架构：分为复杂指令集 CISC 和精简指令集 RISC。RISC 指令固定长度，代表是 ARM；CISC 指令不固定长度，代表是 Intel</li><li>x86 架构：狭义的 x86 架构指只支持 32 位的 Intel/AMD 的 CPU；x86_64 架构又称 x64 架构，支持 32 位和 64 位，指令集与 x86 兼容，目前绝大部分的 Intel/AMD CPU 属于这个体系；广义的 x86 架构，泛指 x86 + x64。程序员谈论的 x86 一般指广义上的，即 Intel/AMD 的 CPU。</li><li>超线程：Intel 的技术商标，更广泛的概念叫 同步多线程 Simultaneous Multithreading。不同于软件级别的多线程，超线程将一个物理 CPU 分成两个逻辑部分 ，例如在 CPU 有两份相同的寄存器，每份寄存器存储一个任务的运行环境，在一个任务无法进行时可以极快切换到另一个任务运行。我们平时看到的 8 核 16 线程即属于超线程的范畴。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></li><li><a href="https://time.geekbang.org/column/intro/100026001">极客时间：深入浅出计算机组成原理</a></li><li><a href="https://zh.wikipedia.org/wiki/X86-64">x86-64 wikipedia</a></li><li><a href="http://www.ruanyifeng.com/blog/2018/01/assembly-language-primer.html">汇编语言入门教程 阮一峰</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1">程序员需要了解的计组知识(1): 二进制数</a>%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2">程序员需要了解的计组知识(2): CPU</a>%20CPU/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3">程序员需要了解的计组知识(3): 存储器</a>%20%E5%AD%98%E5%82%A8%E5%99%A8/)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员需要了解的计组知识(1): 二进制数</title>
      <link href="/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1)%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
      <url>/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1)%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h2><p>计算机内部由集成电路 IC 这种电子部件构成的，IC 的一个引脚有 0V 或 5V 两个状态，这个特性决定了计算机的信息采用二进制数来处理。</p><p>计算机处理信息的最小单位是位，位的英文 bit 是 binary digit 的缩写。由于 CPU 的位数一般是 8 的倍数，将 8 位二进制数称为一个字节 byte。</p><h2 id="2-补码"><a href="#2-补码" class="headerlink" title="2. 补码"></a>2. 补码</h2><p>正整数的二进制和十进制的转换不做具体介绍，这里主要介绍整数在计算机的表示：补码。</p><p>二进制数表示负数时，一般将最高位作为符号使用。假设整数用 8 位来表示，一个直观想法是 1 的二进制为 <code>0000 0001</code>，那么 - 1 的二进制为  <code>1000 0001</code>，这种符合人脑运算的表示称为原码。</p><p>但是原码对于计算机运算存在一定问题，例如 1+ (-1) 的二进制结果为 <code>1000 0010</code>，按照原码表示为 -2，与实际运算不相符。 针对运算问题引入补码的概念，补码的思想是使用正数来表示负数。</p><p>要计算补码之前，先要介绍一下反码，正数的反码等于自身，负数的反码在其原码的基础上，符号位不变，其余各位取反，例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反</span><br><span class="line">[-1] = [10000001]原 = [11111110]反</span><br></pre></td></tr></table></figure><p>反码的应用是用于计算补码，正数的补码等于自身，负数的补码等于其反码 + 1，例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[+1] = [00000001]原 = [00000001]反 = [00000001]补</span><br><span class="line">[-1] = [10000001]原 = [11111110]反 = [11111111]补</span><br></pre></td></tr></table></figure><p>补码虽然直观不易理解，但逻辑十分严谨，例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + (-1) = 00000001 + 11111111 = 1 0000 0000 = 0(舍弃溢出位)</span><br></pre></td></tr></table></figure><p>x 位有符号二进制数能表示的范围为 <script type="math/tex">-2^{x}</script> 到 <script type="math/tex">2^{x} -1</script>，在日常开发中，需要注意溢出问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">2147483647</span>;</span><br><span class="line">        a++;</span><br><span class="line">        System.out.println(a); <span class="comment">// -2147483648</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li><p>计算机使用补码来表示整数</p></li><li><p>正数的原码、反码、补码都等于自身</p></li><li>负数的补码 = 其绝对值的反码 + 1</li></ul><h2 id="3-浮点数"><a href="#3-浮点数" class="headerlink" title="3. 浮点数"></a>3. 浮点数</h2><h3 id="3-1-定点数"><a href="#3-1-定点数" class="headerlink" title="3.1 定点数"></a>3.1 定点数</h3><p>日常生活中并不是所有数据都是整数，那么如何用二进制表示实数呢？</p><p>假如用 32 bit 表示实数，一个直观的想法是每 4 bit 表示 0 - 9 的数字，并且规定最右边的 2 个 0 - 9 的整数当成小数部分，例如 <code>0000 0000 0000 0000 0000 0011 0001 0100</code> 表示为 3.14，这种表示称为定点数。定点数表示实数简单易读，但是存在以下问题：</p><ul><li>浪费位数。4 bit 能够表示 0 - 15 的数字，只使用了其中 0 - 9 的部分</li><li>无法同时表示很大和小数部分很精确的数字。由于定点只有一个，小数部分越精确，整数部分的范围就小了，如果程序中的同时存在很大和小数部分很精确的数，便无法用定点数表示</li></ul><h3 id="3-2-浮点数"><a href="#3-2-浮点数" class="headerlink" title="3.2 浮点数"></a>3.2 浮点数</h3><p>针对上述定点数的问题，引入了浮点数的概念，IEEE 对浮点数定义了两个基本格式，分为单精度 32 bit 和双精度 64 bit，这里以单精度进行介绍。</p><p>单精度浮点数可以分为三部分：</p><ul><li>符号位，1 bit，1 表示正数，0 表示负数，称为 s</li><li>指数位，8 bit，称为 e。8 bit 能够表示的无符号整数范围为 0 - 255，将其中的 1 - 254 映射到 -126 -127（不包含 0），例如 -126 为区间内第 1 个整数，表示为 <code>0000 0001(1)</code>；-1 为第 126 个，表示为<code>0111 1110(126)</code></li><li>有效位，23 bit，称为 f。每一位依次表示  <script type="math/tex">2^{-1}</script>，<script type="math/tex">2^{-2}</script>、<script type="math/tex">2^{-3}</script>  … 例如 <script type="math/tex">0.5 = 2^{-1}</script>，表示为 1000……，<script type="math/tex">0.75 = 2^{-1} + 2^{-2}</script>​，表示为 11000….</li></ul><p><img src="单精度浮点数.png" alt="alt"></p><p>浮点数即可表示为</p><script type="math/tex; mode=display">(-1)^s \times (1 + f) \times 2^e</script><p>这里给出两种计算方法：</p><h5 id="计算方法1"><a href="#计算方法1" class="headerlink" title="计算方法1"></a>计算方法1</h5><p>0.5 可以表示为</p><script type="math/tex; mode=display">0.5 = (-1)^0 \times 1.0 \times 2^{-1}</script><p>即 s = 0，e = -1（需要用 126 表示），f = 0。0.5 的浮点数二进制表示即为 <code>0-01111110-0000000 00000000 00000000</code>。</p><p>1.5 可以表示为</p><script type="math/tex; mode=display">1.5 = (-1)^0 \times 1.5 \times 2^0</script><p>即 s = 0，e = 0（需要为 127 表示），f = 0.5（2 的 -1 次方，二进制表示第一位为 1，其余为 0），二进制表示为 <code>0-011111111-0000000000000000000000</code></p><p>细心的同学会发现上述公式无法表示数字 0，故 IEEE 规定当 e 和 f 的比特位都全为 0 时，表示数字 0。</p><h5 id="计算方法2"><a href="#计算方法2" class="headerlink" title="计算方法2"></a>计算方法2</h5><p>另一种对浮点数的计算方式是对于实数 x，确定指数 e 使  <script type="math/tex">2^{e} \le x < 2^{e+1}</script>，将该区间分为  <script type="math/tex">2^{23}</script> 份，f 的整数表示 x 在的小区间的位置（以 0 开始）。</p><p>对于实数 0.5，确定指数 e 为 -1，并且 0.5 位于第 0 个小区间，二进制表示为  <code>0-01111110-0000000 00000000 00000000</code>。</p><p>对于实数 1.5，确定指数 e 为 0, 将 <script type="math/tex">2^{0}</script> ~ <script type="math/tex">2^{1}</script> 分为 <script type="math/tex">2^{23}</script> 个小区间，1.5 位于第   <script type="math/tex">2^{22}</script> 个小区间，二进制表示为 <code>0-01111111-10000000000000000000000</code>。</p><h3 id="3-3-浮点数精度丢失"><a href="#3-3-浮点数精度丢失" class="headerlink" title="3.3 浮点数精度丢失"></a>3.3 浮点数精度丢失</h3><p>浮点数的精度损失主要来源两方面，一方面是实数本身无法精确表示，例如数字 1.1 ，确定指数 e 为 0，将 1 - 2 划分 $2^{23}$ 个小区间后，1.1 不在区间的两端，无法进行精确表示。</p><p>另一方面来自运算可能导致的损失，浮点数进行加法运算的规则很简单：先对齐，再计算。</p><ul><li>先将两个浮点数的指数位变成一样的，选择更大的指数位</li><li>进行加法计算</li></ul><p>例如数字 0.5，e = -1, f = 0；0.125，e = -3, f = 0，计算 0.5 + 0.125 时，首先将两个指数位统一为较大的 -1，其中 0.125 的有效数位 1.00 要右移两位，变为 0.01，两者的有效数位相加为 1.01，而指数位是 -1，这样便得到相加后的结果。</p><p>可以发现，指数位较小的数需要进行右移运算，会丢弃最右侧的有效位，32 位浮点数的有效长度为 23 位，如果两个浮点数大小差 <script type="math/tex">2^{24}</script> 倍，相加之后，结果不会变化，即所谓的大数吃小数问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> a = <span class="number">20000000.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> b = <span class="number">1.0f</span>;</span><br><span class="line">        <span class="keyword">float</span> c = a + b;</span><br><span class="line">        System.out.println(<span class="string">&quot;c is &quot;</span> + c); <span class="comment">// c is 2.0E7</span></span><br><span class="line">        <span class="keyword">float</span> d = c - a;</span><br><span class="line">        System.out.println(<span class="string">&quot;d is &quot;</span> + d); <span class="comment">// d is 0.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题可以通过 <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan-Summation</a> 算法解决，此处不进行具体介绍，感兴趣的可以自行搜索。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/26365491/">程序是怎样跑起来的</a></li><li><a href="http://www.ruanyifeng.com/blog/2010/06/ieee_floating-point_representation.html">浮点数的二进制表示</a></li><li><a href="https://en.wikipedia.org/wiki/IEEE_754">IEEE 754</a></li><li><a href="https://time.geekbang.org/column/intro/100026001">极客时间：深入浅出计算机组成原理</a></li><li><a href="https://book.douban.com/subject/30333948/">码出高效: Java开发手册</a></li><li><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan summation algorithm</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><ul><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(1">程序员需要了解的计组知识(1): 二进制数</a>%20%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(2">程序员需要了解的计组知识(2): CPU</a>%20CPU/)</p></li><li><p><a href="https://strokebun.github.io/2022/01/28/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%84%E8%AE%A1%E7%BB%84%E7%9F%A5%E8%AF%86(3">程序员需要了解的计组知识(3): 存储器</a>%20%E5%AD%98%E5%82%A8%E5%99%A8/)</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机组成原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式相关理论</title>
      <link href="/2022/01/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/"/>
      <url>/2022/01/26/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="1-CAP"><a href="#1-CAP" class="headerlink" title="1. CAP"></a>1. CAP</h2><p>CAP 是分布式系统的三个指标：</p><ul><li>Consistency：一致性</li><li>Availability：可用性</li><li>Partition Tolerance：分区容错性</li></ul><h3 id="1-1-介绍"><a href="#1-1-介绍" class="headerlink" title="1.1 介绍"></a>1.1 介绍</h3><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>一致性指在更新操作完成之后，所有节点在同一时间的数据完全一致，不存在中间状态。</p><p>数据一致性可分为：</p><ul><li>强一致性：任意时刻客户端获取到的各个节点数据都是一致的</li><li>最终一致性：允许存在中间状态，但要求经过一段时间之后，数据最终是一致的</li><li>弱一致性：允许部分数据不一致</li></ul><p>注：数据库事务也有一致性的概念，这个一致性指系统从一个正确的状态到另一个正确的状态；而分布式场景中的一致性指各副本数据之间的关系。两个一致性没有任何联系。</p><h4 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h4><p>可用性要求系统提供的服务必须一致是可用的状态，对于用户的每一个请求能在有限的时间内返回正常的结果。</p><p>其两个指标：</p><ul><li>有限时间：系统的响应时间必须是一个用户可接受的值</li><li>正常结果：无论操作成功还是失败，系统能返回一个用户能够理解的响应。例如返回一个系统内存错误 OOM 便不是一个正常结果 </li></ul><h4 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h4><p>系统在遇到网络分区故障时，仍然能够保证对外提供服务。</p><p>网络分区是系统中存在多个子网络，子网络之间通信异常，但内部通信是正常的，从而使系统被分为若干个区域。</p><h3 id="1-2-CAP-的应用"><a href="#1-2-CAP-的应用" class="headerlink" title="1.2 CAP 的应用"></a>1.2 CAP 的应用</h3><p><img src="cap.png" alt="alt"></p><p>在分布式系统中，P 是基本条件，因为分区是一种错误，它是必然会发生的，而不是一个可选项，如果不能保证 P，那么出现分区，系统便无法工作，这是无法接受的。所以，对于分布式系统，我们只能选择  C 或者 A。</p><h4 id="CP系统"><a href="#CP系统" class="headerlink" title="CP系统"></a>CP系统</h4><p>系统发生分区故障之后，客户端的任何请求都卡死或者超时，但是系统的每个节点都鞥你返回一致的数据。</p><h4 id="AP系统"><a href="#AP系统" class="headerlink" title="AP系统"></a>AP系统</h4><p> 系统发生分区故障之后，客户端能够访问系统，但是不能保证获取到的数据是最新的数据。</p><h3 id="1-3-CAP-的不足"><a href="#1-3-CAP-的不足" class="headerlink" title="1.3 CAP 的不足"></a>1.3 CAP 的不足</h3><ul><li>CAP 理论没有考虑网络延迟的问题，认为各节点的数据同步是瞬时的，与现实不符。这导致分布式大多选用 AP 方式</li><li>CAP 只是一种状态的描述，对于工程领域以及系统设计并没有帮助</li></ul><h2 id="2-BASE定理"><a href="#2-BASE定理" class="headerlink" title="2. BASE定理"></a>2. BASE定理</h2><p>由于 CAP 的种种不足，ebay 的架构师提出了 BASE 理论，是对 AP 的延伸。</p><p>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终⼀致性）三个短语的缩写，核心思想是即使无法做到强一致性，但可以采用适合的方式达到最终一致性。</p><h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>基本可用指系统出现故障之后，系统仍是可用的，但允许损失部分可用性，例如</p><ul><li>响应时间增加</li><li>服务降级：流量高峰时，屏蔽一些功能维持系统稳定</li></ul><h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>软状态允许系统中的数据存在中间状态，这些中间状态不会影响系统的可用性，即允许不同节点的数据同步存在延迟</p><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性要求数据副本在一定时间之后，能够达到一致的状态。</p><p>最终一致性可分为</p><ul><li>因果一致性：进程 A 更新数据后通知进程 B，进程 B 对包含该项数据的范围都是 A 更新后的值</li><li>单调读：如果之前读到新的数据，后续读取不会得到更旧的数据。单调读一致性保证强于最终一致性，弱于强一致性</li><li>单调写：系统需要保证来⾃同⼀个进程的写操作被顺序执行</li><li>读写一致性：用户获取到的自身修改是最新的，其他用户的更新可能稍后才会看到</li></ul><h2 id="3-PACELC理论"><a href="#3-PACELC理论" class="headerlink" title="3. PACELC理论"></a>3. PACELC理论</h2><p>分布式环境由于以下原因不存在绝对的强一致性：</p><ul><li>信息传播需要时间，有时间就有延迟，有延迟就会产生不一致</li><li>在网络中传递的信息可能是过时的</li><li>网络是不可靠的</li></ul><p>我们日常提到的强一致性，是从观察者的角度，即客户端获取的数据是一致的。PACELC 理论是 CAP 的拓展，其中 C、A、P 没有变化，而是引入了 Latency（延迟 L）和 E （Else）。</p><p><img src="pacelc.png" alt="alt"></p><p>也就是说，当分区 P 出现时，需要在可用性 A 和一致性 C 中权衡；而当 P 出现时，需要在延迟 L 和 C 中做权衡。换句话说，达成一致的节点越多，响应速度越慢。</p><p> PACELC 的作用是提供以下指导意义：</p><ul><li>半同步复制：例如 MySQL 主从架构，master节点只要收到一个 slave 节点写入磁盘成功的响应，即可将结果返回给客户端，减少响应时间。这样，即使 master 节点挂了，也有一个 slave 节点的数据是完整的；</li><li>主从分离：不要求主从之间的强一致性事务约束，从节点的数据可以存在一小段时间延迟。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/30329536/">数据密集型应用系统设计</a></li><li><a href="https://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a></li><li><a href="https://www.zhihu.com/question/31346392">如何理解数据库事务中的一致性的概念?</a></li><li><a href="https://www.zhihu.com/question/54105974/answer/1643846752">CAP中的P到底是个什么意思</a></li><li><a href="https://en.wikipedia.org/wiki/Eventual_consistency">Eventual consistency</a></li><li><a href="https://book.douban.com/subject/30443578/">软件架构设计 大型网站技术架构与业务架构融合之道</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试常见智力题</title>
      <link href="/2022/01/26/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
      <url>/2022/01/26/%E9%9D%A2%E8%AF%95%E5%B8%B8%E8%A7%81%E6%99%BA%E5%8A%9B%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>现在的互联网面试中，除了技术问题以外，还会出现一些智力题考验面试者的思维和应变能力，如果没提前看过在面试时并不容易做出来。本文主要介绍面试中常出现并且具有一定难度的智力题。</p><p>注：倒水问题、用天平找重球、烧绳记录时间、脑筋急转弯等性质题目较为简单，不在本文介绍。</p><h3 id="1-赛马问题"><a href="#1-赛马问题" class="headerlink" title="1. 赛马问题"></a>1. 赛马问题</h3><p>问题：25 匹马，5 个赛道，每次只能同时有 5 匹马跑，没有计时器，最少比赛几次选出前 3 名的马？</p><p>解答：</p><ul><li>将 25 匹马分为 1-5 组，进行 5 次赛马，得到每组的排名</li><li>根据排名将马重新划分，分为 A - E组，即原先 1-5 各组排名第一的马分到 A 组，排名第二的马分到 B 组，依次类推。A 组进行一次赛马，第一名即为 25 匹马的第一名</li><li>所有马的第二名和第三名只可能在 A 组的第二、三名，B 组的第一、二名，C 组的第一名，共 5 匹马。让这 5 匹马再进行一次赛马，即可得到二三名</li></ul><p>综上，共需要 5 + 1 + 1 = 7 次赛马。</p><p>如果是选出前 5 名的马，最少需要 8 次，详细可见 <a href="https://www.iteye.com/blog/hxraid-662643">25匹马的角逐</a></p><h3 id="2-病狗问题"><a href="#2-病狗问题" class="headerlink" title="2. 病狗问题"></a>2. 病狗问题</h3><p>问题：村里住着 100 户人家，每家都养了一条狗。已知这些狗中有病狗，疾病不会传染，每家都只能通过观察别人家的狗是否有病去判断自己家的狗，一旦判断出自家的狗有病，就必须打死自己家的狗（每家只能打自己的狗）。第一天过去没有枪声，第二天过去仍然没有枪声，第三天傍晚同时响起一片枪声，病狗全都死了，问村子里有几条病狗？</p><p>解答：</p><ul><li>假如有 1 只病狗。那么它的主人观察其他狗都没有病之后，便会知道自己的狗是病狗，第一天过后会出现枪声，与题意相背</li><li>假如有 2 只病狗。第一天病狗的主人观察发现其它 49 只狗中有 1 只病狗，因为不知道确切病狗的数量，所以都认为自己的狗没病；第一天过后两个主人发现没有狗被杀，说明还存在其它病狗，那么只能是自家的狗，第二天过后应该出现枪声，与题意相背</li><li>假如有 3 只病狗。根据假设2，到了第三天，病狗的主人发现其它两方的病狗还活着，说明存在 2 只以上的病狗，那么只能是自家的狗，故出现枪声杀死所有病狗，与题意符合，故共有 3 只病狗</li></ul><p>推论：x 天出现枪声，则村里共有 x 只病狗。</p><h3 id="3-找毒药问题"><a href="#3-找毒药问题" class="headerlink" title="3. 找毒药问题"></a>3. 找毒药问题</h3><p>问题：x 瓶药，有⼀瓶有毒，用老鼠来喝药，喝到有毒的一天后死亡。⼀天内至少需要多少只老鼠才能检测到哪些有毒？</p><p>解答：</p><p>因为老鼠只有死亡和存活两种状态，设死亡 = 1, 存活 = 0，对老鼠和药进行编号后，根据药的二进制对老鼠喂药。一周后根据死亡和存活老鼠的二进制表达即可知道有毒的药水，故需要的老鼠数量为 ceil(log2(x))，ceil 表示向上取整。</p><p>例如有 8 瓶药水，编号为 0 - 7， 则一共需要 3 只老鼠，老鼠编号为 1- 3，将 4、5、6、7号药水混合到一起喂给老鼠1，将 2，3，6，7号药水混合喂给老鼠2，将1、3、5、7药水混合喂给老鼠3，观察老鼠是否中毒。假如 1 号老鼠和 3 号老鼠死亡，那么有毒的药水编号为 5 （二进制为 101）。</p><h3 id="4-找变质的药"><a href="#4-找变质的药" class="headerlink" title="4. 找变质的药"></a>4. 找变质的药</h3><p>问题：有 10 瓶药，每瓶有10粒药，其中有一瓶是变质的。好药每颗重 1 克，变质的药每颗比好药重 0.1 克。问怎样用天秤称一次找出变质的那瓶药？</p><p>解答：</p><ul><li>将 10 瓶药编号 1 - 10</li><li>每瓶药取编号数量粒药，第 1 瓶取 1 粒，第 2 瓶取 2 粒，依次类推。如果药物没有变质，那么应该为 55 克，此时多出零点几克，哪瓶药就是变质的，例如现在为 55.5 克，那么 5 号药就是变质的。</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://www.iteye.com/blog/hxraid-662643">25匹马的角逐</a></li><li><a href="https://zhuanlan.zhihu.com/p/395132338">路人张 字节面试常考智力题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智力题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(4)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍行为型的设计模式，主要解决的是类或对象的之间的交互问题，常见的有 观察者模式，模板方法模式、责任链模式。</p><h2 id="1-观察者模式"><a href="#1-观察者模式" class="headerlink" title="1. 观察者模式"></a>1. 观察者模式</h2><p>观察者模式也称 发布-订阅 模式，在 GoF 的《设计模式》中对它的定义是，在对象之间定义一个一对多的依赖，当对象状态变化时，所有依赖都会收到通知。</p><p>一般而言，被依赖的对象称为被观察者（Observable），依赖的对象叫做观察者（Observer）。</p><p>现有一个气象台的例子，用户选择订阅气象台的数据，当天气参数发生变化时，需要通知给所有用户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> pressure, <span class="keyword">double</span> humidity)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被观察者接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt; observers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据变化，通知每个观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        nofityObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> pressure, <span class="keyword">double</span> humidity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        dataChange();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除观察者</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nofityObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer o : observers) &#123;</span><br><span class="line">            <span class="comment">// 调用观察者对应的接口</span></span><br><span class="line">            o.update(temperature, pressure, humidity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察者的应用非常广泛，小到代码层面的解耦，大到系统层面的解耦（例如 MQ），都有这种模式的影子。</p><h2 id="2-模板方法模式"><a href="#2-模板方法模式" class="headerlink" title="2. 模板方法模式"></a>2. 模板方法模式</h2><p>模板方法模式在一个方法中定义一个骨架，并将某些步骤推迟到子类中实现。其实现模板如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... </span></span><br><span class="line">        method1();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板方法模式的主要作用：</p><ul><li>复用，不可变的部分交由父类实现，将可变部分交由子类实现</li><li>拓展，通过一系列 hook 方法，交由用户实现自定义拓展</li></ul><p>jdk 中大量使用了模板方法模式，例如 concurrent 的包大量类继承了 AQS，重写 tryAcquire 等方法即可实现并发工具；HashMap 留下了 afterNodeInsertion 等方法，LinkedHashMap 继承 HashMap 并重写这些方法，在保留  HashMap 的功能基础上可实现 LRU 算法。</p><h2 id="3-责任链模式"><a href="#3-责任链模式" class="headerlink" title="3. 责任链模式"></a>3. 责任链模式</h2><p>GoF 对责任链模式的定义是，将请求的发送和接收解耦，让接收对象都有机会处理这个请求，将接收对象形成一条链，并沿着链条传递请求，直到某个接收对象能够处理为止。</p><p>GoF 给出的定义中，如果某个处理器能够处理请求，将不会向下传递，日常使用也有变体，请求会被所有处理器处理一遍，不会中止。</p><p>下面是责任链模式的通常实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">implements</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> heandled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">implements</span> <span class="title">IHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> heandled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(IHandler handler)</span> </span>&#123;</span><br><span class="line">        handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (IHandler handler : handlers) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> handled = hander.handle();</span><br><span class="line">            <span class="comment">// 根据业务需要是否提前中止</span></span><br><span class="line">            <span class="keyword">if</span> (handled) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>netty 中的编解码使用了责任链模式，用户可以在入和出的方法定义自己的编解码器，对数据进行加工。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在 GoF 的《设计模式》中，存在 23 种设计模式，系列文章没有全部介绍，这不代表这些模式不重要，一是由于迭代器模式等在日常开发中较少自己实现，二是作者能力有限，很多模式未能确定最好的使用场景，只能选择最常用的一些模式进行介绍。</p><p>设计模式并非银弹，遇到某个场景，不能机械把模式插入，同时也要考虑选择模式带来的代价。有人说到设计模式学习的尽头是心中无模式，但使用处处是模式，如同《神雕侠侣》中的独孤求败，重剑无锋，大巧不工，四十岁前恃之横行天下，四十岁後，不滞於物，草木竹石均可为剑，自此精修，渐进於无剑胜有剑之境。希望你也能成为程序员中的独孤求败。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://book.douban.com/subject/1052241/">设计模式</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1">小话设计模式(1)</a>/)</p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2">小话设计模式(2)</a>/)</p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3">小话设计模式(3)</a>/)</p>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(3)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍结构型的设计模式，结构型模式总结了类或对象组合在一起的结构，常见的有代理模式、装饰器模式、适配模式、门面模式。</p><h2 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h2><p>代理模式即在不改变原始类（被代理类）的情况下，引入代理类给原始类附加功能。主要分为静态代理和动态代理。</p><h3 id="1-1-静态代理"><a href="#1-1-静态代理" class="headerlink" title="1.1 静态代理"></a>1.1 静态代理</h3><p>静态代理要求代理类和被代理类实现同样的接口，在调用相同的接口时，在代理类中进行业务增强。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="function">UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 业务逻辑...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">  <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">(UserController userController)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.userController = userController;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">    UserVo userVo = userController.login(telephone, password);</span><br><span class="line">    <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">    RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">&quot;login&quot;</span>, responseTime, startTimestamp);</span><br><span class="line">    metricsCollector.recordRequest(requestInfo);</span><br><span class="line">    <span class="keyword">return</span> userVo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">IUserController userController = <span class="keyword">new</span> UserControllerProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>上述代码在原业务逻辑中引入性能监控，UserControllerProxy 也实现了 IUserController 接口，并在 login 业务中添加了性能监控。</p><p>静态代理实现简单，但缺点是需要为每一个原始类都需要创建一个代理类，造成代码膨胀。 </p><h3 id="1-2-动态代理"><a href="#1-2-动态代理" class="headerlink" title="1.2 动态代理"></a>1.2 动态代理</h3><p>为了解决静态代理类膨胀的问题，引入了动态代理。动态代理不事先编写代理类，而是在运行时动态创建代理类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsCollectorProxy</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MetricsCollectorProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt;[] interfaces = proxiedObject.getClass().getInterfaces();</span><br><span class="line">    DynamicProxyHandler handler = <span class="keyword">new</span> DynamicProxyHandler(proxiedObject);</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(proxiedObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object proxiedObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxiedObject)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.proxiedObject = proxiedObject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">      Object result = method.invoke(proxiedObject, args);</span><br><span class="line">      <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">      <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">      String apiName = proxiedObject.getClass().getName() + <span class="string">&quot;:&quot;</span> + method.getName();</span><br><span class="line">      RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">      metricsCollector.recordRequest(requestInfo);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MetricsCollectorProxy proxy = <span class="keyword">new</span> MetricsCollectorProxy();</span><br><span class="line">IUserController userController = (IUserController) proxy.createProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>通过动态代理，我们就得到了一个对于所有实现  IUserController 接口都能实现监控的效果。</p><p>动态代理在 RPC、监控、鉴权以及各种框架中被广泛使用，但也存在一定的性能损耗，在日常业务开发中选择静态代理还是动态代理，需要在性能和代码膨胀中进行权衡。</p><h2 id="2-装饰器模式"><a href="#2-装饰器模式" class="headerlink" title="2. 装饰器模式"></a>2. 装饰器模式</h2><p>装饰器模式允许向一个现有对象添加新的功能，同时不改变新的结构。</p><p>Java IO 中 InputStream 是一个接口，FileInputStream 用来读取文件，BufferedInputStream 支持缓存，可以提高速度。当我们带缓存读取文件时，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">InputStream bis = <span class="keyword">new</span> BufferedInputStream(is);</span><br></pre></td></tr></table></figure><p>可以看到，使用时需要先创建一个 FileInputStream，再将它传给 BufferedInputStream 才能使用，为什么不直接继承实现一个带缓存的文件流 BufferedFileInputStream呢？如果 InputStream 实现类较少的话，那我们直接继承是可以接受的，但是 InputStream 存在大量实现类，如果我们想给每种实现都带缓存，那么需要对每个实现类进行继承，产生大量派生类，类继承结构变得特别复杂。</p><p>设计原则中有 ”组合优于继承“，我们可以使用组合替代继承，引入装饰器模式，下面是 Java IO 流的类似实现思路。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">        <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Buffer size &lt;= 0&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            fill(); <span class="comment">// fill是读入缓冲区的代码</span></span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123; </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in; </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">this</span>.in = in; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//...实现读取基本类型数据的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferedInputStream 和  DataInputStream 继承了相同的 InputStream 父类，可以对原始类嵌套多个装饰器类，当我们需要某个功能时，只需要装饰（嵌套）对应功能的实现类即可。</p><p>通过装饰器模式，我们免除了复杂的继承机制，并且可以动态添加和撤销功能。</p><h2 id="3-适配模式"><a href="#3-适配模式" class="headerlink" title="3. 适配模式"></a>3. 适配模式</h2><p>适配模式目的是将不兼容的接口转换为可兼容的接口，让原先接口不兼容的类能够组合工作。生活中常见的例子是各种 USB 转接头，让原本无法直接连接的设备能够通讯。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeCToUSB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleConnect</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双端typeC的充电线</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;连接TypeC充电&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// USB转接</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">TypeCToUSB</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TypeC typeC;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(TypeC typeC)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeC = typeC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleConnect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        typeC.connect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adapter adapter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">power</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adapter.handleConnect();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们便实现使用双端 typeC 设备与电脑连接充电。</p><p>适配模式并不复杂，在日常开发中使用适配模式的场景如下：</p><ul><li>封装有缺陷的接口设计，抽象出更好的接口设计</li><li>兼容老版本接口</li><li>当依赖的外部系统被替换时，通过适配模式减少代码改动</li></ul><h2 id="4-门面模式"><a href="#4-门面模式" class="headerlink" title="4. 门面模式"></a>4. 门面模式</h2><p>GoF 中对门面模式的定义是，为子系统提供一组统一的接口，定义高层的接口让子系统更易使用。</p><p>假设有系统 A，提供 a、b、c、d 四个接口，另一个系统 B 想要使用 a、b、d 接口，利用门面模式，我们提供一个包含三个接口的 x 接口，供 B 使用。</p><p>那为什么需要 x 接口呢，直接调用 a、b、d 不可以吗？</p><p>如果 A 是我们平常的后端系统， 而 B 是前端，A 与 B 之间需要通过网络通信。那么如果直接调用 3 个接口，会产生三次网络通信，而调用 x 接口，只需要一次通信，为了加快响应速度，提高用户体验，我们应该尽可能减少网络通信的次数。</p><p>接下来举一个家庭影院的例子，家中有空调、影碟机和爆米花机，我们希望有一个上层系统进行控制，开启/关闭系统后自动打开/关闭所有设备。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HomeFacade</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DVDPlayer dvdPlayer;</span><br><span class="line">    <span class="keyword">private</span> Popcorn popcorn;</span><br><span class="line">    <span class="keyword">private</span> AirCondition airCondition;</span><br><span class="line">    <span class="comment">// 省略构造函数...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ready</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.on();</span><br><span class="line">        popcorn.on();</span><br><span class="line">        airCondition.on();</span><br><span class="line">        airCondition.down();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        dvdPlayer.pause();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        airCondition.off();</span><br><span class="line">        popcorn.off();</span><br><span class="line">        airCondition.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>概括而言，门面模式做接口整合，解决是多接口调用带来的问题。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://www.bilibili.com/video/BV1G4411c7N4?from=search&amp;seid=17614039806864782413&amp;spm_id_from=333.337.0.0">尚硅谷：设计模式</a></li><li><a href="https://www.runoob.com/design-pattern/decorator-pattern.html">装饰器模式 菜鸟教程</a></li><li><a href="https://book.douban.com/subject/1052241/">设计模式</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1">小话设计模式(1)</a>/)</p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2">小话设计模式(2)</a>/)</p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4">小话设计模式(4)</a>/)</p>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(2)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2)/</url>
      
        <content type="html"><![CDATA[<p>本文主要介绍常见的创建型设计模式，主要有单例、工厂和建造者模式。</p><h2 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h2><p>单例模式是一个很容易理解的概念，要求一个类只能创建一个对象，并提供全局访问点，常用场景是存储配置信息或者唯一高消耗资源。</p><p>实现单例模式的主要考虑点为：</p><ul><li>构造函数外部无法访问</li><li>对象创建时线程安全</li><li>是否需要延迟加载</li></ul><p>具体实现主要有两种方式，饿汉式和懒汉式，下文将会以一个 id 生成器进行举例。</p><h3 id="1-1-饿汉式"><a href="#1-1-饿汉式" class="headerlink" title="1.1 饿汉式"></a>1.1 饿汉式</h3><p>饿汉式实现即在类加载之后，该实例就已经创建完成，该实例创建的时候是线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>饿汉式的优点是实现非常简单，有人认为这种方式提前初始化会提前创建对象却不使用，导致资源浪费，个人不认同这种观点，在系统启动后去执行耗时的操作，可能会影响系统的性能，不如将这耗时的操作提前到系统初始化之时。</p><h3 id="1-2-懒汉式"><a href="#1-2-懒汉式" class="headerlink" title="1.2 懒汉式"></a>1.2 懒汉式</h3><p>与饿汉式对应的是懒汉式，将对象的初始化延迟。在 java 中有多种方式可以实现懒汉式，这里主要推荐静态内部类和枚举的方式。</p><ul><li>静态内部类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方式依赖类加载机制，当调用 getInstance() 方法时，内部类才会进行加载，instance 才会被创建，其唯一性和线程安全性由 JVM 进行保证。</p><ul><li>枚举：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式依赖 java 枚举为单例的性质，实现最为简单，推荐使用。</p><p>说明：懒汉式中还有一种双重检测的实现方式，但这种方式实现复杂，注意点多，甚至在低版本 jdk 下都无法保证正确实现单例模式。个人不推荐使用这种方式，但在此还是提供实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> IdGenerator instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (IdGenerator.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h2><p>工厂模式主要用于创建对象，可分为简单工厂、工厂方法和抽象工厂。其中抽象工厂较为复杂，在日常开发中较少使用，下文以一个车辆工厂举例介绍简单工厂和工厂方法。</p><h3 id="2-1-简单工厂"><a href="#2-1-简单工厂" class="headerlink" title="2.1 简单工厂"></a>2.1 简单工厂</h3><p>简单工厂将创建对象的逻辑汇集到一个工厂类中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getCar</span><span class="params">(String car)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;五菱&quot;</span>.equals(car)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;特斯拉&quot;</span>.equals(car)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getWuling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Car <span class="title">getTesla</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建车辆的代码被汇集到 CarFactory 中，并且提供按品牌创建车辆对象的方法。简单工厂并不是一个设计模式，它没有用到面向对象的任何特性，它更像是一种编程习惯，将类似功能的代码整合，并没有提升代码的拓展性。</p><h3 id="2-2-工厂方法"><a href="#2-2-工厂方法" class="headerlink" title="2.2 工厂方法"></a>2.2 工厂方法</h3><p>当需要拓展新类型时，简单工厂仍需要在一堆 if-else 中进行改动，要避免这种情况，需要利用多态的特性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">name</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;特斯拉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Car <span class="title">create</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wuling</span> <span class="keyword">implements</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;五菱宏光&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WulingFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Wuling();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeslaFactory</span> <span class="keyword">implements</span> <span class="title">ICarFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Tesla();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了一个工厂接口，并且实现了五菱和特斯拉的工厂类。当我们需要创建对象时，先创建对应的工厂，再调用 create 方法即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ICarFactory teslaFactory = <span class="keyword">new</span> TeslaFactory();</span><br><span class="line">Car tesla = teslaFactory.create();</span><br><span class="line">ICarFactory wulingFactory = <span class="keyword">new</span> WulingFactory();</span><br><span class="line">Car wuling = wulingFactory.create();</span><br></pre></td></tr></table></figure><p>工厂方法即提供创建对象的统一接口，并将创建对象的具体实现交由子类实现。</p><h3 id="2-3-应用场景"><a href="#2-3-应用场景" class="headerlink" title="2.3 应用场景"></a>2.3 应用场景</h3><p>那什么时候选择简单工厂，什么时候选择工厂方法呢？</p><ul><li>如果创建对象的代码块比较简单，只有两三种类型，推荐不进行拆分</li><li>当创建对象的类型较多，并且各个对象的创建逻辑较为简单时，例如只需要简单的 new 操作，选择简单工厂模式</li><li>当各个对象的创建逻辑较为复杂，需要复杂的初始化时，选择工厂方法模式，将复杂的逻辑分散到各个工厂子类中</li></ul><h2 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h2><h3 id="3-1-头疼的初始化"><a href="#3-1-头疼的初始化" class="headerlink" title="3.1 头疼的初始化"></a>3.1 头疼的初始化</h3><p>在日常开发中，创建一个对象的常用方式是直接调用该类的构造函数。但是当成员属性较多，并且有部分属性初始化是可选的时，我们需要重载大量的构造函数，代码的可读性和易用性都降低了。</p><p>有一种解决方案是提供一个简单的构造函数和 setter 方法，在创建一个对象之后，调用 setter 给需要的属性赋值。这种方案能够解决一定问题，但仍存在缺陷：</p><ul><li>必须初始化的属性依赖程序员而不是编译器确认，如果使用者忘记初始化，会影响后续的业务逻辑</li><li>建造过程中可能处于不一致的状态，没法通过检查构造参数实现一致性</li><li>该类要求是不可变对象，不应该提供 setter</li></ul><h3 id="3-2-建造者模式"><a href="#3-2-建造者模式" class="headerlink" title="3.2 建造者模式"></a>3.2 建造者模式</h3><p>为了解决这些问题，建造者模式由此产生。建造者模式在类中内置一个建造者 Builder 类，并且区分必选项和可选项，摆脱陷入大量重载构造函数的泥泽之中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化必选项</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</span><br><span class="line">        <span class="comment">// 初始化可选项，提供默认值</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.servingSize = servingSize;</span><br><span class="line">            <span class="keyword">this</span>.servings = servings;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            calories = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            fat = val;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        servingSize = builder.servingSize;</span><br><span class="line">        servings = builder.servings;</span><br><span class="line">        calories = builder.calories;</span><br><span class="line">        fat = builder.fat;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在对建造者模式都有很好的支持，lombok 插件只需要一个 @Builder 注解即可为该类低入侵式实现建造者模式，</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/2243615/">head first 设计模式</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://www.bilibili.com/video/BV1G4411c7N4?from=search&amp;seid=17614039806864782413&amp;spm_id_from=333.337.0.0">尚硅谷：设计模式</a></li><li><a href="https://book.douban.com/subject/30412517/">effective java</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1">小话设计模式(1)</a>/)</p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3">小话设计模式(3)</a>/)</p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4">小话设计模式(4)</a>/)</p>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小话设计模式(1)</title>
      <link href="/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/"/>
      <url>/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(1)/</url>
      
        <content type="html"><![CDATA[<p>设计模式首次在 GoF 的《设计模式》书中提出，其副标题是可复用面向对象软件的基础，旨在实现可拓展、可维护的高质量代码。</p><p>学习设计模式往往有以下目的：</p><ul><li>面对面试中的设计模式相关问题</li><li>改善自己的代码质量</li><li>阅读源码、框架的基础</li></ul><p>在使用模式之前，我们需要先了解各种模式以及他们适用的场景，设计模式按类型可以分为：</p><ul><li>建造型</li><li>结构型</li><li>行为型</li></ul><p>在后续文章中会按类型对常用的设计模式进行介绍。</p><p>正如计算机领域的一句名言而言，“计算机领域的问题可以靠加一层抽象来解决”，良好的抽象会极大提升了代码的质量。但很多人也忽视了下一句，“而这往往会带来其他问题”，设计模式是面向对象大树上生长出的硕果，如果使用者还未踏入面向对象的殿堂，盲目使用设计模式往往会带来相反的效果。笔者刚学习设计模式之初，曾想方设法进行应用，大肆设计，后经时间验证，过度的设计不会带来任何优势，反而却增加了代码的复杂度，代码阅读者如果不了解该模式便会不知所云。引入设计模式的目的是为了让代码变得更容易理解和维护。</p><p>自然地使用设计模式，而不是被它们套上枷锁。软件设计的能力并不是一朝一夕就能培养出来的，不要妄图通过阅读一本《设计模式》抓到面向对象设计的精髓。设计模式如同张无忌学剑一般，忘记了，也便学会了。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/1052241/">GoF 设计模式</a></li><li><p><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></p></li><li><p><a href="https://draveness.me/holy-grail-design-pattern/">圣杯与银弹 没用的设计模式</a></p></li><li><a href="https://www.zhihu.com/question/23757237">知乎：设计模式有何不妥，所谓的荼毒体现在哪</a></li><li><a href="https://zhuanlan.zhihu.com/p/19835717">为什么我们需要学习（设计）模式</a></li></ul><h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(2">小话设计模式(2)</a>/)</p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(3">小话设计模式(3)</a>/)</p><p><a href="https://strokebun.github.io/2022/01/25/%E5%B0%8F%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(4">小话设计模式(4)</a>/)</p>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈面向对象编程</title>
      <link href="/2022/01/24/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/24/%E6%B5%85%E8%B0%88%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>面向过程是一种编程范式，以过程（函数）作为单元组织代码，数据与过程相分离，主要是对过程进行抽象，将其组合为函数，代表语言 C 语言。</p><p>而面向对象也是一种编程范式，以对象（类）作为组织代码的单元，主要是对数据进行抽象，将其组合为类，具有封装、继承、多态三个特性，代表语言有 C++、Java、C#。</p><p>面向对象相比于面向过程有以下优势：</p><ul><li>更适合于复杂大规模程序开发</li><li>OOP 风格的代码更容易复用、拓展和维护</li></ul><p>说明：面向过程也并一无是处，没有纯粹的 OOP，面向对象的编程语言在宏观上是面向对象，但在微观上仍是面向过程的。 面向过程的 C 语言也可以实现不完全的面向对象特性：</p><ul><li>封装：使用 static 关键字</li><li>继承：用组合代替</li><li>多态：利用函数指针实现，redis 和 linux 内核中的 VFS 就是使用这种方法实现多态</li></ul><h2 id="2-特性"><a href="#2-特性" class="headerlink" title="2. 特性"></a>2. 特性</h2><h3 id="2-1-封装"><a href="#2-1-封装" class="headerlink" title="2.1 封装"></a>2.1 封装</h3><p>封装是将相关的数据和操作汇集到类模块，并暴露有限的接口供外部访问内部数据，用户不需要也无权访问其底层实现。</p><p>意义：</p><ul><li>降低修改的灵活性，提高代码的可控性</li><li>降低使用负担，使用者只需关注暴露的接口即可</li></ul><p>原则：</p><ul><li>当不确定内部属性的访问权限时，优先考虑最低的访问权限。当将一个属性的访问权限从 public 改为 private 可能导致大量的代码改动，反之只要小量或者没有代码改动。</li><li>有必要时才提供 setter 方法</li><li>当获取或者设置类的可变属性时，考虑采用防御性复制</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line">person.setBirthday(<span class="keyword">new</span> Date());</span><br><span class="line">System.out.println(person.toString());</span><br><span class="line"><span class="comment">// Person&#123;birthday=Mon Jan 24 09:21:38 CST 2022&#125;</span></span><br><span class="line">Date birthday = person.getBirthday();</span><br><span class="line">birthday.setYear(<span class="number">98</span>);</span><br><span class="line">System.out.println(person.toString());</span><br><span class="line"><span class="comment">// Person&#123;birthday=Sat Jan 24 09:21:38 CST 1998&#125;</span></span><br></pre></td></tr></table></figure><p>上述测试代码中 <code>getBirthday</code> 方法返回的是可变的 <code>Date</code> 对象，在外部对该 <code>Date</code> 对象进行修改会导致 <code>Person</code> 业务逻辑错误。问题根源是 birthday 虽然是引用类型，但语意上应该是值类型，我们关心的是它的值，不希望不同引用对其进行同步修改。</p><p>修改方式是采用防御性复制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Date <span class="title">getBirthday</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> birthday == <span class="keyword">null</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> Date(birthday.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li><code>Date</code> 可变是一种设计错误，其一系列 getter/setter 已被弃用</li><li>是否采用防御性复制，需要根据其语意和实际类型是否统一判断</li></ul><h3 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h3><p>此处讨论的继承为广义的继承，不局限于继承具体类。</p><p>从可继承数量上分为：</p><ul><li>单继承：一个类只能继承一个父类，代表语言 Java、C#</li><li>多继承：一个类能继承多个父类，代表语言 C++。多继承会存在菱形问题，类 B 和 C 继承 A，都重写了某一个方法，现有类 D 继承 B 和 C，该方法继承 B 还是 C 会存在歧义 </li></ul><p>根据继承类型分为：</p><ul><li>接口继承：实现某一个接口，<strong>生成可复用的代码</strong>，Java 中采用 implements 关键字</li><li>实现继承：继承某个类，<strong>复用已有的代码</strong>，Java 中采用 extends 关键字</li></ul><p>原则：</p><ul><li>提倡接口继承，慎用实现继承</li><li>优先考虑组合而不是继承。一方面继承带来了更大的耦合，父类改动时需要谨慎考虑对子类的影响，降低了拓展性；另一方面子类可以通过重写破坏父类精心设计的封装</li><li><p>考虑使用继承的情况：1. 继承层次浅，继承关系不复杂；2.模板方法设计模式；</p><p>3.无法改变一个方法的参数类型，并且该参数不是接口，考虑使用继承进行拓展</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(Client client)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    client.encode(url);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomizedClient</span> <span class="keyword">extends</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(url)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重写该方法实现自己的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line">Client client = <span class="keyword">new</span> CustomizedClient();</span><br><span class="line">f(client);</span><br></pre></td></tr></table></figure><ul><li>继承应遵守里氏替换原则，能够向上转型，常规逻辑的 is-a 关系不是使用继承的充分条件，需要<strong>考虑父类/接口的契约，子类需要履行所有契约</strong>。一个直观的测试方法：子类能够通过父类的所有的单元测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List接口，供举例说明，与java.util.List定义不同</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 添加一个元素到列表的末尾</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体实现...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中 <code>SortedList</code> 实现了 <code>List</code> 接口，但 <code>SortedList</code> 在插入元素应该将其存放在合适的位置，并不一定是末尾，并不遵守 <code>List</code> 的契约。直觉上 <code>SortedList</code> 是<code>List</code>，但从设计角度不应该实现 <code>List</code> 接口，考虑使用更上级的 <code>Collection</code> 接口。</p><p>jdk 中的设计错误：</p><p>1.<code>Stack</code> 继承了 <code>Vector</code>，栈从定义上并不具备 <code>Vector</code> 中随机访问和删除等功能，不应该使用继承。正确方式是使用组合，在内部维护一个 <code>Vector</code>，对外提供入栈、出栈等方法。</p><p>2.<code>Properties</code> 继承了 <code>HashTable&lt;Object, Object&gt;</code>，<code>Properties</code> 相比 <code>HashTable</code> 而言多了 IO 读取和持久化等功能。但是其 key 和 value 都应该是 <code>String</code> 类型，如果 <code>Properties</code> 调用继承<code>HashTable</code> 的 <code>put</code> 方法插入非 <code>String</code> 类型的 k/v 时，在持久化时会导致强制转型失败。正确方式是继承 <code>HashTable&lt;String, String&gt;</code> 或者使用组合。</p><h3 id="2-3-多态"><a href="#2-3-多态" class="headerlink" title="2.3 多态"></a>2.3 多态</h3><p>广义的多态可分为：</p><ul><li>静态多态：也称参数多态，在编译期确定类型，让相同的代码应用在不同类型。例如 C++ 中的 template（采用异构翻译，即为每一个类型创建一份代码），Java 中的泛型（采用同构翻译，即类型擦除，所有类型都会被转为 Object）</li><li>动态多态：也称子类型多态，在运行期确定，让不同的实现代码应用在相同的场合。OOP 中讨论的多态通常指动态多态</li></ul><p>多态可以提高代码的拓展性和复用性，也是很多设计模式的继承。在 OOP 中多态依赖继承实现，继承是多态的基础，多态是继承的目的。</p><p>设计原则：</p><ul><li>设计接口和父类时，需要谨慎设计契约</li></ul><p>这里举一个常见的鸟类案例：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    public void fly() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    public void fly() &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">&quot;ostrich can&#x27;t fly&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码创建了父类鸟类，并定义 <code>fly</code> 方法，子类鸵鸟继承了该类，但由于鸵鸟无法飞，<code>fly</code> 方法中抛出异常。一方面是上文所言鸵鸟无法实现父类的契约，不应该继承该类；另一方面，抽象出鸟类时应该考虑到不是所有鸟都会飞，不应该提供 <code>fly</code> 方法。更好的方式是将 <code>fly</code> 放到 <code>Flyable</code>接口中，而鸵鸟类不实现该接口。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="type">Flyable</span> &#123;</span><br><span class="line">    void fly();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AbstractBird</span>  </span>&#123;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">eagle</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> <span class="title">implements</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    void fly() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-结语"><a href="#3-结语" class="headerlink" title="3.结语"></a>3.结语</h2><p>设计再良好的系统，在烂代码的侵蚀下最终会变得不可控。在考虑总体架构设计之后，也别忽略对模块、类、方法的设计，勿在浮沙筑高楼，好的架构师首先得是一个好的程序员。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://book.douban.com/subject/4031906/">冒号课堂 编程范式和OOP思想</a></li><li><a href="https://time.geekbang.org/column/intro/100039001">设计模式之美</a></li><li><a href="https://book.douban.com/subject/2334288/">大话设计模式</a></li><li><a href="https://www.youtube.com/watch?v=aAb7hSCtvGw">Google Tech Talk: How to design a good API</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 写好代码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程思维 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
