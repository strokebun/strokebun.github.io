<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>包老师写作的地方</title><meta name="keywords" content="怕什么真理无穷，进一步有进一步的欢喜"><meta name="author" content="StrokeBun"><meta name="copyright" content="StrokeBun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Money Oriented Programming">
<meta property="og:type" content="website">
<meta property="og:title" content="包老师写作的地方">
<meta property="og:url" content="https://strokebun.github.io/index.html">
<meta property="og:site_name" content="包老师写作的地方">
<meta property="og:description" content="Money Oriented Programming">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://strokebun.github.io/img/avatar.jpg">
<meta property="article:author" content="StrokeBun">
<meta property="article:tag" content="怕什么真理无穷，进一步有进一步的欢喜">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://strokebun.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/bun.png"><link rel="canonical" href="https://strokebun.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '包老师写作的地方',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-02-23 22:23:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">包老师写作的地方</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">包老师写作的地方</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" title="HTTP GET和POST的区别">HTTP GET和POST的区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-22T06:30:13.000Z" title="发表于 2022-02-22 14:30:13">2022-02-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">GET 和 POST 是 HTTP 发送请求最常用的两种方法，当你用搜索两者的区别时，很容易得到以下回答：

GET 通过 URL 传递参数，而 POST 放在请求体 request body 中；
GET 直接在 URL 中暴露参数，相比 POST 更不安全；
对参数的数据类型，GET 只接受 ASCII 字符，而POST没有限制；
GET 传递数据大小有限制，而 POST 没有限制；
GET 发送一个请求，而 POST 发送两个请求；
……

但如果查看相关 RFC 文档的话，便会产生质疑。

The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/" title="TCP的粘包">TCP的粘包</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-21T08:50:21.000Z" title="发表于 2022-02-21 16:50:21">2022-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 粘包与半包之前的文章中一直提到，TCP 是面向流的协议，也就是说协议的内容像流水一样，没有明确的分割标志。
TCP 默认使用了 Nagle 算法，为了提高传输性能，会将多个包累积一起发送。 
例如 A 和 B 使用了 TCP 进行通信，A 向 B 发送了两个数据包，分别为 100 字节和 200 字节。B 可能先收到 100 字节，再收到 200 字节，这很美好；也可能先收到 50 字节，再收到 250 字节；也可能先收到 50 字节，再收到 100 字节，最后收到 150 字节……
发送方 A 是知道两个数据包的边界是 100 字节，然而对于接收方 B 而言，是不知道把收到的数据中多少字节作为一个包来处理的。
当发送方发送多个包以上的数据时，接收方一次读取的数据可能是大于等于 1 个（1 个，1.5 个，3 个…皆有可能）包的数据，这被称为粘包。相应的，如果一次发送数据很多，由于 TCP 收到底层 MTU 的限制，会将其分为多个 TCP 包发送，而接收方读取的数据可能只是发送方一个包的部分，这被称为半包。

其实，粘包不是 TCP 协议造成的，它的出现是由于设计了不合适的应用层 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/21/TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/" title="TCP连接的建立与释放">TCP连接的建立与释放</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-21T02:42:36.000Z" title="发表于 2022-02-21 10:42:36">2022-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍TCP 是面向连接的协议，TCP 的连接需要经过三个阶段：连接建立、数据传送、连接释放。上文 TCP可靠传输和拥塞控制 介绍了 TCP 在数据传送阶段如何实现可靠传输和拥塞控制，本文主要介绍 TCP 连接的建立和释放。
再次祭出 TCP 的首部格式：

在本文中主要关注以下字段：

SYN：同步位，该位为 1 时，希望建立连接；
FIN：中止位，该位为 1 时，希望断开连接；

ACK：确认位，该位为 1 时，确认应答的字段有效，除了最初的 SYN 包，其他的包都应该设置为 1。


2. 连接建立2.1 三次握手TCP 的连接用一个四元组 {源 IP，源端口，目标 IP，目标端口} 标记，TCP 建立连接的过程叫作握手，握手过程需要交换 3 个 TCP 报文段，通常称为三次握手。

这里称为三次握手主要是遵循日常叫法，RFC 文档中的描述是 three way（three message）handshake，其实是在一次握手过程中交换了三个报文。

TCP 建立连接的过程如下：


起初客户端和服务端都处于 CLOSED 状态，服务端创建服务，进入 LISTEN（监听） 状 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/20/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" title="TCP可靠传输与拥塞控制">TCP可靠传输与拥塞控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-20T09:46:26.000Z" title="发表于 2022-02-20 17:46:26">2022-02-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍传输控制协议 TCP（Transmission Control Proticol）是一种面向连接的、可靠的、基于字节流的通信协议，具有拥塞控制功能。在计算机网络 OSI 模型中，位于传输层。

所谓连接，即双方维护了一组数据结构记录状态，并根据一个状态机进行状态转移或者相应的处理机制。
在同一层还有用户数据报协议 UDP（User Datagram Protocol），与 TCP 基本相反，UDP 无连接、不可靠、面向报文。但这不代表使用 UDP 就无法实现可靠传输，只要在上面的应用层精心设计，也能够达到可靠传输的效果，例如 Google 的 QUIC 协议。

由于 TCP 非常复杂，在一文中介绍其全部特性是不太现实的，本文主要介绍可靠传输和拥塞控制两个特性。
首先需要关注一下 TCP 的头格式，如下所示。

其中关于可靠传输和拥塞控制主要关注以下几个部分：

Sequence Number：包的序号，用来解决网络包乱序问题。下文统一称作 seq；
Acknowledgement Number：确认收到的包序号，解决可靠传输问题。下文统一称作 ack；
Window：接收窗 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/17/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/" title="HTTP发展史">HTTP发展史</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-17T07:26:47.000Z" title="发表于 2022-02-17 15:26:47">2022-02-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">HTTP 基于 TCP 协议，默认端口是 80，HTTP 是 Web 世界中的基础协议，是现如今 Web 开发的必备知识，它也经历了多个版本的发展。
本文将介绍 HTTP 协议的发展历史。
1. HTTP/0.9HTTP/0.9 在 1991 年发布，协议内容非常简单，没有请求头，只支持 GET 命令，然后没了。
2. HTTP/1.01996 年，HTTP/1.0 发布，拓展了不少功能：

除了 GET 命令外，引入了 POST 和 HEAD 命令；
添加了 HTTP header，请求和响应都有 header 了，并且在请求 header 中指明了 http 版本；
添加了状态码，例如 200，404 等；
可以传输图像、视频等，使用 Content-Type 指明文件类型。

HTTP/1.0 极大拓展了 Web 世界的丰富程度，但也有一个主要缺点：每个 TCP 连接都只能发送一个请求。TCP 的连接需要三次握手，每次 HTTP 请求都得建立一个连接，速度较慢。除此之外，请求是串行的，每个请求必须等待上一个请求完成才可以发送。
为了解决 HTTP 短连接的问题，当时有些浏览器在请 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/17/https%E7%9A%84%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/" title="HTTPS的加密原理">HTTPS的加密原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-17T01:21:32.000Z" title="发表于 2022-02-17 09:21:32">2022-02-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍基于 TCP 的 HTTP 协议在 web 世界得到广泛使用，但由于 HTTP 采用明文传输，会存在以下问题：

通信的内容可能会被窃听，可能会泄露用户的信息；
无法验证通信方的身份，可能遭遇伪装的服务器；
无法验证报文是否遭遇篡改。

因此，在高可靠性的场合，例如银行登录、转账等，都会采用安全的 HTTPS 协议。HTTPS 其实是将HTTP 的通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。

SSL 是由 Netspace 公司设计的，3.0 版本得到大规模使用。后来互联网标准化组织 ISOC 接替 Netspace，发布了 SSL 的升级版 TLS 1.0（设计上与 SSL 3.0 几乎没有区别，TLS 1.0 通常被标示为 SSL 3.1），并在后续分别推出 TLS 1.1 和 TLS 1.2。

HTTP 直接和 TCP 通信，HTTPS 先与 SSL 通信，再由 SSL 和 TCP 通信。

2. 密码学基础在了解 HTTPS 的加密原理之前，需要先介绍一点密码学基础。
 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/16/%E6%AD%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D/" title="死锁和处理死锁">死锁和处理死锁</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-16T10:21:04.000Z" title="发表于 2022-02-16 18:21:04">2022-02-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 死锁1.1 定义死锁的定义是：如果一个进程/线程集合中的每个进程/线程都在等待只能由该集合中其他进程/线程才能引发的事件，那么该集合是死锁的。
在大多数情况下，这个事件是释放占用的资源，换句话说，死锁就是进程/线程集合中的每个进程/线程都在等待被占用的资源，都不能被唤醒运行。
很容易用 java 实现死锁：
1234567891011121314151617181920212223242526272829303132333435363738394041public class DeadLock &#123;    private static Object resourceA = new Object();    private static Object resourceB = new Object();    public static void main(String[] args) &#123;        Thread threadA = new Thread(() -&gt; &#123;            synchronized (resourceA) &# ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(6)%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/" title="Java并发编程(6) 生产者消费者模型">Java并发编程(6) 生产者消费者模型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-16T07:24:40.000Z" title="发表于 2022-02-16 15:24:40">2022-02-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">1. 介绍生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个角色——即所谓的“生产者”和“消费者”。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。

生产者消费者问题经常出现 Java 面试之中，一般有以下写法。
2. 使用wait和notify这是最简单的实现，缓冲区满和空都调用 wait 方法等待，当生产或者消费了一个产品，则使用 notfityAll 唤醒所有的生产者消费者。
注意：wait 和 notify 需要和 synchronized 配合使用。
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/16/netty%E4%BB%8B%E7%BB%8D/" title="netty介绍">netty介绍</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-16T01:29:04.000Z" title="发表于 2022-02-16 09:29:04">2022-02-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">1. 简介 netty 是一款事件驱动的异步网络框架， 是对 Java NIO 的封装，用于快速开发高性能、高可靠的网络服务器和客户端，在大量中间件例如 Dubbo、RocketMQ 中得到广泛应用。
上文 Java NIO 对 NIO 进行了介绍，NIO 存在以下问题：

类库和 API 繁琐，上手难度高；
需要熟悉多线程编程；
存在 epoll 空轮询 bug。

Netty 对 NIO 进行了封装，简单易用，并且内置了多种编解码器，支持多种协议，可用于快速开发。
2. ByteBuf2.1 介绍ByteBuffer 是 NIO 中网络的数据容器，但这个类使用繁琐复杂，netty 中的替代品是 ByteBuf。ByteBuf 拥有以下优势：

内置零拷贝
容量可以按需增长
同时具有读模式和写模式，不需要进行转换

2.2 分配与 ByteBuffer 类似，ByteBuf 可在堆中分配，也可在直接内存分配。
为了降低内存分配和释放的开销，netty 使用 PooledByteBufAllocator 实现了池化，并且基于引用计数实现内存回收，其主要 API 如下：

buffer( ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/15/Java-NIO/" title="Java NIO">Java NIO</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-15T11:03:18.000Z" title="发表于 2022-02-15 19:03:18">2022-02-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">1. 介绍传统的服务端同步阻塞 IO BIO（Blocking IO）调用 read 之后，如果接收缓冲区中没有数据，会一直阻塞直到接收数据。在 IO多路复用 中提到，传统的 BIO + 多线程的解决方案，大量连接将产生大量线程，难以解决 C10K 问题，需要使用 IO 多路复用解决。
NIO（Non-blocking IO，也称 New IO），是 Java 的一种同步非阻塞 IO 模型，底层使用了 IO 多路复用，可以有效解决 C10K 问题。
Java NIO 有三个核心组件，Buffers、Selector 和 Channel，将在下文中陆续介绍。
2. Buffer2.1 基本用法Buffer 是存储数据的缓冲区，提供读写操作，底层使用数组实现。使用 Buffer 一般遵守 4 个步骤：

写入数据到 Buffer

调用 flip() 方法

从 Buffer 中读取数据
调用 clear() 或 compact() 方法清除缓存

向 Buffer 写入数据后，内部会记录写入数据量，一旦需要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/#content-inner">4</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">StrokeBun</div><div class="author-info__description">Money Oriented Programming</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">38</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">14</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/strokebun"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" title="HTTP GET和POST的区别">HTTP GET和POST的区别</a><time datetime="2022-02-22T06:30:13.000Z" title="发表于 2022-02-22 14:30:13">2022-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/" title="TCP的粘包">TCP的粘包</a><time datetime="2022-02-21T08:50:21.000Z" title="发表于 2022-02-21 16:50:21">2022-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/21/TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/" title="TCP连接的建立与释放">TCP连接的建立与释放</a><time datetime="2022-02-21T02:42:36.000Z" title="发表于 2022-02-21 10:42:36">2022-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/20/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" title="TCP可靠传输与拥塞控制">TCP可靠传输与拥塞控制</a><time datetime="2022-02-20T09:46:26.000Z" title="发表于 2022-02-20 17:46:26">2022-02-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/17/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/" title="HTTP发展史">HTTP发展史</a><time datetime="2022-02-17T07:26:47.000Z" title="发表于 2022-02-17 15:26:47">2022-02-17</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">11</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/NoSQL/"><span class="card-category-list-name">NoSQL</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%86%99%E5%A5%BD%E4%BB%A3%E7%A0%81/"><span class="card-category-list-name">写好代码</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="card-category-list-name">分布式</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="card-category-list-name">数据库</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><span class="card-category-list-name">系统设计</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">计算机基础</span><span class="card-category-list-count">11</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="card-category-list-name">面试</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/JVM/" style="font-size: 1.3em; color: #99a1ac">JVM</a> <a href="/tags/Java-IO/" style="font-size: 1.1em; color: #999">Java IO</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 1.5em; color: #99a9bf">Java并发编程</a> <a href="/tags/MySQL/" style="font-size: 1.4em; color: #99a5b6">MySQL</a> <a href="/tags/Redis/" style="font-size: 1.4em; color: #99a5b6">Redis</a> <a href="/tags/netty/" style="font-size: 1.1em; color: #999">netty</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.1em; color: #999">分布式</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.2em; color: #999da3">操作系统</a> <a href="/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/" style="font-size: 1.1em; color: #999">智力题</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 1.1em; color: #999">系统设计</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/" style="font-size: 1.1em; color: #999">编程思维</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.3em; color: #99a1ac">计算机组成原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.5em; color: #99a9bf">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.4em; color: #99a5b6">设计模式</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">二月 2022</span><span class="card-archive-list-count">26</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/01/"><span class="card-archive-list-date">一月 2022</span><span class="card-archive-list-count">12</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">38</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-02-23T14:23:47.403Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By StrokeBun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (false) { 
    window.typed = new Typed("#subtitle", {
      strings: ["怕什么真理无穷&#44;进一步有进一步的欢喜"],
      startDelay: 300,
      typeSpeed: 150,
      loop: false,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '怕什么真理无穷&#44;进一步有进一步的欢喜'
  }
}

if (false) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>