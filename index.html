<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>包老师写作的地方</title><meta name="keywords" content="怕什么真理无穷，进一步有进一步的欢喜"><meta name="author" content="StrokeBun"><meta name="copyright" content="StrokeBun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Money Oriented Programming">
<meta property="og:type" content="website">
<meta property="og:title" content="包老师写作的地方">
<meta property="og:url" content="https://strokebun.github.io/index.html">
<meta property="og:site_name" content="包老师写作的地方">
<meta property="og:description" content="Money Oriented Programming">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://strokebun.github.io/img/avatar.jpg">
<meta property="article:author" content="StrokeBun">
<meta property="article:tag" content="怕什么真理无穷，进一步有进一步的欢喜">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://strokebun.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/bun.png"><link rel="canonical" href="https://strokebun.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '包老师写作的地方',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-03-08 16:11:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">包老师写作的地方</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">包老师写作的地方</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/17/https%E7%9A%84%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/" title="HTTPS的加密原理">HTTPS的加密原理</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-17T01:21:32.000Z" title="发表于 2022-02-17 09:21:32">2022-02-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍HTTP 协议在 web 世界得到广泛使用，但由于采用明文传输，会存在以下问题：

通信的内容可能会被窃听，可能会泄露用户的信息；
无法验证通信方的身份，可能遭遇伪装的服务器；
无法验证报文是否遭遇篡改。

因此，在高可靠性的场合，例如银行登录、转账等，都会采用安全的 HTTPS 协议。HTTPS 其实是将HTTP 的通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已，默认端口是 443。

SSL 是由 Netspace 公司设计的，3.0 版本得到大规模使用。后来互联网标准化组织 ISOC 接替 Netspace，发布了 SSL 的升级版 TLS 1.0（设计上与 SSL 3.0 几乎没有区别，TLS 1.0 通常被标示为 SSL 3.1），并在后续分别推出 TLS 1.1、TLS 1.2 和 TLS 1.3。

HTTP 直接和 TCP 通信，HTTPS 先与 SSL 通信，再由 SSL 和 TCP 通信。

2. 密码学基础在了解 HTTPS 的加密原理之前，需要先介绍一点密码学基 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/15/IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="IO多路复用">IO多路复用</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-15T07:26:37.000Z" title="发表于 2022-02-15 15:26:37">2022-02-15</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. Socket 基础网络通信依赖 Socket 实现，内核对应用层提供 socket 接口供用户进程访问。

socket 维护了读写缓冲区，当使用操作系统提供的 write 写入数据时，需要先将数据从用户态拷贝到内核态的缓冲区，由操作系统发送。对端的网卡收到数据后，通过触发中断， 将网卡数据拷贝到内核的缓冲区，再拷贝到用户空间供进程读取。

对于传统的阻塞IO BIO（Blocking IO），一次阻塞读取的工作流程如下：

阻塞式读取 Socket，缓冲区中没有数据；
进程进入阻塞状态，从 CPU 的运行队列中出队，进入 Socket 的等待队列；
客户端的数据到达网卡，通过 DMA 将数据拷贝到缓存区，完成后发起中断；
系统响应中断，将进程从 Socket 的等待队列移动到 CPU 的运行队列，进程有机会获得 CPU 时间片。

2. IO多路复用2.1 C10K问题一个 TCP 服务器如何处理多个请求呢？直观的想法对于多个请求按顺序处理，由于使用 BIO，后一个请求需要等待前一个请求完成，这样的处理方式完全没有并发能力，对于多核 CPU 服务器而言导致大量的计算资源浪费。
 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/09/JVM%E7%B3%BB%E5%88%97(3)%20%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" title="JVM系列(3) 垃圾回收">JVM系列(3) 垃圾回收</a><div class="article-meta-wrap"><span class="article-meta"><i class="fas fa-thumbtack sticky"></i><span class="sticky">置顶</span><span class="article-meta-separator">|</span></span><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-09T11:09:41.000Z" title="发表于 2022-02-09 19:09:41">2022-02-09</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">1. 垃圾识别1.1 GC介绍在 C 语言中，程序员需要手动管理内存，使用 malloc 分配内存，当对象不再使用时，需要使用 free 回收内存。如果忘记调用，这块内存将一直占用无法被使用，导致内存泄露，如果放任内存泄露的程序运行，在某一刻内存将占满，程序崩溃。另外，程序员可能会错误释放使用中的内存空间，下一次程序使用此空间时将会发生故障，往往会遇到令人头疼的段错误。以上问题出现的时间可能不一致，导致这类 BUG 难以定位。
为了摆脱手动管理内存的困境，Garbarge Collection，GC，垃圾回收机制应运而生。对象如果不再使用，其占用的内存将会自动被回收，后来出现的大部分语言，例如 Java、Go、C# 等都引入了垃圾回收机制。
1.2 垃圾识别在回收对象内存之前，需要先判断该对象是否存活，有两种经典的算法：

引用计数
可达性分析

1.2.1 引用计数引用计数的思路是，在对象中添加一个引用计数器，当被引用时，计数 +1，引用失效时，计数 -1。如果计数器的值为 0，则该对象不再被使用，可以进行回收。
引用计数的优点是思路简单，可以立即回收垃圾，暂停时间短。
引用计数无法 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/03/08/Reactor%E6%A8%A1%E5%BC%8F/" title="Reactor模式">Reactor模式</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-03-08T06:41:30.000Z" title="发表于 2022-03-08 14:41:30">2022-03-08</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E5%86%99%E5%A5%BD%E4%BB%A3%E7%A0%81/">写好代码</a></span></div><div class="content">1. 介绍在 IO多路复用 文章中提到，引入了 IO 多路复用解决了 C10K 问题，但直接基于 select/poll/epoll 编写服务端程序还是比较复杂的，于是对此做了一层封装，称为 Reactor 模式。
Reactor 模式也称为 Dispatcher 模式，使用 IO 多路复用监听事件，收到事件后，根据事件类型分配给某个线程。
下文将介绍常见 Reactor 模型的实现方案。
2. 单Reactor单线程单 Reactor 单线程是最简单的实现方案，示意图如下：

这里主要有三个对象 Reactor、Acceptor 和 Handler：

Reactor 对象通过 IO 多路复用监听事件，如果是连接事件则分发给 Acceptor 对象，非连接事件则分发给 Handler 对象；
Acceptor 对象会获取连接，并为此连接创建一个 Handler 对象处理后续的业务；
Handler 对象进行 读数据 -&gt; 处理业务 -&gt; 发送数据 的流程。

上面的三个对象都在同一个线程中，实现简单，不过也存在两个缺点：

无法利用多核 CPU 的性能优势；
Handle ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/03/03/HTTP%E6%8A%A5%E6%96%87/" title="HTTP报文">HTTP报文</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-03-03T08:11:26.000Z" title="发表于 2022-03-03 16:11:26">2022-03-03</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍超文本传输协议 HyperText Transfer Protocol，HTTP 是 WEB 世界中最常用的协议，基于 TCP 协议，默认端口是 80。
HTTP 是无状态的协议，但使用 Cookie 和 Session 实现保持状态的功能。
本文主要介绍 HTTP 报文。
2. HTTP报文用于 HTTP 协议交互的信息被称为 HTTP 报文，大致可分为报文首部 header 和报文主体 body 两部分，并由空行（CRLF）划分，HTTP 报文并不一定包含主体。

客户端的 HTTP 报文称为请求报文，请求报文的首部包括请求行和各种首部字段。服务端的称为响应报文，响应报文的首部包括状态行和各种首部字段。

3. 常见状态码
1xx1xx 类状态码是一种中间状态，较少使用，一种使用方式是 HTTP GET和POST的区别 中提到的，上传文件时先传文件信息，服务端返回 100 再继续传输文件内容。
2xx2xx 类状态码表示服务器成功处理了客户端的请求。
200 OK 是常见的状态码，表示一切正常。
204 No Content 与 200 基本相同，但响应中没有 body  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(7)%20%E8%A7%A3%E8%AF%BBConcurrentHashMap/" title="Java并发编程(7): 解读ConcurrentHashMap">Java并发编程(7): 解读ConcurrentHashMap</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-28T07:23:52.000Z" title="发表于 2022-02-28 15:23:52">2022-02-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">1. 介绍java.util.concurrent 中包含大量线程安全的集合，一一介绍是不太现实的，而ConcurrentHashMap 在面试中最常考察，本文将对它进行介绍。
HashMap 不是线程安全的，想要得到一个线程安全的 Map 集合，一个直观的想法是对每个方法使用 synchronized 加锁，实现最为简单，但是这种方式锁粒度过大，同一时间只有一个线程能够访问。

HashTable 就是这样的实现方式，一般不推荐使用。


改进方法是降低加锁的粒度，对 Map 中部分元素进行加锁，达到多线程访问的效果。
ConcurrentHashMap 在 jdk 1.7 和 1.8 版本的实现方式是不同的，本文主要介绍 1.8 版本的实现。

jdk 1.7 中的 ConcurrentHashMap 的实现思路是使用分段锁，这个思路在其他语言的线程安全集合中大量应用，推荐掌握。

2. 设计思路ConcurrentHashMap 的数据存储与获取与 HashMap 高度相似：

使用 Node 数组存储元素，数组长度为 2 的幂，求余采用位运算实现；
采用拉链法解决哈希冲突，当链 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/27/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-27T02:31:47.000Z" title="发表于 2022-02-27 10:31:47">2022-02-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍在 c++ 编译的过程中，需要指定文件之间的依赖关系，而编译器通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序。
大学中有些课程需要先修其他课程，学生需要在这个要求下，通过合理的选课修完所有课程。
以上两个例子都依赖一个图中的经典算法，拓扑排序。拓扑排序是有向图中对顶点的一种线性排序，使得对于从顶点 u 到顶点 v 的每个有向边，u 在排序结果中都在 v 之前。
拓扑排序有两种实现方法，Khan 算法和深度优先遍历 DFS 算法。
在此之前，先介绍本文会遇到的部分概念：

入度：有向边 u -&gt; v 的个数称为顶点 v 的入度；
邻接表：图的一种实现方式，对于每个顶点，使用一个表存储与其连接的顶点。在有向图中，表中存储本节点指向的节点，例如有边 u -&gt; v1, u -&gt; v2，则 u 的邻接表为 {v1, v2}。下面为代码实现：

123456789101112131415161718/** * 建立邻接表 * @param n 节点个数 * @param edges 有向边数组，每个元素edge代表存在edge[0] -&gt; edge[1] ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/26/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" title="RocketMQ事务消息">RocketMQ事务消息</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-26T10:40:34.000Z" title="发表于 2022-02-26 18:40:34">2022-02-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="content">1. 事务消息的引入当本地事务和发消息逻辑捆绑在一起的场景，普通消息可能导致逻辑不一致的问题。
例如下单成功后给客户发送短信，短信平台是单独的服务，将修改订单状态和发送消息组合成一个事务，下单成功后发送消息，如果消息发送失败，则回滚事务。由于网络阻塞，消息可能发送成功，而 Broker 的确认超时了，客户端认为消息没有成功，回滚了本地事务，下单未成功。但 Broker 已经存储了消息，导致消费者执行了发送短信的业务，出现给用户发送了短信但下单却没成功的情况。
RocketMQ 在 4.3.0 版本引入事务消息，事务消息将本地事务和发送消息定义到全局事务中，实现分布式事务的最终一致性，解决了上述问题。
2. 使用事务消息当使用事务消息，核心是实现 TransactionListener 接口。
1234567public interface TransactionListener &#123;    // 用于实现本地事务，在得到半消息的响应后执行    LocalTransactionState executeLocalTransaction(final Message msg, fi ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/25/RocketMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/" title="RocketMQ的消息存储">RocketMQ的消息存储</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-25T08:43:50.000Z" title="发表于 2022-02-25 16:43:50">2022-02-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="content">1. 介绍上文 消息队列概述 中说到，为了保证消息不丢失，要求 Broker 将消息落盘后再给客户端发送确认，这就涉及到了消息存储机制。消息存储是 RocketMQ 最为复杂和重要的部分，但官方文档对此介绍却十分简略。
下图为官方的说明图。

RocketMQ 的消息存储主要由 CommitLog、ConsumeQueue 和 IndexFile 实现。
CommitLogBroker 收到信息后，把这个消息顺序写入到磁盘上的一个文件，叫作 CommitLog。所有 topic 下的消息都写入到 CommitLog 中，实现严格的顺序写，提高磁盘写入速率。

CommitLog 存储了消息内容和元数据，其存储文件单个大小默认为 1G，文件名是起始偏移量，长度为 20 位。第一个文件名为 00000000000000000000，当第一个文件写满了，第二个文件为 00000000001073741824（1G = 1073741824），以此类推。
ConsumeQueueRocketMQ 是基于 topic 和 tag 的订阅模式，消费消息也是根据 topic 进行的，遍历 Commi ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/" title="消息队列概述">消息队列概述</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-24T01:00:37.000Z" title="发表于 2022-02-24 09:00:37">2022-02-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="content">1.介绍消息队列 Message Queue，MQ 是现今系统中常用的中间件，一般有以下用途。
异步处理同步请求需要阻塞等待服务端的响应，增加了调用时间，而 MQ 可以实现服务的异步处理，可以：

更快地返回结果，减少等待；
自然实现并发，提升系统的总体性能。

流量控制在瞬间高并发的场景下，服务器无法处理可能被打挂，而其他阶段的流量又很少，服务器计算资源浪费。MQ 可以隔离网关和后端服务，达到削峰填谷的功能。
服务解耦MQ 的另一个作用，是实现系统应用间的解耦。例如一个服务 A，需要依次调用 B、C、D，服务中出现了强耦合。
12345service A() &#123;    B();    C();    D();&#125;
而当出现新服务 E 需要调用时，需要改动 A 服务。而引入 MQ 后，A 可以通过发送消息到一个 Topic，下游服务通过订阅 Topic 获得消息处理，这样下游服务的变化对上游服务没有影响。

虽然 MQ 具有上述好处，但引入 MQ 也会带来延迟、增加系统复杂度、导致数据不一致的问题，需要权衡选择。

2.主流的消息队列消息队列种类繁多，其中最主流的有  ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">StrokeBun</div><div class="author-info__description">Money Oriented Programming</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">45</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/strokebun"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/08/Reactor%E6%A8%A1%E5%BC%8F/" title="Reactor模式">Reactor模式</a><time datetime="2022-03-08T06:41:30.000Z" title="发表于 2022-03-08 14:41:30">2022-03-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/03/HTTP%E6%8A%A5%E6%96%87/" title="HTTP报文">HTTP报文</a><time datetime="2022-03-03T08:11:26.000Z" title="发表于 2022-03-03 16:11:26">2022-03-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(7)%20%E8%A7%A3%E8%AF%BBConcurrentHashMap/" title="Java并发编程(7): 解读ConcurrentHashMap">Java并发编程(7): 解读ConcurrentHashMap</a><time datetime="2022-02-28T07:23:52.000Z" title="发表于 2022-02-28 15:23:52">2022-02-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/27/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a><time datetime="2022-02-27T02:31:47.000Z" title="发表于 2022-02-27 10:31:47">2022-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/26/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" title="RocketMQ事务消息">RocketMQ事务消息</a><time datetime="2022-02-26T10:40:34.000Z" title="发表于 2022-02-26 18:40:34">2022-02-26</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">12</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="card-category-list-name">中间件</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%86%99%E5%A5%BD%E4%BB%A3%E7%A0%81/"><span class="card-category-list-name">写好代码</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="card-category-list-name">分布式</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="card-category-list-name">数据库</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><span class="card-category-list-name">系统设计</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">计算机基础</span><span class="card-category-list-count">13</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="card-category-list-name">面试</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/JVM/" style="font-size: 1.23em; color: #999ea6">JVM</a> <a href="/tags/Java-IO/" style="font-size: 1.1em; color: #999">Java IO</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91/" style="font-size: 1.1em; color: #999">Java并发</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 1.43em; color: #99a6b9">Java并发编程</a> <a href="/tags/MySQL/" style="font-size: 1.3em; color: #99a1ac">MySQL</a> <a href="/tags/Redis/" style="font-size: 1.3em; color: #99a1ac">Redis</a> <a href="/tags/netty/" style="font-size: 1.1em; color: #999">netty</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.1em; color: #999">分布式</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.17em; color: #999c9f">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 1.1em; color: #999">数据结构与算法</a> <a href="/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/" style="font-size: 1.1em; color: #999">智力题</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 1.23em; color: #999ea6">消息队列</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 1.1em; color: #999">系统设计</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/" style="font-size: 1.1em; color: #999">编程思维</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.23em; color: #999ea6">计算机组成原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.5em; color: #99a9bf">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.37em; color: #99a4b2">设计模式</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/03/"><span class="card-archive-list-date">三月 2022</span><span class="card-archive-list-count">2</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">二月 2022</span><span class="card-archive-list-count">31</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/01/"><span class="card-archive-list-date">一月 2022</span><span class="card-archive-list-count">12</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">45</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-03-08T08:11:17.891Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By StrokeBun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (false) { 
    window.typed = new Typed("#subtitle", {
      strings: ["怕什么真理无穷&#44;进一步有进一步的欢喜"],
      startDelay: 300,
      typeSpeed: 150,
      loop: false,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '怕什么真理无穷&#44;进一步有进一步的欢喜'
  }
}

if (false) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>