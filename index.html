<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>包老师写作的地方</title><meta name="keywords" content="怕什么真理无穷，进一步有进一步的欢喜"><meta name="author" content="StrokeBun"><meta name="copyright" content="StrokeBun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Money Oriented Programming">
<meta property="og:type" content="website">
<meta property="og:title" content="包老师写作的地方">
<meta property="og:url" content="https://strokebun.github.io/index.html">
<meta property="og:site_name" content="包老师写作的地方">
<meta property="og:description" content="Money Oriented Programming">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://strokebun.github.io/img/avatar.jpg">
<meta property="article:author" content="StrokeBun">
<meta property="article:tag" content="怕什么真理无穷，进一步有进一步的欢喜">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://strokebun.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/bun.png"><link rel="canonical" href="https://strokebun.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '包老师写作的地方',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-02-28 17:27:38'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">包老师写作的地方</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">包老师写作的地方</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(7)%20%E8%A7%A3%E8%AF%BBConcurrentHashMap/" title="Java并发编程(7): 解读ConcurrentHashMap">Java并发编程(7): 解读ConcurrentHashMap</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-28T07:23:52.000Z" title="发表于 2022-02-28 15:23:52">2022-02-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">1. 介绍java.util.concurrent 中包含大量线程安全的集合，一一介绍是不太现实的，而ConcurrentHashMap 在面试中最常考察，本文将对它进行介绍。
HashMap 不是线程安全的，想要得到一个线程安全的 Map 集合，一个直观的想法是对每个方法使用 synchronized 加锁，实现最为简单，但是这样锁粒度过大，同一时间只有一个线程能够访问。

HashTable 就是这样的实现方式，一般不推荐使用。


改进方法是降低加锁的粒度，对 Map 中部分元素进行加锁，达到多线程访问的效果。
ConcurrentHashMap 在 jdk 1.7 和 1.8 版本的实现方式是不同的，本文主要介绍 1.8 版本的实现。

jdk 1.7 中的 ConcurrentHashMap 的实现思路是使用分段锁，这个思路在其他语言的线程安全集合中大量应用，推荐掌握。

2. 设计思路ConcurrentHashMap 的数据存储与获取与 HashMap 高度相似：

使用 Node 数组存储元素，数组长度为 2 的幂，求余采用位运算实现；
采用拉链法解决哈希冲突，当链表长 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/28/%E8%A7%A3%E8%AF%BBConcurrentHashMap/" title="Java并发编程(7): 解读ConcurrentHashMap">Java并发编程(7): 解读ConcurrentHashMap</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-28T07:23:52.000Z" title="发表于 2022-02-28 15:23:52">2022-02-28</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">1. 介绍java.util.concurrent 中包含大量线程安全的集合，一一介绍是不太现实的，而ConcurrentHashMap 在面试中最常考察，本文将对它进行介绍。
HashMap 不是线程安全的，想要得到一个线程安全的 Map 集合，一个直观的想法是对每个方法进行 synchronized 加锁，实现最为简单，但是加锁粒度太大，同一时间只有一个线程能够访问。

HashTable 就是这样的实现方式，一般不推荐使用。


改进方法是降低加锁的粒度，对 Map 中部分元素进行加锁，达到多线程访问的效果。
ConcurrentHashMap 在 jdk 1.7 和 1.8 版本的实现方式是不同的，本文主要介绍 1.8 版本的实现。

ConcurrentHashMap 在 jdk 1.7 的实现思路是使用分段锁，这个思路在其他语言的线程安全集合中大量应用，推荐掌握。

2. 设计思路ConcurrentHashMap 的数据存储与获取与 HashMap 高度相似：

采用 Node 数组存储元素，数组长度为 2 的幂，求余采用位运算实现；
采用拉链法解决哈希冲突，当链表长度达 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/27/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-27T02:31:47.000Z" title="发表于 2022-02-27 10:31:47">2022-02-27</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍在 c++ 编译的过程中，需要指定文件之间的依赖关系，而编译器通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序。
在大学选课中，有些课程需要先修其他课程，学生需要在这个要求下，选择修完所有课程。
以上两个例子都依赖一个图中的经典算法，拓扑排序。
拓扑排序是有向图中对顶点的一种线性排序，使得对于从顶点 u 到顶点 v 的每个有向边，u 在排序结果中都在 v 之前。
拓扑排序有两种实现方法，Khan 算法和深度优先遍历 DFS 算法。
在此之前，先介绍本文会遇到的部分概念：

入度：有向边 u -&gt; v 的个数称为顶点 v 的入度；
邻接表：图的一种实现方式，对于每个顶点，使用一个表存储与其连接的顶点。在有向图中，表中存储本节点指向的节点，例如有边 u -&gt; v1, u -&gt; v2，则 u 的邻接表为 {v1, v2}。下面为代码实现：

123456789101112131415161718/** * 建立邻接表 * @param n 节点个数 * @param edges 有向边数组，每个元素edge代表存在edge[0] -&gt; edge[1] ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/26/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" title="RocketMQ事务消息">RocketMQ事务消息</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-26T10:40:34.000Z" title="发表于 2022-02-26 18:40:34">2022-02-26</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="content">1. 事务消息的引入当本地事务和发消息逻辑捆绑在一起的场景，普通消息可能导致逻辑不一致的问题。
例如下单成功后给客户发送短信，短信平台是单独的服务，将修改订单状态和发送消息组合成一个事务，下单成功后发送消息，如果消息发送失败，则回滚事务。由于网络阻塞，消息可能发送成功，而 Broker 的确认超时了，客户端认为消息没有成功，回滚了本地事务，下单未成功。但 Broker 已经存储了消息，导致消费者执行了发送短信的业务，出现给用户发送了短信但下单却没成功的情况。
RocketMQ 在 4.3.0 版本引入事务消息，事务消息将本地事务和发送消息定义到全局事务中，实现分布式事务的最终一致性，解决了上述问题。
2. 使用事务消息当使用事务消息，核心是实现 TransactionListener 接口。
1234567public interface TransactionListener &#123;    // 用于实现本地事务，在得到半消息的响应后执行    LocalTransactionState executeLocalTransaction(final Message msg, fi ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/25/RocketMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/" title="RocketMQ的消息存储">RocketMQ的消息存储</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-25T08:43:50.000Z" title="发表于 2022-02-25 16:43:50">2022-02-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="content">1. 介绍上文 消息队列概述 中说到，为了保证消息不丢失，要求 Broker 将消息落盘后再给客户端发送确认，这就涉及到了消息存储机制。消息存储是 RocketMQ 最为复杂和重要的部分，但官方文档对此介绍却十分简略。
下图为官方的说明图。

RocketMQ 的消息存储主要由 CommitLog、ConsumeQueue 和 IndexFile 实现。
CommitLogBroker 收到信息后，把这个消息顺序写入到磁盘上的一个文件，叫作 CommitLog。所有 topic 下的消息都写入到 CommitLog 中，实现严格的顺序写，提高磁盘写入速率。
CommitLog 存储了消息内容和元数据，其存储文件单个大小默认为 1G，文件名是起始偏移量，长度为 20 位。第一个文件名为 00000000000000000000，当第一个文件写满了，第二个文件为 00000000001073741824（1G = 1073741824），以此类推。

ConsumeQueueRocketMQ 是基于 topic 和 tag 的订阅模式，消费消息也是根据 topic 进行的，遍历 Commi ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/" title="消息队列概述">消息队列概述</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-24T01:00:37.000Z" title="发表于 2022-02-24 09:00:37">2022-02-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="content">1.介绍消息队列 Message Queue，MQ 是现今系统中常用的中间件，一般有以下用途。
异步处理同步请求需要阻塞等待服务端的响应，增加了调用时间，而 MQ 可以实现服务的异步处理，可以：

更快地返回结果，减少等待；
自然实现并发，提升系统的总体性能。

流量控制在瞬间高并发的场景下，服务器无法处理可能被打挂，而其他阶段的流量又很少，服务器计算资源浪费。MQ 可以隔离网关和后端服务，达到削峰填谷的功能。
服务解耦MQ 的另一个作用，是实现系统应用间的解耦。例如一个服务 A，需要依次调用 B、C、D，服务中出现了强耦合。
12345service A() &#123;    B();    C();    D();&#125;
而当出现新服务 E 需要调用时，需要改动 A 服务。而引入 MQ 后，A 可以通过发送消息到一个 Topic，下游服务通过订阅 Topic 获得消息处理，这样下游服务的变化对上游服务没有影响。

虽然 MQ 具有上述好处，但引入 MQ 也会带来延迟、增加系统复杂度、导致数据不一致的问题，需要权衡选择。

2.主流的消息队列消息队列种类繁多，其中最主流的有  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" title="HTTP GET和POST的区别">HTTP GET和POST的区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-22T06:30:13.000Z" title="发表于 2022-02-22 14:30:13">2022-02-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">GET 和 POST 是 HTTP 发送请求最常用的两种方法，当你用搜索两者的区别时，很容易得到以下回答：

GET 通过 URL 传递参数，而 POST 放在请求体 request body 中；
GET 直接在 URL 中暴露参数，相比 POST 更不安全；
对参数的数据类型，GET 只接受 ASCII 字符，而POST没有限制；
GET 传递数据大小有限制，而 POST 没有限制；
GET 发送一个请求，而 POST 发送两个请求；
……

但如果查看相关 RFC 文档的话，便会产生质疑。

The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/" title="TCP的粘包">TCP的粘包</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-21T08:50:21.000Z" title="发表于 2022-02-21 16:50:21">2022-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 粘包与半包之前的文章中一直提到，TCP 是面向流的协议，也就是说协议的内容像流水一样，没有明确的分割标志。
TCP 默认使用了 Nagle 算法，为了提高传输性能，会将多个包累积一起发送。 
例如 A 和 B 使用了 TCP 进行通信，A 向 B 发送了两个数据包，分别为 100 字节和 200 字节。B 可能先收到 100 字节，再收到 200 字节，这很美好；也可能先收到 50 字节，再收到 250 字节；也可能先收到 50 字节，再收到 100 字节，最后收到 150 字节……
发送方 A 是知道两个数据包的边界是 100 字节，然而对于接收方 B 而言，是不知道把收到的数据中多少字节作为一个包来处理的。
当发送方发送多个包以上的数据时，接收方一次读取的数据可能是大于等于 1 个（1 个，1.5 个，3 个…皆有可能）包的数据，这被称为粘包。相应的，如果一次发送数据很多，由于 TCP 收到底层 MTU 的限制，会将其分为多个 TCP 包发送，而接收方读取的数据可能只是发送方一个包的部分，这被称为半包。

其实，粘包不是 TCP 协议造成的，它的出现是由于设计了不合适的应用层 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/21/TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/" title="TCP连接的建立与释放">TCP连接的建立与释放</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-21T02:42:36.000Z" title="发表于 2022-02-21 10:42:36">2022-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍TCP 是面向连接的协议，TCP 的连接需要经过三个阶段：连接建立、数据传送、连接释放。上文 TCP可靠传输和拥塞控制 介绍了 TCP 在数据传送阶段如何实现可靠传输和拥塞控制，本文主要介绍 TCP 连接的建立和释放。
再次祭出 TCP 的首部格式：

在本文中主要关注以下字段：

SYN：同步位，该位为 1 时，希望建立连接；
FIN：中止位，该位为 1 时，希望断开连接；

ACK：确认位，该位为 1 时，确认应答的字段有效，除了最初的 SYN 包，其他的包都应该设置为 1。


2. 连接建立2.1 三次握手TCP 的连接用一个四元组 {源 IP，源端口，目标 IP，目标端口} 标记，TCP 建立连接的过程叫作握手，握手过程需要交换 3 个 TCP 报文段，通常称为三次握手。

这里称为三次握手主要是遵循日常叫法，RFC 文档中的描述是 three way（three message）handshake，其实是在一次握手过程中交换了三个报文。

TCP 建立连接的过程如下：


起初客户端和服务端都处于 CLOSED 状态，服务端创建服务，进入 LISTEN（监听） 状 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/20/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" title="TCP可靠传输与拥塞控制">TCP可靠传输与拥塞控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-20T09:46:26.000Z" title="发表于 2022-02-20 17:46:26">2022-02-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍传输控制协议 TCP（Transmission Control Proticol）是一种面向连接的、可靠的、基于字节流的通信协议，具有拥塞控制功能。在计算机网络 OSI 模型中，位于传输层。

所谓连接，即双方维护了一组数据结构记录状态，并根据一个状态机进行状态转移或者相应的处理机制。
在同一层还有用户数据报协议 UDP（User Datagram Protocol），与 TCP 基本相反，UDP 无连接、不可靠、面向报文。但这不代表使用 UDP 就无法实现可靠传输，只要在上面的应用层精心设计，也能够达到可靠传输的效果，例如 Google 的 QUIC 协议。

由于 TCP 非常复杂，在一文中介绍其全部特性是不太现实的，本文主要介绍可靠传输和拥塞控制两个特性。
首先需要关注一下 TCP 的头格式，如下所示。

其中关于可靠传输和拥塞控制主要关注以下几个部分：

Sequence Number：包的序号，用来解决网络包乱序问题。下文统一称作 seq；
Acknowledgement Number：确认收到的包序号，解决可靠传输问题。下文统一称作 ack；
Window：接收窗 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/#content-inner">5</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">StrokeBun</div><div class="author-info__description">Money Oriented Programming</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">44</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">17</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/strokebun"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/28/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(7)%20%E8%A7%A3%E8%AF%BBConcurrentHashMap/" title="Java并发编程(7): 解读ConcurrentHashMap">Java并发编程(7): 解读ConcurrentHashMap</a><time datetime="2022-02-28T07:23:52.000Z" title="发表于 2022-02-28 15:23:52">2022-02-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/28/%E8%A7%A3%E8%AF%BBConcurrentHashMap/" title="Java并发编程(7): 解读ConcurrentHashMap">Java并发编程(7): 解读ConcurrentHashMap</a><time datetime="2022-02-28T07:23:52.000Z" title="发表于 2022-02-28 15:23:52">2022-02-28</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/27/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/" title="拓扑排序">拓扑排序</a><time datetime="2022-02-27T02:31:47.000Z" title="发表于 2022-02-27 10:31:47">2022-02-27</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/26/RocketMQ%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/" title="RocketMQ事务消息">RocketMQ事务消息</a><time datetime="2022-02-26T10:40:34.000Z" title="发表于 2022-02-26 18:40:34">2022-02-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/25/RocketMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/" title="RocketMQ的消息存储">RocketMQ的消息存储</a><time datetime="2022-02-25T08:43:50.000Z" title="发表于 2022-02-25 16:43:50">2022-02-25</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">13</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="card-category-list-name">中间件</span><span class="card-category-list-count">7</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%86%99%E5%A5%BD%E4%BB%A3%E7%A0%81/"><span class="card-category-list-name">写好代码</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="card-category-list-name">分布式</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="card-category-list-name">数据库</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><span class="card-category-list-name">系统设计</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">计算机基础</span><span class="card-category-list-count">12</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="card-category-list-name">面试</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/JVM/" style="font-size: 1.3em; color: #99a1ac">JVM</a> <a href="/tags/Java-IO/" style="font-size: 1.1em; color: #999">Java IO</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91/" style="font-size: 1.2em; color: #999da3">Java并发</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 1.5em; color: #99a9bf">Java并发编程</a> <a href="/tags/MySQL/" style="font-size: 1.4em; color: #99a5b6">MySQL</a> <a href="/tags/Redis/" style="font-size: 1.4em; color: #99a5b6">Redis</a> <a href="/tags/netty/" style="font-size: 1.1em; color: #999">netty</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.1em; color: #999">分布式</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.2em; color: #999da3">操作系统</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 1.1em; color: #999">数据结构与算法</a> <a href="/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/" style="font-size: 1.1em; color: #999">智力题</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 1.3em; color: #99a1ac">消息队列</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 1.1em; color: #999">系统设计</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/" style="font-size: 1.1em; color: #999">编程思维</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.3em; color: #99a1ac">计算机组成原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.5em; color: #99a9bf">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.4em; color: #99a5b6">设计模式</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">二月 2022</span><span class="card-archive-list-count">32</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/01/"><span class="card-archive-list-date">一月 2022</span><span class="card-archive-list-count">12</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">44</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-02-28T09:27:38.183Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By StrokeBun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (false) { 
    window.typed = new Typed("#subtitle", {
      strings: ["怕什么真理无穷&#44;进一步有进一步的欢喜"],
      startDelay: 300,
      typeSpeed: 150,
      loop: false,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '怕什么真理无穷&#44;进一步有进一步的欢喜'
  }
}

if (false) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>