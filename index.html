<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>包老师写作的地方</title><meta name="keywords" content="怕什么真理无穷，进一步有进一步的欢喜"><meta name="author" content="StrokeBun"><meta name="copyright" content="StrokeBun"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Money Oriented Programming">
<meta property="og:type" content="website">
<meta property="og:title" content="包老师写作的地方">
<meta property="og:url" content="https://strokebun.github.io/index.html">
<meta property="og:site_name" content="包老师写作的地方">
<meta property="og:description" content="Money Oriented Programming">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://strokebun.github.io/img/avatar.jpg">
<meta property="article:author" content="StrokeBun">
<meta property="article:tag" content="怕什么真理无穷，进一步有进一步的欢喜">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://strokebun.github.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/bun.png"><link rel="canonical" href="https://strokebun.github.io/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '包老师写作的地方',
  isPost: false,
  isHome: true,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-02-25 20:35:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="page" id="body-wrap"><header class="full_page" id="page-header" style="background-image: url('/img/background.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">包老师写作的地方</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="site-info"><h1 id="site-title">包老师写作的地方</h1><div id="site-subtitle"><span id="subtitle"></span></div></div><div id="scroll-down"><i class="fas fa-angle-down scroll-down-effects"></i></div></header><main class="layout" id="content-inner"><div class="recent-posts" id="recent-posts"><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/25/RocketMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/" title="RocketMQ的消息存储">RocketMQ的消息存储</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-25T08:43:50.000Z" title="发表于 2022-02-25 16:43:50">2022-02-25</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="content">1. 介绍上文 消息队列概述 中说到，为了保证消息不丢失，要求 Broker 将消息落盘后再给客户端发送确认，这就涉及到了消息存储机制。消息存储是 RocketMQ 最为复杂和重要的部分，但官方文档对此介绍却十分简略，难以理解。
下图为官方的说明图。

RocketMQ 的消息存储主要由 CommitLog、ConsumeQueue 和 IndexFile 实现。
CommitLogBroker 收到信息后，把这个消息顺序写入到磁盘上的一个文件，叫作 CommitLog。所有 topic 下的消息都写入到 CommitLog 中，实现严格的顺序写，提高磁盘写入速率。
CommitLog 存储了消息内容和元数据，其存储文件单个大小默认为 1G，文件名是起始偏移量，长度为 20 位。第一个文件名为 00000000000000000000，当第一个文件写满了，第二个文件为 00000000001073741824（1G = 1073741824），以此类推。

ConsumeQueueRocketMQ 是基于 topic 和 tag 的订阅模式，消费消息也是根据 topic 进行的，遍历  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/" title="消息队列概述">消息队列概述</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-24T01:00:37.000Z" title="发表于 2022-02-24 09:00:37">2022-02-24</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/">中间件</a></span></div><div class="content">1.介绍消息队列 Message Queue，MQ 是现今系统中常用的中间件，一般有以下用途。
异步处理同步请求需要阻塞等待服务端的响应，增加了调用时间，而 MQ 可以实现服务的异步处理，可以：

更快地返回结果，减少等待；
自然实现并发，提升系统的总体性能。

流量控制在瞬间高并发的场景下，服务器无法处理可能被打挂，而其他阶段的流量又很少，服务器计算资源浪费。MQ 可以隔离网关和后端服务，达到削峰填谷的功能。
服务解耦MQ 的另一个作用，是实现系统应用间的解耦。例如一个服务 A，需要依次调用 B、C、D，服务中出现了强耦合。
12345service A() &#123;    B();    C();    D();&#125;
而当出现新服务 E 需要调用时，需要改动 A 服务。而引入 MQ 后，A 可以通过发送消息到一个 Topic，下游服务通过订阅 Topic 获得消息处理，这样下游服务的变化对上游服务没有影响。

虽然 MQ 具有上述好处，但引入 MQ 也会带来延迟、增加系统复杂度、导致数据不一致的问题，需要权衡选择。

2.主流的消息队列消息队列种类繁多，其中最主流的有  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" title="HTTP GET和POST的区别">HTTP GET和POST的区别</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-22T06:30:13.000Z" title="发表于 2022-02-22 14:30:13">2022-02-22</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">GET 和 POST 是 HTTP 发送请求最常用的两种方法，当你用搜索两者的区别时，很容易得到以下回答：

GET 通过 URL 传递参数，而 POST 放在请求体 request body 中；
GET 直接在 URL 中暴露参数，相比 POST 更不安全；
对参数的数据类型，GET 只接受 ASCII 字符，而POST没有限制；
GET 传递数据大小有限制，而 POST 没有限制；
GET 发送一个请求，而 POST 发送两个请求；
……

但如果查看相关 RFC 文档的话，便会产生质疑。

The GET method requests transfer of a current selected representation for the target resource. GET is the primary mechanism of information retrieval and the focus of almost all performance optimizations. Hence, when people speak of retrieving some  ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/" title="TCP的粘包">TCP的粘包</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-21T08:50:21.000Z" title="发表于 2022-02-21 16:50:21">2022-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 粘包与半包之前的文章中一直提到，TCP 是面向流的协议，也就是说协议的内容像流水一样，没有明确的分割标志。
TCP 默认使用了 Nagle 算法，为了提高传输性能，会将多个包累积一起发送。 
例如 A 和 B 使用了 TCP 进行通信，A 向 B 发送了两个数据包，分别为 100 字节和 200 字节。B 可能先收到 100 字节，再收到 200 字节，这很美好；也可能先收到 50 字节，再收到 250 字节；也可能先收到 50 字节，再收到 100 字节，最后收到 150 字节……
发送方 A 是知道两个数据包的边界是 100 字节，然而对于接收方 B 而言，是不知道把收到的数据中多少字节作为一个包来处理的。
当发送方发送多个包以上的数据时，接收方一次读取的数据可能是大于等于 1 个（1 个，1.5 个，3 个…皆有可能）包的数据，这被称为粘包。相应的，如果一次发送数据很多，由于 TCP 收到底层 MTU 的限制，会将其分为多个 TCP 包发送，而接收方读取的数据可能只是发送方一个包的部分，这被称为半包。

其实，粘包不是 TCP 协议造成的，它的出现是由于设计了不合适的应用层 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/21/TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/" title="TCP连接的建立与释放">TCP连接的建立与释放</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-21T02:42:36.000Z" title="发表于 2022-02-21 10:42:36">2022-02-21</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍TCP 是面向连接的协议，TCP 的连接需要经过三个阶段：连接建立、数据传送、连接释放。上文 TCP可靠传输和拥塞控制 介绍了 TCP 在数据传送阶段如何实现可靠传输和拥塞控制，本文主要介绍 TCP 连接的建立和释放。
再次祭出 TCP 的首部格式：

在本文中主要关注以下字段：

SYN：同步位，该位为 1 时，希望建立连接；
FIN：中止位，该位为 1 时，希望断开连接；

ACK：确认位，该位为 1 时，确认应答的字段有效，除了最初的 SYN 包，其他的包都应该设置为 1。


2. 连接建立2.1 三次握手TCP 的连接用一个四元组 {源 IP，源端口，目标 IP，目标端口} 标记，TCP 建立连接的过程叫作握手，握手过程需要交换 3 个 TCP 报文段，通常称为三次握手。

这里称为三次握手主要是遵循日常叫法，RFC 文档中的描述是 three way（three message）handshake，其实是在一次握手过程中交换了三个报文。

TCP 建立连接的过程如下：


起初客户端和服务端都处于 CLOSED 状态，服务端创建服务，进入 LISTEN（监听） 状 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/20/TCP%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/" title="TCP可靠传输与拥塞控制">TCP可靠传输与拥塞控制</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-20T09:46:26.000Z" title="发表于 2022-02-20 17:46:26">2022-02-20</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍传输控制协议 TCP（Transmission Control Proticol）是一种面向连接的、可靠的、基于字节流的通信协议，具有拥塞控制功能。在计算机网络 OSI 模型中，位于传输层。

所谓连接，即双方维护了一组数据结构记录状态，并根据一个状态机进行状态转移或者相应的处理机制。
在同一层还有用户数据报协议 UDP（User Datagram Protocol），与 TCP 基本相反，UDP 无连接、不可靠、面向报文。但这不代表使用 UDP 就无法实现可靠传输，只要在上面的应用层精心设计，也能够达到可靠传输的效果，例如 Google 的 QUIC 协议。

由于 TCP 非常复杂，在一文中介绍其全部特性是不太现实的，本文主要介绍可靠传输和拥塞控制两个特性。
首先需要关注一下 TCP 的头格式，如下所示。

其中关于可靠传输和拥塞控制主要关注以下几个部分：

Sequence Number：包的序号，用来解决网络包乱序问题。下文统一称作 seq；
Acknowledgement Number：确认收到的包序号，解决可靠传输问题。下文统一称作 ack；
Window：接收窗 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/17/HTTP%E5%8F%91%E5%B1%95%E5%8F%B2/" title="HTTP发展史">HTTP发展史</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-17T07:26:47.000Z" title="发表于 2022-02-17 15:26:47">2022-02-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">HTTP 基于 TCP 协议，默认端口是 80，HTTP 是 Web 世界中的基础协议，是现如今 Web 开发的必备知识，它也经历了多个版本的发展。
本文将介绍 HTTP 协议的发展历史。
1. HTTP/0.9HTTP/0.9 在 1991 年发布，协议内容非常简单，没有请求头，只支持 GET 命令，然后没了。
2. HTTP/1.01996 年，HTTP/1.0 发布，拓展了不少功能：

除了 GET 命令外，引入了 POST 和 HEAD 命令；
添加了 HTTP header，请求和响应都有 header 了，并且在请求 header 中指明了 http 版本；
添加了状态码，例如 200，404 等；
可以传输图像、视频等，使用 Content-Type 指明文件类型。

HTTP/1.0 极大拓展了 Web 世界的丰富程度，但也有一个主要缺点：每个 TCP 连接都只能发送一个请求。TCP 的连接需要三次握手，每次 HTTP 请求都得建立一个连接，速度较慢。除此之外，请求是串行的，每个请求必须等待上一个请求完成才可以发送。
为了解决 HTTP 短连接的问题，当时有些浏览器在请 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/17/https%E7%9A%84%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86/" title="HTTPS的加密原理">HTTPS的加密原理</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-17T01:21:32.000Z" title="发表于 2022-02-17 09:21:32">2022-02-17</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 介绍基于 TCP 的 HTTP 协议在 web 世界得到广泛使用，但由于 HTTP 采用明文传输，会存在以下问题：

通信的内容可能会被窃听，可能会泄露用户的信息；
无法验证通信方的身份，可能遭遇伪装的服务器；
无法验证报文是否遭遇篡改。

因此，在高可靠性的场合，例如银行登录、转账等，都会采用安全的 HTTPS 协议。HTTPS 其实是将HTTP 的通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。

SSL 是由 Netspace 公司设计的，3.0 版本得到大规模使用。后来互联网标准化组织 ISOC 接替 Netspace，发布了 SSL 的升级版 TLS 1.0（设计上与 SSL 3.0 几乎没有区别，TLS 1.0 通常被标示为 SSL 3.1），并在后续分别推出 TLS 1.1 和 TLS 1.2。

HTTP 直接和 TCP 通信，HTTPS 先与 SSL 通信，再由 SSL 和 TCP 通信。

2. 密码学基础在了解 HTTPS 的加密原理之前，需要先介绍一点密码学基础。
 ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/16/%E6%AD%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D/" title="死锁和处理死锁">死锁和处理死锁</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-16T10:21:04.000Z" title="发表于 2022-02-16 18:21:04">2022-02-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></span></div><div class="content">1. 死锁1.1 定义死锁的定义是：如果一个进程/线程集合中的每个进程/线程都在等待只能由该集合中其他进程/线程才能引发的事件，那么该集合是死锁的。
在大多数情况下，这个事件是释放占用的资源，换句话说，死锁就是进程/线程集合中的每个进程/线程都在等待被占用的资源，都不能被唤醒运行。
很容易用 java 实现死锁：
1234567891011121314151617181920212223242526272829303132333435363738394041public class DeadLock &#123;    private static Object resourceA = new Object();    private static Object resourceB = new Object();    public static void main(String[] args) &#123;        Thread threadA = new Thread(() -&gt; &#123;            synchronized (resourceA) &# ...</div></div></div><div class="recent-post-item"><div class="recent-post-info no-cover"><a class="article-title" href="/2022/02/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(6)%20%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B/" title="Java并发编程(6) 生产者消费者模型">Java并发编程(6) 生产者消费者模型</a><div class="article-meta-wrap"><span class="post-meta-date"><i class="far fa-calendar-alt"></i><span class="article-meta-label">发表于</span><time datetime="2022-02-16T07:24:40.000Z" title="发表于 2022-02-16 15:24:40">2022-02-16</time></span><span class="article-meta"><span class="article-meta-separator">|</span><i class="fas fa-inbox"></i><a class="article-meta__categories" href="/categories/Java/">Java</a></span></div><div class="content">1. 介绍生产者消费者问题（Producer-consumer problem），也称有限缓冲问题（Bounded-buffer problem），是一个多线程同步问题的经典案例。该问题描述了共享固定大小缓冲区的两个角色——即所谓的“生产者”和“消费者”。生产者的主要作用是生成一定量的数据放到缓冲区中，然后重复此过程。与此同时，消费者也在缓冲区消耗这些数据。该问题的关键就是要保证生产者不会在缓冲区满时加入数据，消费者也不会在缓冲区中空时消耗数据。

生产者消费者问题经常出现 Java 面试之中，一般有以下写法。
2. 使用wait和notify这是最简单的实现，缓冲区满和空都调用 wait 方法等待，当生产或者消费了一个产品，则使用 notfityAll 唤醒所有的生产者消费者。
注意：wait 和 notify 需要和 synchronized 配合使用。
1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 ...</div></div></div><nav id="pagination"><div class="pagination"><span class="page-number current">1</span><a class="page-number" href="/page/2/#content-inner">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/#content-inner">4</a><a class="extend next" rel="next" href="/page/2/#content-inner"><i class="fas fa-chevron-right fa-fw"></i></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">StrokeBun</div><div class="author-info__description">Money Oriented Programming</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">40</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/strokebun"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/25/RocketMQ%E7%9A%84%E6%B6%88%E6%81%AF%E5%AD%98%E5%82%A8/" title="RocketMQ的消息存储">RocketMQ的消息存储</a><time datetime="2022-02-25T08:43:50.000Z" title="发表于 2022-02-25 16:43:50">2022-02-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/24/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A6%82%E8%BF%B0/" title="消息队列概述">消息队列概述</a><time datetime="2022-02-24T01:00:37.000Z" title="发表于 2022-02-24 09:00:37">2022-02-24</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/22/HTTP%20GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/" title="HTTP GET和POST的区别">HTTP GET和POST的区别</a><time datetime="2022-02-22T06:30:13.000Z" title="发表于 2022-02-22 14:30:13">2022-02-22</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/21/TCP%E7%9A%84%E7%B2%98%E5%8C%85/" title="TCP的粘包">TCP的粘包</a><time datetime="2022-02-21T08:50:21.000Z" title="发表于 2022-02-21 16:50:21">2022-02-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/02/21/TCP%E7%9A%84%E8%BF%9E%E6%8E%A5%E4%B8%8E%E9%87%8A%E6%94%BE/" title="TCP连接的建立与释放">TCP连接的建立与释放</a><time datetime="2022-02-21T02:42:36.000Z" title="发表于 2022-02-21 10:42:36">2022-02-21</time></div></div></div></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Java/"><span class="card-category-list-name">Java</span><span class="card-category-list-count">11</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"><span class="card-category-list-name">中间件</span><span class="card-category-list-count">6</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%86%99%E5%A5%BD%E4%BB%A3%E7%A0%81/"><span class="card-category-list-name">写好代码</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"><span class="card-category-list-name">分布式</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="card-category-list-name">数据库</span><span class="card-category-list-count">4</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/"><span class="card-category-list-name">系统设计</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"><span class="card-category-list-name">计算机基础</span><span class="card-category-list-count">11</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/%E9%9D%A2%E8%AF%95/"><span class="card-category-list-name">面试</span><span class="card-category-list-count">1</span></a></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/JVM/" style="font-size: 1.3em; color: #99a1ac">JVM</a> <a href="/tags/Java-IO/" style="font-size: 1.1em; color: #999">Java IO</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 1.5em; color: #99a9bf">Java并发编程</a> <a href="/tags/MySQL/" style="font-size: 1.4em; color: #99a5b6">MySQL</a> <a href="/tags/Redis/" style="font-size: 1.4em; color: #99a5b6">Redis</a> <a href="/tags/netty/" style="font-size: 1.1em; color: #999">netty</a> <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" style="font-size: 1.1em; color: #999">分布式</a> <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.2em; color: #999da3">操作系统</a> <a href="/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/" style="font-size: 1.1em; color: #999">智力题</a> <a href="/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 1.2em; color: #999da3">消息队列</a> <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" style="font-size: 1.1em; color: #999">系统设计</a> <a href="/tags/%E7%BC%96%E7%A8%8B%E6%80%9D%E7%BB%B4/" style="font-size: 1.1em; color: #999">编程思维</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.3em; color: #99a1ac">计算机组成原理</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.5em; color: #99a9bf">计算机网络</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 1.4em; color: #99a5b6">设计模式</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/02/"><span class="card-archive-list-date">二月 2022</span><span class="card-archive-list-count">28</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2022/01/"><span class="card-archive-list-date">一月 2022</span><span class="card-archive-list-count">12</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">40</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2022-02-25T12:35:08.298Z"></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By StrokeBun</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"><script>function subtitleType () {
  if (false) { 
    window.typed = new Typed("#subtitle", {
      strings: ["怕什么真理无穷&#44;进一步有进一步的欢喜"],
      startDelay: 300,
      typeSpeed: 150,
      loop: false,
      backSpeed: 50
    })
  } else {
    document.getElementById("subtitle").innerHTML = '怕什么真理无穷&#44;进一步有进一步的欢喜'
  }
}

if (false) {
  if (typeof Typed === 'function') {
    subtitleType()
  } else {
    getScript('https://cdn.jsdelivr.net/npm/typed.js/lib/typed.min.js').then(subtitleType)
  }
} else {
  subtitleType()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>